<html class="_theme-default">
<head>
    <meta charset="utf-8">
    <title>.. Named entities without a namespace</title>
    
    <link rel="preload" href="../../assets/index.js" as="script" type="text/javascript" />

    <link rel="stylesheet" type="text/css" href="../../application.css" />
    <link rel="stylesheet" type="text/css" href="../../assets/index.css" />
</head>
<body>
    <div class="_app">
        <devdocs-navbar current="reference/names/namespaces" prefix="../../" listing-src="../../navbar.json"></devdocs-navbar>
        <div class="_container">
            <main class="_content">
                <div class="_page _rust"><h1 class="rule" id="r-names.namespaces">
<a class="rule-link" href="#r-names.namespaces" title="names.namespaces"><span>[names<wbr>.namespaces]</wbr></span></a> </h1> <h1 id="namespaces">Namespaces</h1> <div class="rule" id="r-names.namespaces.intro">
<a class="rule-link" href="#r-names.namespaces.intro" title="names.namespaces.intro"><span>[names<wbr>.namespaces<wbr>.intro]</wbr></wbr></span></a> </div> <p>A <em>namespace</em> is a logical grouping of declared <a href="../names">names</a>. Names are segregated into separate namespaces based on the kind of entity the name refers to. Namespaces allow the occurrence of a name in one namespace to not conflict with the same name in another namespace.</p> <p>There are several different namespaces that each contain different kinds of entities. The usage of a name will look for the declaration of that name in different namespaces, based on the context, as described in the <a href="name-resolution">name resolution</a> chapter.</p> <div class="rule" id="r-names.namespaces.kinds">
<a class="rule-link" href="#r-names.namespaces.kinds" title="names.namespaces.kinds"><span>[names<wbr>.namespaces<wbr>.kinds]</wbr></wbr></span></a> </div> <p>The following is a list of namespaces, with their corresponding entities:</p> <ul> <li>Type Namespace <ul> <li><a href="../items/modules">Module declarations</a></li> <li><a href="../items/extern-crates">External crate declarations</a></li> <li>
<a href="preludes#extern-prelude">External crate prelude</a> items</li> <li>
<a href="../items/structs">Struct</a>, <a href="../items/unions">union</a>, <a href="../items/enumerations">enum</a>, enum variant declarations</li> <li><a href="../items/traits">Trait item declarations</a></li> <li><a href="../items/type-aliases">Type aliases</a></li> <li><a href="../items/associated-items#associated-types">Associated type declarations</a></li> <li>Built-in types: <a href="../types/boolean">boolean</a>, <a href="../types/numeric">numeric</a>, and <a href="../types/textual">textual</a>
</li> <li><a href="../items/generics">Generic type parameters</a></li> <li><a href="../paths#self-1"><code>Self</code> type</a></li> <li><a href="../attributes#tool-attributes">Tool attribute modules</a></li> </ul> </li> <li>Value Namespace <ul> <li><a href="../items/functions">Function declarations</a></li> <li><a href="../items/constant-items">Constant item declarations</a></li> <li><a href="../items/static-items">Static item declarations</a></li> <li><a href="../items/structs">Struct constructors</a></li> <li><a href="../items/enumerations">Enum variant constructors</a></li> <li><a href="../paths#self-1"><code>Self</code> constructors</a></li> <li><a href="../items/generics#const-generics">Generic const parameters</a></li> <li><a href="../items/associated-items#associated-constants">Associated const declarations</a></li> <li><a href="../items/associated-items#associated-functions-and-methods">Associated function declarations</a></li> <li>Local bindings â€” <a href="../statements#let-statements"><code>let</code></a>, <a href="../expressions/if-expr#if-let-patterns"><code>if let</code></a>, <a href="../expressions/loop-expr#while-let-patterns"><code>while let</code></a>, <a href="../expressions/loop-expr#iterator-loops"><code>for</code></a>, <a href="../expressions/match-expr"><code>match</code></a> arms, <a href="../items/functions#function-parameters">function parameters</a>, <a href="../expressions/closure-expr">closure parameters</a>
</li> <li>Captured <a href="../expressions/closure-expr">closure</a> variables</li> </ul> </li> <li>Macro Namespace <ul> <li><a href="../macros-by-example"><code>macro_rules</code> declarations</a></li> <li><a href="../attributes#built-in-attributes-index">Built-in attributes</a></li> <li><a href="../attributes#tool-attributes">Tool attributes</a></li> <li><a href="../procedural-macros#function-like-procedural-macros">Function-like procedural macros</a></li> <li><a href="../procedural-macros#derive-macros">Derive macros</a></li> <li><a href="../procedural-macros#derive-macro-helper-attributes">Derive macro helpers</a></li> <li><a href="../procedural-macros#attribute-macros">Attribute macros</a></li> </ul> </li> <li>Lifetime Namespace <ul> <li><a href="../items/generics">Generic lifetime parameters</a></li> </ul> </li> <li>Label Namespace <ul> <li><a href="../expressions/loop-expr#loop-labels">Loop labels</a></li> <li><a href="../expressions/loop-expr#labelled-block-expressions">Block labels</a></li> </ul> </li> </ul> <p>An example of how overlapping names in different namespaces can be used unambiguously:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
// Foo introduces a type in the type namespace and a constructor in the value
// namespace.
struct Foo(u32);

// The `Foo` macro is declared in the macro namespace.
macro_rules! Foo {
    () =&gt; {};
}

// `Foo` in the `f` parameter type refers to `Foo` in the type namespace.
// `'Foo` introduces a new lifetime in the lifetime namespace.
fn example&lt;'Foo&gt;(f: Foo) {
    // `Foo` refers to the `Foo` constructor in the value namespace.
    let ctor = Foo;
    // `Foo` refers to the `Foo` macro in the macro namespace.
    Foo!{}
    // `'Foo` introduces a label in the label namespace.
    'Foo: loop {
        // `'Foo` refers to the `'Foo` lifetime parameter, and `Foo`
        // refers to the type namespace.
        let x: &amp;'Foo Foo;
        // `'Foo` refers to the label.
        break 'Foo;
    }
}
}</pre> <div class="rule" id="r-names.namespaces.without">
<a class="rule-link" href="#r-names.namespaces.without" title="names.namespaces.without"><span>[names<wbr>.namespaces<wbr>.without]</wbr></wbr></span></a> </div> <h2 id="named-entities-without-a-namespace">Named entities without a namespace</h2> <p>The following entities have explicit names, but the names are not a part of any specific namespace.</p> <h3 id="fields">Fields</h3> <div class="rule" id="r-names.namespaces.without.fields">
<a class="rule-link" href="#r-names.namespaces.without.fields" title="names.namespaces.without.fields"><span>[names<wbr>.namespaces<wbr>.without<wbr>.fields]</wbr></wbr></wbr></span></a> </div> <p>Even though struct, enum, and union fields are named, the named fields do not live in an explicit namespace. They can only be accessed via a <a href="../expressions/field-expr">field expression</a>, which only inspects the field names of the specific type being accessed.</p> <h3 id="use-declarations">Use declarations</h3> <div class="rule" id="r-names.namespaces.without.use">
<a class="rule-link" href="#r-names.namespaces.without.use" title="names.namespaces.without.use"><span>[names<wbr>.namespaces<wbr>.without<wbr>.use]</wbr></wbr></wbr></span></a> </div> <p>A <a href="../items/use-declarations">use declaration</a> has named aliases that it imports into scope, but the <code>use</code> item itself does not belong to a specific namespace. Instead, it can introduce aliases into multiple namespaces, depending on the item kind being imported.</p> <div class="rule" id="r-names.namespaces.sub-namespaces">
<a class="rule-link" href="#r-names.namespaces.sub-namespaces" title="names.namespaces.sub-namespaces"><span>[names<wbr>.namespaces<wbr>.sub-namespaces]</wbr></wbr></span></a> </div> <h2 id="sub-namespaces">Sub-namespaces</h2> <div class="rule" id="r-names.namespaces.sub-namespaces.intro">
<a class="rule-link" href="#r-names.namespaces.sub-namespaces.intro" title="names.namespaces.sub-namespaces.intro"><span>[names<wbr>.namespaces<wbr>.sub-namespaces<wbr>.intro]</wbr></wbr></wbr></span></a> </div> <p>The macro namespace is split into two sub-namespaces: one for <a href="../macros">bang-style macros</a> and one for <a href="../attributes">attributes</a>. When an attribute is resolved, any bang-style macros in scope will be ignored. And conversely resolving a bang-style macro will ignore attribute macros in scope. This prevents one style from shadowing another.</p> <p>For example, the <a href="../conditional-compilation#the-cfg-attribute"><code>cfg</code> attribute</a> and the <a href="../conditional-compilation#the-cfg-macro"><code>cfg</code> macro</a> are two different entities with the same name in the macro namespace, but they can still be used in their respective context.</p> <div class="rule" id="r-names.namespaces.sub-namespaces.use-shadow">
<a class="rule-link" href="#r-names.namespaces.sub-namespaces.use-shadow" title="names.namespaces.sub-namespaces.use-shadow"><span>[names<wbr>.namespaces<wbr>.sub-namespaces<wbr>.use-shadow]</wbr></wbr></wbr></span></a> </div> <p>It is still an error for a <a href="../items/use-declarations"><code>use</code> import</a> to shadow another macro, regardless of their sub-namespaces.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/reference/names/namespaces.html" class="_attribution-link">https://doc.rust-lang.org/reference/names/namespaces.html</a>
  </p>
</div>
</div>
            </main>
        </div>
    </div>
    <script type="text/javascript" src="../../assets/index.js"></script>
</body>

</html>