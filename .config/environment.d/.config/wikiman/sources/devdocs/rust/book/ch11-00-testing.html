<html class="_theme-default">
<head>
    <meta charset="utf-8">
    <title>11.00. The Rust Programming Language</title>
    
    <link rel="preload" href="../assets/index.js" as="script" type="text/javascript" />

    <link rel="stylesheet" type="text/css" href="../application.css" />
    <link rel="stylesheet" type="text/css" href="../assets/index.css" />
</head>
<body>
    <div class="_app">
        <devdocs-navbar current="book/ch11-00-testing" prefix="../" listing-src="../navbar.json"></devdocs-navbar>
        <div class="_container">
            <main class="_content">
                <div class="_page _rust"><h1 id="writing-automated-tests">Writing Automated Tests</h1> <p>In his 1972 essay “The Humble Programmer,” Edsger W. Dijkstra said that “program testing can be a very effective way to show the presence of bugs, but it is hopelessly inadequate for showing their absence.” That doesn’t mean we shouldn’t try to test as much as we can!</p> <p>Correctness in our programs is the extent to which our code does what we intend it to do. Rust is designed with a high degree of concern about the correctness of programs, but correctness is complex and not easy to prove. Rust’s type system shoulders a huge part of this burden, but the type system cannot catch everything. As such, Rust includes support for writing automated software tests.</p> <p>Say we write a function <code>add_two</code> that adds 2 to whatever number is passed to it. This function’s signature accepts an integer as a parameter and returns an integer as a result. When we implement and compile that function, Rust does all the type checking and borrow checking that you’ve learned so far to ensure that, for instance, we aren’t passing a <code>String</code> value or an invalid reference to this function. But Rust <em>can’t</em> check that this function will do precisely what we intend, which is return the parameter plus 2 rather than, say, the parameter plus 10 or the parameter minus 50! That’s where tests come in.</p> <p>We can write tests that assert, for example, that when we pass <code>3</code> to the <code>add_two</code> function, the returned value is <code>5</code>. We can run these tests whenever we make changes to our code to make sure any existing correct behavior has not changed.</p> <p>Testing is a complex skill: although we can’t cover in one chapter every detail about how to write good tests, in this chapter we will discuss the mechanics of Rust’s testing facilities. We’ll talk about the annotations and macros available to you when writing your tests, the default behavior and options provided for running your tests, and how to organize tests into unit tests and integration tests.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/book/ch11-00-testing.html" class="_attribution-link">https://doc.rust-lang.org/book/ch11-00-testing.html</a>
  </p>
</div>
</div>
            </main>
        </div>
    </div>
    <script type="text/javascript" src="../assets/index.js"></script>
</body>

</html>