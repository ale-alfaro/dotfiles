<html class="_theme-default">
<head>
    <meta charset="utf-8">
    <title>std::zeroed</title>
    
    <link rel="preload" href="../../assets/index.js" as="script" type="text/javascript" />

    <link rel="stylesheet" type="text/css" href="../../application.css" />
    <link rel="stylesheet" type="text/css" href="../../assets/index.css" />
</head>
<body>
    <div class="_app">
        <devdocs-navbar current="std/mem/fn.zeroed" prefix="../../" listing-src="../../navbar.json"></devdocs-navbar>
        <div class="_container">
            <main class="_content">
                <div class="_page _rust"><h1 class="main-heading">Function zeroed</h1>
<pre class="rust item-decl" data-language="rust">pub const unsafe fn zeroed&lt;T&gt;() -&gt; T</pre>
<p>Returns the value of type <code>T</code> represented by the all-zero byte-pattern.</p> <p>This means that, for example, the padding byte in <code>(u8, u16)</code> is not necessarily zeroed.</p> <p>There is no guarantee that an all-zero byte-pattern represents a valid value of some type <code>T</code>. For example, the all-zero byte-pattern is not a valid value for reference types (<code>&amp;T</code>, <code>&amp;mut T</code>) and function pointers. Using <code>zeroed</code> on such types causes immediate <a href="../../reference/behavior-considered-undefined">undefined behavior</a> because <a href="union.maybeuninit#initialization-invariant" title="union std::mem::MaybeUninit">the Rust compiler assumes</a> that there always is a valid value in a variable it considers initialized.</p> <p>This has the same effect as <a href="union.maybeuninit#method.zeroed" title="associated function std::mem::MaybeUninit::zeroed"><code>MaybeUninit::zeroed().assume_init()</code></a>. It is useful for FFI sometimes, but should generally be avoided.</p> <h2 id="examples">Examples</h2> <p>Correct usage of this function: initializing an integer with zero.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::mem;

let x: i32 = unsafe { mem::zeroed() };
assert_eq!(0, x);</pre></div> <p><em>Incorrect</em> usage of this function: initializing a reference with zero.</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::mem;

let _x: &amp;i32 = unsafe { mem::zeroed() }; // Undefined behavior!
let _y: fn() = unsafe { mem::zeroed() }; // And again!</pre></div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/mem/fn.zeroed.html" class="_attribution-link">https://doc.rust-lang.org/std/mem/fn.zeroed.html</a>
  </p>
</div>
</div>
            </main>
        </div>
    </div>
    <script type="text/javascript" src="../../assets/index.js"></script>
</body>

</html>