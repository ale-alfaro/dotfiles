<html class="_theme-default">
<head>
    <meta charset="utf-8">
    <title>std::ffi</title>
    
    <link rel="preload" href="../../../../assets/index.js" as="script" type="text/javascript" />

    <link rel="stylesheet" type="text/css" href="../../../../application.css" />
    <link rel="stylesheet" type="text/css" href="../../../../assets/index.css" />
</head>
<body>
    <div class="_app">
        <devdocs-navbar current="std/os/windows/ffi/index" prefix="../../../../" listing-src="../../../../navbar.json"></devdocs-navbar>
        <div class="_container">
            <main class="_content">
                <div class="_page _rust"><h1 class="main-heading">Module ffi</h1>
<span class="item-info"><div class="stab portability">Available on <strong>Windows</strong> only.</div></span><p>Windows-specific extensions to primitives in the <a href="../../../ffi/index" title="mod std::ffi"><code>std::ffi</code></a> module.</p> <h2 id="overview">Overview</h2> <p>For historical reasons, the Windows API uses a form of potentially ill-formed UTF-16 encoding for strings. Specifically, the 16-bit code units in Windows strings may contain <a href="https://simonsapin.github.io/wtf-8/#ill-formed-utf-16">isolated surrogate code points which are not paired together</a>. The Unicode standard requires that surrogate code points (those in the range U+D800 to U+DFFF) always be <em>paired</em>, because in the UTF-16 encoding a <em>surrogate code unit pair</em> is used to encode a single character. For compatibility with code that does not enforce these pairings, Windows does not enforce them, either.</p> <p>While it is not always possible to convert such a string losslessly into a valid UTF-16 string (or even UTF-8), it is often desirable to be able to round-trip such a string from and to Windows APIs losslessly. For example, some Rust code may be “bridging” some Windows APIs together, just passing <code>WCHAR</code> strings among those APIs without ever really looking into the strings.</p> <p>If Rust code <em>does</em> need to look into those strings, it can convert them to valid UTF-8, possibly lossily, by substituting invalid sequences with <a href="../../../char/constant.replacement_character" title="constant std::char::REPLACEMENT_CHARACTER"><code>U+FFFD REPLACEMENT CHARACTER</code></a>, as is conventionally done in other Rust APIs that deal with string encodings.</p> <h2 id="osstringext-and-osstrext">
<code>OsStringExt</code> and <code>OsStrExt</code>
</h2> <p><a href="../../../ffi/struct.osstring" title="struct std::ffi::OsString"><code>OsString</code></a> is the Rust wrapper for owned strings in the preferred representation of the operating system. On Windows, this struct gets augmented with an implementation of the <a href="trait.osstringext" title="trait std::os::windows::ffi::OsStringExt"><code>OsStringExt</code></a> trait, which has an <a href="trait.osstringext#tymethod.from_wide" title="associated function std::os::windows::ffi::OsStringExt::from_wide"><code>OsStringExt::from_wide</code></a> method. This lets you create an <a href="../../../ffi/struct.osstring" title="struct std::ffi::OsString"><code>OsString</code></a> from a <code>&amp;[u16]</code> slice; presumably you get such a slice out of a <code>WCHAR</code> Windows API.</p> <p>Similarly, <a href="../../../ffi/struct.osstr" title="struct std::ffi::OsStr"><code>OsStr</code></a> is the Rust wrapper for borrowed strings from preferred representation of the operating system. On Windows, the <a href="trait.osstrext" title="trait std::os::windows::ffi::OsStrExt"><code>OsStrExt</code></a> trait provides the <a href="trait.osstrext#tymethod.encode_wide" title="method std::os::windows::ffi::OsStrExt::encode_wide"><code>OsStrExt::encode_wide</code></a> method, which outputs an <a href="struct.encodewide" title="struct std::os::windows::ffi::EncodeWide"><code>EncodeWide</code></a> iterator. You can <a href="../../../iter/trait.iterator#method.collect" title="method std::iter::Iterator::collect"><code>collect</code></a> this iterator, for example, to obtain a <code>Vec&lt;u16&gt;</code>; you can later get a pointer to this vector’s contents and feed it to Windows APIs.</p> <p>These traits, along with <a href="../../../ffi/struct.osstring" title="struct std::ffi::OsString"><code>OsString</code></a> and <a href="../../../ffi/struct.osstr" title="struct std::ffi::OsStr"><code>OsStr</code></a>, work in conjunction so that it is possible to <strong>round-trip</strong> strings from Windows and back, with no loss of data, even if the strings are ill-formed UTF-16.</p> <h3 id="structs" class="section-header">Structs</h3>
<dl class="item-table">
<dt><a class="struct" href="struct.encodewide" title="struct std::os::windows::ffi::EncodeWide">Encode<wbr>Wide</wbr></a></dt>
<dd>Generates a wide character sequence for potentially ill-formed UTF-16.</dd>
</dl>
<h3 id="traits" class="section-header">Traits</h3>
<dl class="item-table">
<dt><a class="trait" href="trait.osstrext" title="trait std::os::windows::ffi::OsStrExt">OsStr<wbr>Ext</wbr></a></dt>
<dd>Windows-specific extensions to <a href="../../../ffi/struct.osstr" title="struct std::ffi::OsStr"><code>OsStr</code></a>.</dd>
<dt><a class="trait" href="trait.osstringext" title="trait std::os::windows::ffi::OsStringExt">OsString<wbr>Ext</wbr></a></dt>
<dd>Windows-specific extensions to <a href="../../../ffi/struct.osstring" title="struct std::ffi::OsString"><code>OsString</code></a>.</dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/os/windows/ffi/index.html" class="_attribution-link">https://doc.rust-lang.org/std/os/windows/ffi/index.html</a>
  </p>
</div>
</div>
            </main>
        </div>
    </div>
    <script type="text/javascript" src="../../../../assets/index.js"></script>
</body>

</html>