<html class="_theme-default">
<head>
    <meta charset="utf-8">
    <title>std::slice</title>
    
    <link rel="preload" href="../../assets/index.js" as="script" type="text/javascript" />

    <link rel="stylesheet" type="text/css" href="../../application.css" />
    <link rel="stylesheet" type="text/css" href="../../assets/index.css" />
</head>
<body>
    <div class="_app">
        <devdocs-navbar current="std/slice/index" prefix="../../" listing-src="../../navbar.json"></devdocs-navbar>
        <div class="_container">
            <main class="_content">
                <div class="_page _rust"><h1 class="main-heading">Module slice</h1>
<p>Utilities for the slice primitive type.</p> <p><em><a href="../primitive.slice" title="primitive slice">See also the slice primitive type</a>.</em></p> <p>Most of the structs in this module are iterator types which can only be created using a certain function. For example, <code>slice.iter()</code> yields an <a href="struct.iter" title="struct std::slice::Iter"><code>Iter</code></a>.</p> <p>A few functions are provided to create a slice from a value reference or from a raw pointer.</p> <h3 id="structs" class="section-header">Structs</h3>
<dl class="item-table">
<dt><a class="struct" href="struct.chunkby" title="struct std::slice::ChunkBy">ChunkBy</a></dt>
<dd>An iterator over slice in (non-overlapping) chunks separated by a predicate.</dd>
<dt><a class="struct" href="struct.chunkbymut" title="struct std::slice::ChunkByMut">Chunk<wbr>ByMut</wbr></a></dt>
<dd>An iterator over slice in (non-overlapping) mutable chunks separated by a predicate.</dd>
<dt><a class="struct" href="struct.chunks" title="struct std::slice::Chunks">Chunks</a></dt>
<dd>An iterator over a slice in (non-overlapping) chunks (<code>chunk_size</code> elements at a time), starting at the beginning of the slice.</dd>
<dt><a class="struct" href="struct.chunksexact" title="struct std::slice::ChunksExact">Chunks<wbr>Exact</wbr></a></dt>
<dd>An iterator over a slice in (non-overlapping) chunks (<code>chunk_size</code> elements at a time), starting at the beginning of the slice.</dd>
<dt><a class="struct" href="struct.chunksexactmut" title="struct std::slice::ChunksExactMut">Chunks<wbr>Exact<wbr>Mut</wbr></wbr></a></dt>
<dd>An iterator over a slice in (non-overlapping) mutable chunks (<code>chunk_size</code> elements at a time), starting at the beginning of the slice.</dd>
<dt><a class="struct" href="struct.chunksmut" title="struct std::slice::ChunksMut">Chunks<wbr>Mut</wbr></a></dt>
<dd>An iterator over a slice in (non-overlapping) mutable chunks (<code>chunk_size</code> elements at a time), starting at the beginning of the slice.</dd>
<dt><a class="struct" href="struct.escapeascii" title="struct std::slice::EscapeAscii">Escape<wbr>Ascii</wbr></a></dt>
<dd>An iterator over the escaped version of a byte slice.</dd>
<dt><a class="struct" href="struct.iter" title="struct std::slice::Iter">Iter</a></dt>
<dd>Immutable slice iterator</dd>
<dt><a class="struct" href="struct.itermut" title="struct std::slice::IterMut">IterMut</a></dt>
<dd>Mutable slice iterator.</dd>
<dt><a class="struct" href="struct.rchunks" title="struct std::slice::RChunks">RChunks</a></dt>
<dd>An iterator over a slice in (non-overlapping) chunks (<code>chunk_size</code> elements at a time), starting at the end of the slice.</dd>
<dt><a class="struct" href="struct.rchunksexact" title="struct std::slice::RChunksExact">RChunks<wbr>Exact</wbr></a></dt>
<dd>An iterator over a slice in (non-overlapping) chunks (<code>chunk_size</code> elements at a time), starting at the end of the slice.</dd>
<dt><a class="struct" href="struct.rchunksexactmut" title="struct std::slice::RChunksExactMut">RChunks<wbr>Exact<wbr>Mut</wbr></wbr></a></dt>
<dd>An iterator over a slice in (non-overlapping) mutable chunks (<code>chunk_size</code> elements at a time), starting at the end of the slice.</dd>
<dt><a class="struct" href="struct.rchunksmut" title="struct std::slice::RChunksMut">RChunks<wbr>Mut</wbr></a></dt>
<dd>An iterator over a slice in (non-overlapping) mutable chunks (<code>chunk_size</code> elements at a time), starting at the end of the slice.</dd>
<dt><a class="struct" href="struct.rsplit" title="struct std::slice::RSplit">RSplit</a></dt>
<dd>An iterator over subslices separated by elements that match a predicate function, starting from the end of the slice.</dd>
<dt><a class="struct" href="struct.rsplitmut" title="struct std::slice::RSplitMut">RSplit<wbr>Mut</wbr></a></dt>
<dd>An iterator over the subslices of the vector which are separated by elements that match <code>pred</code>, starting from the end of the slice.</dd>
<dt><a class="struct" href="struct.rsplitn" title="struct std::slice::RSplitN">RSplitN</a></dt>
<dd>An iterator over subslices separated by elements that match a predicate function, limited to a given number of splits, starting from the end of the slice.</dd>
<dt><a class="struct" href="struct.rsplitnmut" title="struct std::slice::RSplitNMut">RSplitN<wbr>Mut</wbr></a></dt>
<dd>An iterator over subslices separated by elements that match a predicate function, limited to a given number of splits, starting from the end of the slice.</dd>
<dt><a class="struct" href="struct.split" title="struct std::slice::Split">Split</a></dt>
<dd>An iterator over subslices separated by elements that match a predicate function.</dd>
<dt><a class="struct" href="struct.splitinclusive" title="struct std::slice::SplitInclusive">Split<wbr>Inclusive</wbr></a></dt>
<dd>An iterator over subslices separated by elements that match a predicate function. Unlike <code>Split</code>, it contains the matched part as a terminator of the subslice.</dd>
<dt><a class="struct" href="struct.splitinclusivemut" title="struct std::slice::SplitInclusiveMut">Split<wbr>Inclusive<wbr>Mut</wbr></wbr></a></dt>
<dd>An iterator over the mutable subslices of the vector which are separated by elements that match <code>pred</code>. Unlike <code>SplitMut</code>, it contains the matched parts in the ends of the subslices.</dd>
<dt><a class="struct" href="struct.splitmut" title="struct std::slice::SplitMut">Split<wbr>Mut</wbr></a></dt>
<dd>An iterator over the mutable subslices of the vector which are separated by elements that match <code>pred</code>.</dd>
<dt><a class="struct" href="struct.splitn" title="struct std::slice::SplitN">SplitN</a></dt>
<dd>An iterator over subslices separated by elements that match a predicate function, limited to a given number of splits.</dd>
<dt><a class="struct" href="struct.splitnmut" title="struct std::slice::SplitNMut">SplitN<wbr>Mut</wbr></a></dt>
<dd>An iterator over subslices separated by elements that match a predicate function, limited to a given number of splits.</dd>
<dt><a class="struct" href="struct.windows" title="struct std::slice::Windows">Windows</a></dt>
<dd>An iterator over overlapping subslices of length <code>size</code>.</dd>
<dt>
<a class="struct" href="struct.arraychunks" title="struct std::slice::ArrayChunks">Array<wbr>Chunks</wbr></a><wbr><span class="stab unstable" title="">Experimental</span></wbr>
</dt>
<dd>An iterator over a slice in (non-overlapping) chunks (<code>N</code> elements at a time), starting at the beginning of the slice.</dd>
<dt>
<a class="struct" href="struct.arraychunksmut" title="struct std::slice::ArrayChunksMut">Array<wbr>Chunks<wbr>Mut</wbr></wbr></a><wbr><span class="stab unstable" title="">Experimental</span></wbr>
</dt>
<dd>An iterator over a slice in (non-overlapping) mutable chunks (<code>N</code> elements at a time), starting at the beginning of the slice.</dd>
<dt>
<a class="struct" href="struct.arraywindows" title="struct std::slice::ArrayWindows">Array<wbr>Windows</wbr></a><wbr><span class="stab unstable" title="">Experimental</span></wbr>
</dt>
<dd>A windowed iterator over a slice in overlapping chunks (<code>N</code> elements at a time), starting at the beginning of the slice</dd>
</dl>
<h3 id="enums" class="section-header">Enums</h3>
<dl class="item-table">
<dt><a class="enum" href="enum.getdisjointmuterror" title="enum std::slice::GetDisjointMutError">GetDisjoint<wbr>MutError</wbr></a></dt>
<dd>The error type returned by <a href="../primitive.slice#method.get_disjoint_mut" title="method slice::get_disjoint_mut"><code>get_disjoint_mut</code></a>.</dd>
</dl>
<h3 id="traits" class="section-header">Traits</h3>
<dl class="item-table">
<dt><a class="trait" href="trait.sliceindex" title="trait std::slice::SliceIndex">Slice<wbr>Index</wbr></a></dt>
<dd>A helper trait used for indexing operations.</dd>
<dt>
<a class="trait" href="trait.concat" title="trait std::slice::Concat">Concat</a><wbr><span class="stab unstable" title="">Experimental</span></wbr>
</dt>
<dd>Helper trait for <a href="../primitive.slice#method.concat" title="method slice::concat"><code>[T]::concat</code></a>.</dd>
<dt>
<a class="trait" href="trait.join" title="trait std::slice::Join">Join</a><wbr><span class="stab unstable" title="">Experimental</span></wbr>
</dt>
<dd>Helper trait for <a href="../primitive.slice#method.join" title="method slice::join"><code>[T]::join</code></a>
</dd>
</dl>
<h3 id="functions" class="section-header">Functions</h3>
<dl class="item-table">
<dt><a class="fn" href="fn.from_mut" title="fn std::slice::from_mut">from_<wbr>mut</wbr></a></dt>
<dd>Converts a reference to T into a slice of length 1 (without copying).</dd>
<dt>
<a class="fn" href="fn.from_raw_parts" title="fn std::slice::from_raw_parts">from_<wbr>raw_<wbr>parts</wbr></wbr></a><sup title="unsafe function">⚠</sup>
</dt>
<dd>Forms a slice from a pointer and a length.</dd>
<dt>
<a class="fn" href="fn.from_raw_parts_mut" title="fn std::slice::from_raw_parts_mut">from_<wbr>raw_<wbr>parts_<wbr>mut</wbr></wbr></wbr></a><sup title="unsafe function">⚠</sup>
</dt>
<dd>Performs the same functionality as <a href="fn.from_raw_parts" title="fn std::slice::from_raw_parts"><code>from_raw_parts</code></a>, except that a mutable slice is returned.</dd>
<dt><a class="fn" href="fn.from_ref" title="fn std::slice::from_ref">from_<wbr>ref</wbr></a></dt>
<dd>Converts a reference to T into a slice of length 1 (without copying).</dd>
<dt>
<a class="fn" href="fn.from_mut_ptr_range" title="fn std::slice::from_mut_ptr_range">from_<wbr>mut_<wbr>ptr_<wbr>range</wbr></wbr></wbr></a><sup title="unsafe function">⚠</sup><wbr><span class="stab unstable" title="">Experimental</span></wbr>
</dt>
<dd>Forms a mutable slice from a pointer range.</dd>
<dt>
<a class="fn" href="fn.from_ptr_range" title="fn std::slice::from_ptr_range">from_<wbr>ptr_<wbr>range</wbr></wbr></a><sup title="unsafe function">⚠</sup><wbr><span class="stab unstable" title="">Experimental</span></wbr>
</dt>
<dd>Forms a slice from a pointer range.</dd>
<dt>
<a class="fn" href="fn.range" title="fn std::slice::range">range</a><wbr><span class="stab unstable" title="">Experimental</span></wbr>
</dt>
<dd>Performs bounds checking of a range.</dd>
<dt>
<a class="fn" href="fn.try_range" title="fn std::slice::try_range">try_<wbr>range</wbr></a><wbr><span class="stab unstable" title="">Experimental</span></wbr>
</dt>
<dd>Performs bounds checking of a range without panicking.</dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/slice/index.html" class="_attribution-link">https://doc.rust-lang.org/std/slice/index.html</a>
  </p>
</div>
</div>
            </main>
        </div>
    </div>
    <script type="text/javascript" src="../../assets/index.js"></script>
</body>

</html>