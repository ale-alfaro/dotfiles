<html class="_theme-default">
<head>
    <meta charset="utf-8">
    <title>std::compiler_fence</title>
    
    <link rel="preload" href="../../../assets/index.js" as="script" type="text/javascript" />

    <link rel="stylesheet" type="text/css" href="../../../application.css" />
    <link rel="stylesheet" type="text/css" href="../../../assets/index.css" />
</head>
<body>
    <div class="_app">
        <devdocs-navbar current="std/sync/atomic/fn.compiler_fence" prefix="../../../" listing-src="../../../navbar.json"></devdocs-navbar>
        <div class="_container">
            <main class="_content">
                <div class="_page _rust"><h1 class="main-heading">Function compiler_fence</h1>
<pre class="rust item-decl" data-language="rust">pub fn compiler_fence(order: Ordering)</pre>
<p>A “compiler-only” atomic fence.</p> <p>Like <a href="fn.fence" title="fn std::sync::atomic::fence"><code>fence</code></a>, this function establishes synchronization with other atomic operations and fences. However, unlike <a href="fn.fence" title="fn std::sync::atomic::fence"><code>fence</code></a>, <code>compiler_fence</code> only establishes synchronization with operations <em>in the same thread</em>. This may at first sound rather useless, since code within a thread is typically already totally ordered and does not need any further synchronization. However, there are cases where code can run on the same thread without being ordered:</p> <ul> <li>The most common case is that of a <em>signal handler</em>: a signal handler runs in the same thread as the code it interrupted, but it is not ordered with respect to that code. <code>compiler_fence</code> can be used to establish synchronization between a thread and its signal handler, the same way that <code>fence</code> can be used to establish synchronization across threads.</li> <li>Similar situations can arise in embedded programming with interrupt handlers, or in custom implementations of preemptive green threads. In general, <code>compiler_fence</code> can establish synchronization with code that is guaranteed to run on the same hardware CPU.</li> </ul> <p>See <a href="fn.fence" title="fn std::sync::atomic::fence"><code>fence</code></a> for how a fence can be used to achieve synchronization. Note that just like <a href="fn.fence" title="fn std::sync::atomic::fence"><code>fence</code></a>, synchronization still requires atomic operations to be used in both threads – it is not possible to perform synchronization entirely with fences and non-atomic operations.</p> <p><code>compiler_fence</code> does not emit any machine code, but restricts the kinds of memory re-ordering the compiler is allowed to do. <code>compiler_fence</code> corresponds to <a href="https://en.cppreference.com/w/cpp/atomic/atomic_signal_fence"><code>atomic_signal_fence</code></a> in C and C++.</p> <h2 id="panics">Panics</h2> <p>Panics if <code>order</code> is <a href="enum.ordering#variant.Relaxed" title="variant std::sync::atomic::Ordering::Relaxed"><code>Relaxed</code></a>.</p> <h2 id="examples">Examples</h2> <p>Without the two <code>compiler_fence</code> calls, the read of <code>IMPORTANT_VARIABLE</code> in <code>signal_handler</code> is <em>undefined behavior</em> due to a data race, despite everything happening in a single thread. This is because the signal handler is considered to run concurrently with its associated thread, and explicit synchronization is required to pass data between a thread and its signal handler. The code below uses two <code>compiler_fence</code> calls to establish the usual release-acquire synchronization pattern (see <a href="fn.fence" title="fn std::sync::atomic::fence"><code>fence</code></a> for an image).</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::sync::atomic::AtomicBool;
use std::sync::atomic::Ordering;
use std::sync::atomic::compiler_fence;

static mut IMPORTANT_VARIABLE: usize = 0;
static IS_READY: AtomicBool = AtomicBool::new(false);

fn main() {
    unsafe { IMPORTANT_VARIABLE = 42 };
    // Marks earlier writes as being released with future relaxed stores.
    compiler_fence(Ordering::Release);
    IS_READY.store(true, Ordering::Relaxed);
}

fn signal_handler() {
    if IS_READY.load(Ordering::Relaxed) {
        // Acquires writes that were released with relaxed stores that we read from.
        compiler_fence(Ordering::Acquire);
        assert_eq!(unsafe { IMPORTANT_VARIABLE }, 42);
    }
}</pre></div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/sync/atomic/fn.compiler_fence.html" class="_attribution-link">https://doc.rust-lang.org/std/sync/atomic/fn.compiler_fence.html</a>
  </p>
</div>
</div>
            </main>
        </div>
    </div>
    <script type="text/javascript" src="../../../assets/index.js"></script>
</body>

</html>