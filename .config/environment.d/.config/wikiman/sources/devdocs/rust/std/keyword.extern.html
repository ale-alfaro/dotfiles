<html class="_theme-default">
<head>
    <meta charset="utf-8">
    <title>std::extern</title>
    
    <link rel="preload" href="../assets/index.js" as="script" type="text/javascript" />

    <link rel="stylesheet" type="text/css" href="../application.css" />
    <link rel="stylesheet" type="text/css" href="../assets/index.css" />
</head>
<body>
    <div class="_app">
        <devdocs-navbar current="std/keyword.extern" prefix="../" listing-src="../navbar.json"></devdocs-navbar>
        <div class="_container">
            <main class="_content">
                <div class="_page _rust"><h1 class="main-heading">Keyword extern</h1>
<p>Link to or import external code.</p> <p>The <code>extern</code> keyword is used in two places in Rust. One is in conjunction with the <a href="keyword.crate"><code>crate</code></a> keyword to make your Rust code aware of other Rust crates in your project, i.e., <code>extern crate lazy_static;</code>. The other use is in foreign function interfaces (FFI).</p> <p><code>extern</code> is used in two different contexts within FFI. The first is in the form of external blocks, for declaring function interfaces that Rust code can call foreign code by. This use of <code>extern</code> is unsafe, since we are asserting to the compiler that all function declarations are correct. If they are not, using these items may lead to undefined behavior.</p> <div class="example-wrap ignore">ⓘ<pre class="rust rust-example-rendered" data-language="rust">// SAFETY: The function declarations given below are in
// line with the header files of `my_c_library`.
#[link(name = "my_c_library")]
unsafe extern "C" {
    fn my_c_function(x: i32) -&gt; bool;
}</pre>
</div> <p>This code would attempt to link with <code>libmy_c_library.so</code> on unix-like systems and <code>my_c_library.dll</code> on Windows at runtime, and panic if it can’t find something to link to. Rust code could then use <code>my_c_function</code> as if it were any other unsafe Rust function. Working with non-Rust languages and FFI is inherently unsafe, so wrappers are usually built around C APIs.</p> <p>The mirror use case of FFI is also done via the <code>extern</code> keyword:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">#[unsafe(no_mangle)]
pub extern "C" fn callable_from_c(x: i32) -&gt; bool {
    x % 3 == 0
}</pre></div> <p>If compiled as a dylib, the resulting .so could then be linked to from a C library, and the function could be used as if it was from any other library.</p> <p>For more information on FFI, check the <a href="../book/ch19-01-unsafe-rust#using-extern-functions-to-call-external-code">Rust book</a> or the <a href="../reference/items/external-blocks">Reference</a>.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/keyword.extern.html" class="_attribution-link">https://doc.rust-lang.org/std/keyword.extern.html</a>
  </p>
</div>
</div>
            </main>
        </div>
    </div>
    <script type="text/javascript" src="../assets/index.js"></script>
</body>

</html>