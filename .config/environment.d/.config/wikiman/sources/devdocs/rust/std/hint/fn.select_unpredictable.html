<html class="_theme-default">
<head>
    <meta charset="utf-8">
    <title>std::select_unpredictable</title>
    
    <link rel="preload" href="../../assets/index.js" as="script" type="text/javascript" />

    <link rel="stylesheet" type="text/css" href="../../application.css" />
    <link rel="stylesheet" type="text/css" href="../../assets/index.css" />
</head>
<body>
    <div class="_app">
        <devdocs-navbar current="std/hint/fn.select_unpredictable" prefix="../../" listing-src="../../navbar.json"></devdocs-navbar>
        <div class="_container">
            <main class="_content">
                <div class="_page _rust"><h1 class="main-heading">Function select_unpredictable</h1>
<pre class="rust item-decl" data-language="rust">pub fn select_unpredictable&lt;T&gt;(condition: bool, true_val: T, false_val: T) -&gt; T</pre>
<p>Returns either <code>true_val</code> or <code>false_val</code> depending on the value of <code>condition</code>, with a hint to the compiler that <code>condition</code> is unlikely to be correctly predicted by a CPU’s branch predictor.</p> <p>This method is functionally equivalent to</p> <div class="example-wrap ignore">ⓘ<pre class="rust rust-example-rendered" data-language="rust">fn select_unpredictable&lt;T&gt;(b: bool, true_val: T, false_val: T) -&gt; T {
    if b { true_val } else { false_val }
}</pre>
</div> <p>but might generate different assembly. In particular, on platforms with a conditional move or select instruction (like <code>cmov</code> on x86 or <code>csel</code> on ARM) the optimizer might use these instructions to avoid branches, which can benefit performance if the branch predictor is struggling with predicting <code>condition</code>, such as in an implementation of binary search.</p> <p>Note however that this lowering is not guaranteed (on any platform) and should not be relied upon when trying to write cryptographic constant-time code. Also be aware that this lowering might <em>decrease</em> performance if <code>condition</code> is well-predictable. It is advisable to perform benchmarks to tell if this function is useful.</p> <h2 id="examples">Examples</h2> <p>Distribute values evenly between two buckets:</p> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::hash::BuildHasher;
use std::hint;

fn append&lt;H: BuildHasher&gt;(hasher: &amp;H, v: i32, bucket_one: &amp;mut Vec&lt;i32&gt;, bucket_two: &amp;mut Vec&lt;i32&gt;) {
    let hash = hasher.hash_one(&amp;v);
    let bucket = hint::select_unpredictable(hash % 2 == 0, bucket_one, bucket_two);
    bucket.push(v);
}</pre></div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/hint/fn.select_unpredictable.html" class="_attribution-link">https://doc.rust-lang.org/std/hint/fn.select_unpredictable.html</a>
  </p>
</div>
</div>
            </main>
        </div>
    </div>
    <script type="text/javascript" src="../../assets/index.js"></script>
</body>

</html>