<html class="_theme-default">
<head>
    <meta charset="utf-8">
    <title>std::set_var</title>
    
    <link rel="preload" href="../../assets/index.js" as="script" type="text/javascript" />

    <link rel="stylesheet" type="text/css" href="../../application.css" />
    <link rel="stylesheet" type="text/css" href="../../assets/index.css" />
</head>
<body>
    <div class="_app">
        <devdocs-navbar current="std/env/fn.set_var" prefix="../../" listing-src="../../navbar.json"></devdocs-navbar>
        <div class="_container">
            <main class="_content">
                <div class="_page _rust"><h1 class="main-heading">Function set_var</h1>
<pre class="rust item-decl" data-language="rust">pub unsafe fn set_var&lt;K: AsRef&lt;OsStr&gt;, V: AsRef&lt;OsStr&gt;&gt;(key: K, value: V)</pre>
<p>Sets the environment variable <code>key</code> to the value <code>value</code> for the currently running process.</p> <h2 id="safety">Safety</h2> <p>This function is safe to call in a single-threaded program.</p> <p>This function is also always safe to call on Windows, in single-threaded and multi-threaded programs.</p> <p>In multi-threaded programs on other operating systems, the only safe option is to not use <code>set_var</code> or <code>remove_var</code> at all.</p> <p>The exact requirement is: you must ensure that there are no other threads concurrently writing or <em>reading</em>(!) the environment through functions or global variables other than the ones in this module. The problem is that these operating systems do not provide a thread-safe way to read the environment, and most C libraries, including libc itself, do not advertise which functions read from the environment. Even functions from the Rust standard library may read the environment without going through this module, e.g. for DNS lookups from <a href="../net/trait.tosocketaddrs" title="trait std::net::ToSocketAddrs"><code>std::net::ToSocketAddrs</code></a>. No stable guarantee is made about which functions may read from the environment in future versions of a library. All this makes it not practically possible for you to guarantee that no other thread will read the environment, so the only safe option is to not use <code>set_var</code> or <code>remove_var</code> in multi-threaded programs at all.</p> <p>Discussion of this unsafety on Unix may be found in:</p> <ul> <li><a href="https://austingroupbugs.net/view.php?id=188">Austin Group Bugzilla (for POSIX)</a></li> <li><a href="https://sourceware.org/bugzilla/show_bug.cgi?id=15607#c2">GNU C library Bugzilla</a></li> </ul> <p>To pass an environment variable to a child process, you can instead use <a href="../process/struct.command#method.env" title="method std::process::Command::env"><code>Command::env</code></a>.</p> <h2 id="panics">Panics</h2> <p>This function may panic if <code>key</code> is empty, contains an ASCII equals sign <code>'='</code> or the NUL character <code>'\0'</code>, or when <code>value</code> contains the NUL character.</p> <h2 id="examples">Examples</h2> <div class="example-wrap"><pre class="rust rust-example-rendered" data-language="rust">use std::env;

let key = "KEY";
unsafe {
    env::set_var(key, "VALUE");
}
assert_eq!(env::var(key), Ok("VALUE".to_string()));</pre></div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/std/env/fn.set_var.html" class="_attribution-link">https://doc.rust-lang.org/std/env/fn.set_var.html</a>
  </p>
</div>
</div>
            </main>
        </div>
    </div>
    <script type="text/javascript" src="../../assets/index.js"></script>
</body>

</html>