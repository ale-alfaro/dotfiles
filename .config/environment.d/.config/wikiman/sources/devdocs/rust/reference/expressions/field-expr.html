<html class="_theme-default">
<head>
    <meta charset="utf-8">
    <title>.. Automatic dereferencing</title>
    
    <link rel="preload" href="../../assets/index.js" as="script" type="text/javascript" />

    <link rel="stylesheet" type="text/css" href="../../application.css" />
    <link rel="stylesheet" type="text/css" href="../../assets/index.css" />
</head>
<body>
    <div class="_app">
        <devdocs-navbar current="reference/expressions/field-expr" prefix="../../" listing-src="../../navbar.json"></devdocs-navbar>
        <div class="_container">
            <main class="_content">
                <div class="_page _rust"><h1 class="rule" id="r-expr.field">
<a class="rule-link" href="#r-expr.field" title="expr.field"><span>[expr<wbr>.field]</wbr></span></a> </h1> <h1 id="field-access-expressions">Field access expressions</h1> <div class="rule" id="r-expr.field.syntax">
<a class="rule-link" href="#r-expr.field.syntax" title="expr.field.syntax"><span>[expr<wbr>.field<wbr>.syntax]</wbr></wbr></span></a> </div> <div class="grammar-container"> <p><strong><sup>Syntax</sup></strong> <br> <span class="grammar-text grammar-production" id="grammar-FieldExpression" onclick="show_railroad()"><a href="field-expr#railroad-FieldExpression">FieldExpression</a></span> â†’ <span class="grammar-text"><a href="../expressions#grammar-Expression">Expression</a></span> <span class="grammar-literal">.</span> <span class="grammar-text"><a href="../identifiers#grammar-IDENTIFIER">IDENTIFIER</a></span></p> <p><button class="grammar-toggle-railroad" type="button" title="Toggle railroad display" onclick="toggle_railroad()">Show Railroad</button></p> </div> <div class="grammar-railroad grammar-hidden"> <div style="width: 318px; height: auto; max-width: 100%; max-height: 100%" class="railroad-production" id="railroad-FieldExpression">
<svg class="railroad" viewbox="0 0 318 74" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">  <g class="verticalgrid"> <a class="link" xlink:href="field-expr.html#grammar-FieldExpression"> <text class="comment" x="67" y="25"> FieldExpression</text> </a> <g class="sequence">  <g class="sequence"> <a class="link" xlink:href="../expressions.html#railroad-Expression"> <g class="nonterminal">  <text x="85" y="58"> Expression</text> </g> </a> <g class="terminal">  <text x="159" y="58"> .</text> </g> <a class="link" xlink:href="../identifiers.html#railroad-IDENTIFIER"> <g class="nonterminal">  <text x="233" y="58"> IDENTIFIER</text> </g> </a>   </g>    </g> </g> </svg> </div> </div> <div class="rule" id="r-expr.field.intro">
<a class="rule-link" href="#r-expr.field.intro" title="expr.field.intro"><span>[expr<wbr>.field<wbr>.intro]</wbr></wbr></span></a> </div> <p>A <em>field expression</em> is a <a href="../expressions#place-expressions-and-value-expressions">place expression</a> that evaluates to the location of a field of a <a href="../items/structs">struct</a> or <a href="../items/unions">union</a>.</p> <div class="rule" id="r-expr.field.mut">
<a class="rule-link" href="#r-expr.field.mut" title="expr.field.mut"><span>[expr<wbr>.field<wbr>.mut]</wbr></wbr></span></a> </div> <p>When the operand is <a href="../expressions#mutability">mutable</a>, the field expression is also mutable.</p> <div class="rule" id="r-expr.field.form">
<a class="rule-link" href="#r-expr.field.form" title="expr.field.form"><span>[expr<wbr>.field<wbr>.form]</wbr></wbr></span></a> </div> <p>The syntax for a field expression is an expression, called the <em>container operand</em>, then a <code>.</code>, and finally an <a href="../identifiers">identifier</a>.</p> <div class="rule" id="r-expr.field.not-method-call">
<a class="rule-link" href="#r-expr.field.not-method-call" title="expr.field.not-method-call"><span>[expr<wbr>.field<wbr>.not-method-call]</wbr></wbr></span></a> </div> <p>Field expressions cannot be followed by a parenthetical comma-separated list of expressions, as that is instead parsed as a <a href="method-call-expr">method call expression</a>. That is, they cannot be the function operand of a <a href="call-expr">call expression</a>.</p> <div class="alert alert-note"> <blockquote> <p class="alert-title">Note</p> <p>Wrap the field expression in a <a href="grouped-expr">parenthesized expression</a> to use it in a call expression.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
struct HoldsCallable&lt;F: Fn()&gt; { callable: F }
let holds_callable = HoldsCallable { callable: || () };

// Invalid: Parsed as calling the method "callable"
// holds_callable.callable();

// Valid
(holds_callable.callable)();
}</pre> </blockquote> </div> <p>Examples:</p>  <pre data-language="rust">mystruct.myfield;
foo().x;
(Struct {a: 10, b: 20}).a;
(mystruct.function_field)() // Call expression containing a field expression</pre> <div class="rule" id="r-expr.field.autoref-deref">
<a class="rule-link" href="#r-expr.field.autoref-deref" title="expr.field.autoref-deref"><span>[expr<wbr>.field<wbr>.autoref-deref]</wbr></wbr></span></a> </div> <h2 id="automatic-dereferencing">Automatic dereferencing</h2> <p>If the type of the container operand implements <a href="../special-types-and-traits#deref-and-derefmut"><code>Deref</code></a> or <a href="../special-types-and-traits#deref-and-derefmut"><code>DerefMut</code></a> depending on whether the operand is <a href="../expressions#mutability">mutable</a>, it is <em>automatically dereferenced</em> as many times as necessary to make the field access possible. This process is also called <em>autoderef</em> for short.</p> <div class="rule" id="r-expr.field.borrow">
<a class="rule-link" href="#r-expr.field.borrow" title="expr.field.borrow"><span>[expr<wbr>.field<wbr>.borrow]</wbr></wbr></span></a> </div> <h2 id="borrowing">Borrowing</h2> <p>The fields of a struct or a reference to a struct are treated as separate entities when borrowing. If the struct does not implement <a href="../special-types-and-traits#drop"><code>Drop</code></a> and is stored in a local variable, this also applies to moving out of each of its fields. This also does not apply if automatic dereferencing is done though user-defined types other than <a href="../special-types-and-traits#boxt"><code>Box</code></a>.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
struct A { f1: String, f2: String, f3: String }
let mut x: A;
x = A {
    f1: "f1".to_string(),
    f2: "f2".to_string(),
    f3: "f3".to_string()
};
let a: &amp;mut String = &amp;mut x.f1; // x.f1 borrowed mutably
let b: &amp;String = &amp;x.f2;         // x.f2 borrowed immutably
let c: &amp;String = &amp;x.f2;         // Can borrow again
let d: String = x.f3;           // Move out of x.f3
}</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/reference/expressions/field-expr.html" class="_attribution-link">https://doc.rust-lang.org/reference/expressions/field-expr.html</a>
  </p>
</div>
</div>
            </main>
        </div>
    </div>
    <script type="text/javascript" src="../../assets/index.js"></script>
</body>

</html>