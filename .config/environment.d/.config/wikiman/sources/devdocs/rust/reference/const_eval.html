<html class="_theme-default">
<head>
    <meta charset="utf-8">
    <title>.. Constant expressions</title>
    
    <link rel="preload" href="../assets/index.js" as="script" type="text/javascript" />

    <link rel="stylesheet" type="text/css" href="../application.css" />
    <link rel="stylesheet" type="text/css" href="../assets/index.css" />
</head>
<body>
    <div class="_app">
        <devdocs-navbar current="reference/const_eval" prefix="../" listing-src="../navbar.json"></devdocs-navbar>
        <div class="_container">
            <main class="_content">
                <div class="_page _rust"><h1 class="rule" id="r-const-eval">
<a class="rule-link" href="#r-const-eval" title="const-eval"><span>[const-eval]</span></a> </h1> <h1 id="constant-evaluation">Constant evaluation</h1> <div class="rule" id="r-const-eval.general">
<a class="rule-link" href="#r-const-eval.general" title="const-eval.general"><span>[const-eval<wbr>.general]</wbr></span></a> </div> <p>Constant evaluation is the process of computing the result of <a href="expressions">expressions</a> during compilation. Only a subset of all expressions can be evaluated at compile-time.</p> <div class="rule" id="r-const-eval.const-expr">
<a class="rule-link" href="#r-const-eval.const-expr" title="const-eval.const-expr"><span>[const-eval<wbr>.const-expr]</wbr></span></a> </div> <h2 id="constant-expressions">Constant expressions</h2> <div class="rule" id="r-const-eval.const-expr.general">
<a class="rule-link" href="#r-const-eval.const-expr.general" title="const-eval.const-expr.general"><span>[const-eval<wbr>.const-expr<wbr>.general]</wbr></wbr></span></a> </div> <p>Certain forms of expressions, called constant expressions, can be evaluated at compile time.</p> <div class="rule" id="r-const-eval.const-expr.const-context">
<a class="rule-link" href="#r-const-eval.const-expr.const-context" title="const-eval.const-expr.const-context"><span>[const-eval<wbr>.const-expr<wbr>.const-context]</wbr></wbr></span></a> </div> <p>In <a href="#const-context">const contexts</a>, these are the only allowed expressions, and are always evaluated at compile time.</p> <div class="rule" id="r-const-eval.const-expr.runtime-context">
<a class="rule-link" href="#r-const-eval.const-expr.runtime-context" title="const-eval.const-expr.runtime-context"><span>[const-eval<wbr>.const-expr<wbr>.runtime-context]</wbr></wbr></span></a> </div> <p>In other places, such as <a href="statements#let-statements">let statements</a>, constant expressions <em>may</em> be, but are not guaranteed to be, evaluated at compile time.</p> <div class="rule" id="r-const-eval.const-expr.error">
<a class="rule-link" href="#r-const-eval.const-expr.error" title="const-eval.const-expr.error"><span>[const-eval<wbr>.const-expr<wbr>.error]</wbr></wbr></span></a> </div> <p>Behaviors such as out of bounds <a href="expressions/array-expr#array-and-slice-indexing-expressions">array indexing</a> or <a href="expressions/operator-expr#overflow">overflow</a> are compiler errors if the value must be evaluated at compile time (i.e. in const contexts). Otherwise, these behaviors are warnings, but will likely panic at run-time.</p> <div class="rule" id="r-const-eval.const-expr.list">
<a class="rule-link" href="#r-const-eval.const-expr.list" title="const-eval.const-expr.list"><span>[const-eval<wbr>.const-expr<wbr>.list]</wbr></wbr></span></a> </div> <p>The following expressions are constant expressions, so long as any operands are also constant expressions and do not cause any <a href="destructors"><code>Drop::drop</code></a> calls to be run.</p> <div class="rule" id="r-const-eval.const-expr.literal">
<a class="rule-link" href="#r-const-eval.const-expr.literal" title="const-eval.const-expr.literal"><span>[const-eval<wbr>.const-expr<wbr>.literal]</wbr></wbr></span></a> </div> <ul> <li>
<a href="expressions/literal-expr">Literals</a>.</li> </ul> <div class="rule" id="r-const-eval.const-expr.parameter">
<a class="rule-link" href="#r-const-eval.const-expr.parameter" title="const-eval.const-expr.parameter"><span>[const-eval<wbr>.const-expr<wbr>.parameter]</wbr></wbr></span></a> </div> <ul> <li>
<a href="items/generics">Const parameters</a>.</li> </ul> <div class="rule" id="r-const-eval.const-expr.path-item">
<a class="rule-link" href="#r-const-eval.const-expr.path-item" title="const-eval.const-expr.path-item"><span>[const-eval<wbr>.const-expr<wbr>.path-item]</wbr></wbr></span></a> </div> <ul> <li>
<a href="expressions/path-expr">Paths</a> to <a href="items/functions">functions</a> and <a href="items/constant-items">constants</a>. Recursively defining constants is not allowed.</li> </ul> <div class="rule" id="r-const-eval.const-expr.path-static">
<a class="rule-link" href="#r-const-eval.const-expr.path-static" title="const-eval.const-expr.path-static"><span>[const-eval<wbr>.const-expr<wbr>.path-static]</wbr></wbr></span></a> </div> <ul> <li>Paths to <a href="items/static-items">statics</a> with these restrictions: <ul> <li>Writes to <code>static</code> items are not allowed in any constant evaluation context.</li> <li>Reads from <code>extern</code> statics are not allowed in any constant evaluation context.</li> <li>If the evaluation is <em>not</em> carried out in an initializer of a <code>static</code> item, then reads from any mutable <code>static</code> are not allowed. A mutable <code>static</code> is a <code>static mut</code> item, or a <code>static</code> item with an interior-mutable type.</li> </ul> </li> </ul> <p>These requirements are checked only when the constant is evaluated. In other words, having such accesses syntactically occur in const contexts is allowed as long as they never get executed.</p> <div class="rule" id="r-const-eval.const-expr.tuple">
<a class="rule-link" href="#r-const-eval.const-expr.tuple" title="const-eval.const-expr.tuple"><span>[const-eval<wbr>.const-expr<wbr>.tuple]</wbr></wbr></span></a> </div> <ul> <li>
<a href="expressions/tuple-expr">Tuple expressions</a>.</li> </ul> <div class="rule" id="r-const-eval.const-expr.array">
<a class="rule-link" href="#r-const-eval.const-expr.array" title="const-eval.const-expr.array"><span>[const-eval<wbr>.const-expr<wbr>.array]</wbr></wbr></span></a> </div> <ul> <li>
<a href="expressions/array-expr">Array expressions</a>.</li> </ul> <div class="rule" id="r-const-eval.const-expr.constructor">
<a class="rule-link" href="#r-const-eval.const-expr.constructor" title="const-eval.const-expr.constructor"><span>[const-eval<wbr>.const-expr<wbr>.constructor]</wbr></wbr></span></a> </div> <ul> <li>
<a href="expressions/struct-expr">Struct</a> expressions.</li> </ul> <div class="rule" id="r-const-eval.const-expr.block">
<a class="rule-link" href="#r-const-eval.const-expr.block" title="const-eval.const-expr.block"><span>[const-eval<wbr>.const-expr<wbr>.block]</wbr></wbr></span></a> </div> <ul> <li>
<a href="expressions/block-expr">Block expressions</a>, including <code>unsafe</code> and <code>const</code> blocks. <ul> <li>
<a href="statements#let-statements">let statements</a> and thus irrefutable <a href="patterns">patterns</a>, including mutable bindings</li> <li><a href="expressions/operator-expr#assignment-expressions">assignment expressions</a></li> <li><a href="expressions/operator-expr#compound-assignment-expressions">compound assignment expressions</a></li> <li><a href="statements#expression-statements">expression statements</a></li> </ul> </li> </ul> <div class="rule" id="r-const-eval.const-expr.field">
<a class="rule-link" href="#r-const-eval.const-expr.field" title="const-eval.const-expr.field"><span>[const-eval<wbr>.const-expr<wbr>.field]</wbr></wbr></span></a> </div> <ul> <li>
<a href="expressions/field-expr">Field</a> expressions.</li> </ul> <div class="rule" id="r-const-eval.const-expr.index">
<a class="rule-link" href="#r-const-eval.const-expr.index" title="const-eval.const-expr.index"><span>[const-eval<wbr>.const-expr<wbr>.index]</wbr></wbr></span></a> </div> <ul> <li>Index expressions, <a href="expressions/array-expr#array-and-slice-indexing-expressions">array indexing</a> or <a href="types/slice">slice</a> with a <code>usize</code>.</li> </ul> <div class="rule" id="r-const-eval.const-expr.range">
<a class="rule-link" href="#r-const-eval.const-expr.range" title="const-eval.const-expr.range"><span>[const-eval<wbr>.const-expr<wbr>.range]</wbr></wbr></span></a> </div> <ul> <li>
<a href="expressions/range-expr">Range expressions</a>.</li> </ul> <div class="rule" id="r-const-eval.const-expr.closure">
<a class="rule-link" href="#r-const-eval.const-expr.closure" title="const-eval.const-expr.closure"><span>[const-eval<wbr>.const-expr<wbr>.closure]</wbr></wbr></span></a> </div> <ul> <li>
<a href="expressions/closure-expr">Closure expressions</a> which donâ€™t capture variables from the environment.</li> </ul> <div class="rule" id="r-const-eval.const-expr.builtin-arith-logic">
<a class="rule-link" href="#r-const-eval.const-expr.builtin-arith-logic" title="const-eval.const-expr.builtin-arith-logic"><span>[const-eval<wbr>.const-expr<wbr>.builtin-arith-logic]</wbr></wbr></span></a> </div> <ul> <li>Built-in <a href="expressions/operator-expr#negation-operators">negation</a>, <a href="expressions/operator-expr#arithmetic-and-logical-binary-operators">arithmetic</a>, <a href="expressions/operator-expr#arithmetic-and-logical-binary-operators">logical</a>, <a href="expressions/operator-expr#comparison-operators">comparison</a> or <a href="expressions/operator-expr#lazy-boolean-operators">lazy boolean</a> operators used on integer and floating point types, <code>bool</code>, and <code>char</code>.</li> </ul> <div class="rule" id="r-const-eval.const-expr.borrows">
<a class="rule-link" href="#r-const-eval.const-expr.borrows" title="const-eval.const-expr.borrows"><span>[const-eval<wbr>.const-expr<wbr>.borrows]</wbr></wbr></span></a> </div> <ul> <li>All forms of <a href="expressions/operator-expr#borrow-operators">borrow</a>s, including raw borrows, with one limitation: mutable borrows and shared borrows to values with interior mutability are only allowed to refer to <em>transient</em> places. A place is <em>transient</em> if its lifetime is strictly contained inside the current <a href="#const-context">const context</a>.</li> </ul> <div class="rule" id="r-const-eval.const-expr.deref">
<a class="rule-link" href="#r-const-eval.const-expr.deref" title="const-eval.const-expr.deref"><span>[const-eval<wbr>.const-expr<wbr>.deref]</wbr></wbr></span></a> </div> <ul> <li>The <a href="expressions/operator-expr#the-dereference-operator">dereference operator</a> except for raw pointers.</li> </ul> <div class="rule" id="r-const-eval.const-expr.group">
<a class="rule-link" href="#r-const-eval.const-expr.group" title="const-eval.const-expr.group"><span>[const-eval<wbr>.const-expr<wbr>.group]</wbr></wbr></span></a> </div> <ul> <li>
<a href="expressions/grouped-expr">Grouped</a> expressions.</li> </ul> <div class="rule" id="r-const-eval.const-expr.cast">
<a class="rule-link" href="#r-const-eval.const-expr.cast" title="const-eval.const-expr.cast"><span>[const-eval<wbr>.const-expr<wbr>.cast]</wbr></wbr></span></a> </div> <ul> <li>
<a href="expressions/operator-expr#type-cast-expressions">Cast</a> expressions, except <ul> <li>pointer to address casts and</li> <li>function pointer to address casts.</li> </ul> </li> </ul> <div class="rule" id="r-const-eval.const-expr.const-fn">
<a class="rule-link" href="#r-const-eval.const-expr.const-fn" title="const-eval.const-expr.const-fn"><span>[const-eval<wbr>.const-expr<wbr>.const-fn]</wbr></wbr></span></a> </div> <ul> <li>Calls of <a href="items/functions#const-functions">const functions</a> and const methods.</li> </ul> <div class="rule" id="r-const-eval.const-expr.loop">
<a class="rule-link" href="#r-const-eval.const-expr.loop" title="const-eval.const-expr.loop"><span>[const-eval<wbr>.const-expr<wbr>.loop]</wbr></wbr></span></a> </div> <ul> <li>
<a href="expressions/loop-expr#infinite-loops">loop</a> and <a href="expressions/loop-expr#predicate-loops">while</a> expressions.</li> </ul> <div class="rule" id="r-const-eval.const-expr.if-match">
<a class="rule-link" href="#r-const-eval.const-expr.if-match" title="const-eval.const-expr.if-match"><span>[const-eval<wbr>.const-expr<wbr>.if-match]</wbr></wbr></span></a> </div> <ul> <li>
<a href="expressions/if-expr#if-expressions">if</a> and <a href="expressions/match-expr">match</a> expressions.</li> </ul> <div class="rule" id="r-const-eval.const-context">
<a class="rule-link" href="#r-const-eval.const-context" title="const-eval.const-context"><span>[const-eval<wbr>.const-context]</wbr></span></a> </div> <h2 id="const-context">Const context</h2> <div class="rule" id="r-const-eval.const-context.general">
<a class="rule-link" href="#r-const-eval.const-context.general" title="const-eval.const-context.general"><span>[const-eval<wbr>.const-context<wbr>.general]</wbr></wbr></span></a> </div> <p>A <em>const context</em> is one of the following:</p> <div class="rule" id="r-const-eval.const-context.array-length">
<a class="rule-link" href="#r-const-eval.const-context.array-length" title="const-eval.const-context.array-length"><span>[const-eval<wbr>.const-context<wbr>.array-length]</wbr></wbr></span></a> </div> <ul> <li><a href="types/array">Array type length expressions</a></li> </ul> <div class="rule" id="r-const-eval.const-context.repeat-length">
<a class="rule-link" href="#r-const-eval.const-context.repeat-length" title="const-eval.const-context.repeat-length"><span>[const-eval<wbr>.const-context<wbr>.repeat-length]</wbr></wbr></span></a> </div> <ul> <li><a href="expressions/array-expr">Array repeat length expressions</a></li> </ul> <div class="rule" id="r-const-eval.const-context.init">
<a class="rule-link" href="#r-const-eval.const-context.init" title="const-eval.const-context.init"><span>[const-eval<wbr>.const-context<wbr>.init]</wbr></wbr></span></a> </div> <ul> <li>The initializer of <ul> <li><a href="items/constant-items">constants</a></li> <li><a href="items/static-items">statics</a></li> <li><a href="items/enumerations#discriminants">enum discriminants</a></li> </ul> </li> </ul> <div class="rule" id="r-const-eval.const-context.generic">
<a class="rule-link" href="#r-const-eval.const-context.generic" title="const-eval.const-context.generic"><span>[const-eval<wbr>.const-context<wbr>.generic]</wbr></wbr></span></a> </div> <ul> <li>A <a href="items/generics#const-generics">const generic argument</a>
</li> </ul> <div class="rule" id="r-const-eval.const-context.block">
<a class="rule-link" href="#r-const-eval.const-context.block" title="const-eval.const-context.block"><span>[const-eval<wbr>.const-context<wbr>.block]</wbr></wbr></span></a> </div> <ul> <li>A <a href="expressions/block-expr#const-blocks">const block</a>
</li> </ul> <p>Const contexts that are used as parts of types (array type and repeat length expressions as well as const generic arguments) can only make restricted use of surrounding generic parameters: such an expression must either be a single bare const generic parameter, or an arbitrary expression not making use of any generics.</p> <div class="rule" id="r-const-eval.const-fn">
<a class="rule-link" href="#r-const-eval.const-fn" title="const-eval.const-fn"><span>[const-eval<wbr>.const-fn]</wbr></span></a> </div> <h2 id="const-functions">Const Functions</h2> <div class="rule" id="r-const-eval.const-fn.general">
<a class="rule-link" href="#r-const-eval.const-fn.general" title="const-eval.const-fn.general"><span>[const-eval<wbr>.const-fn<wbr>.general]</wbr></wbr></span></a> </div> <p>A <em>const fn</em> is a function that one is permitted to call from a const context.</p> <div class="rule" id="r-const-eval.const-fn.usage">
<a class="rule-link" href="#r-const-eval.const-fn.usage" title="const-eval.const-fn.usage"><span>[const-eval<wbr>.const-fn<wbr>.usage]</wbr></wbr></span></a> </div> <p>Declaring a function <code>const</code> has no effect on any existing uses, it only restricts the types that arguments and the return type may use, and restricts the function body to constant expressions.</p> <div class="rule" id="r-const-eval.const-fn.const-context">
<a class="rule-link" href="#r-const-eval.const-fn.const-context" title="const-eval.const-fn.const-context"><span>[const-eval<wbr>.const-fn<wbr>.const-context]</wbr></wbr></span></a> </div> <p>When called from a const context, the function is interpreted by the compiler at compile time. The interpretation happens in the environment of the compilation target and not the host. So <code>usize</code> is <code>32</code> bits if you are compiling against a <code>32</code> bit system, irrelevant of whether you are building on a <code>64</code> bit or a <code>32</code> bit system.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/reference/const_eval.html" class="_attribution-link">https://doc.rust-lang.org/reference/const_eval.html</a>
  </p>
</div>
</div>
            </main>
        </div>
    </div>
    <script type="text/javascript" src="../assets/index.js"></script>
</body>

</html>