<html class="_theme-default">
<head>
    <meta charset="utf-8">
    <title>.. Example</title>
    
    <link rel="preload" href="../assets/index.js" as="script" type="text/javascript" />

    <link rel="stylesheet" type="text/css" href="../application.css" />
    <link rel="stylesheet" type="text/css" href="../assets/index.css" />
</head>
<body>
    <div class="_app">
        <devdocs-navbar current="reference/inline-assembly" prefix="../" listing-src="../navbar.json"></devdocs-navbar>
        <div class="_container">
            <main class="_content">
                <div class="_page _rust"><h1 class="rule" id="r-asm">
<a class="rule-link" href="#r-asm" title="asm"><span>[asm]</span></a> </h1> <h1 id="inline-assembly">Inline assembly</h1> <div class="rule" id="r-asm.intro">
<a class="rule-link" href="#r-asm.intro" title="asm.intro"><span>[asm<wbr>.intro]</wbr></span></a> </div> <p>Support for inline assembly is provided via the <a href="https://doc.rust-lang.org/core/arch/macro.asm.html"><code>asm!</code></a>, <a href="https://doc.rust-lang.org/core/arch/macro.naked_asm.html"><code>naked_asm!</code></a>, and <a href="https://doc.rust-lang.org/core/arch/macro.global_asm.html"><code>global_asm!</code></a> macros. It can be used to embed handwritten assembly in the assembly output generated by the compiler.</p> <div class="rule" id="r-asm.stable-targets">
<a class="rule-link" href="#r-asm.stable-targets" title="asm.stable-targets"><span>[asm<wbr>.stable-targets]</wbr></span></a> </div> <p>Support for inline assembly is stable on the following architectures:</p> <ul> <li>x86 and x86-64</li> <li>ARM</li> <li>AArch64 and Arm64EC</li> <li>RISC-V</li> <li>LoongArch</li> <li>s390x</li> </ul> <p>The compiler will emit an error if <code>asm!</code> is used on an unsupported target.</p> <div class="rule" id="r-asm.example">
<a class="rule-link" href="#r-asm.example" title="asm.example"><span>[asm<wbr>.example]</wbr></span></a> </div> <h2 id="example">Example</h2> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
use std::arch::asm;

// Multiply x by 6 using shifts and adds
let mut x: u64 = 4;
unsafe {
    asm!(
        "mov {tmp}, {x}",
        "shl {tmp}, 1",
        "shl {x}, 2",
        "add {x}, {tmp}",
        x = inout(reg) x,
        tmp = out(reg) _,
    );
}
assert_eq!(x, 4 * 6);
}
}</pre> <div class="rule" id="r-asm.syntax">
<a class="rule-link" href="#r-asm.syntax" title="asm.syntax"><span>[asm<wbr>.syntax]</wbr></span></a> </div> <h2 id="syntax">Syntax</h2> <p>The following ABNF specifies the general syntax:</p> <pre>format_string := STRING_LITERAL / RAW_STRING_LITERAL
dir_spec := "in" / "out" / "lateout" / "inout" / "inlateout"
reg_spec := &lt;register class&gt; / "\"" &lt;explicit register&gt; "\""
operand_expr := expr / "_" / expr "=&gt;" expr / expr "=&gt;" "_"
reg_operand := [ident "="] dir_spec "(" reg_spec ")" operand_expr / sym &lt;path&gt; / const &lt;expr&gt; / label &lt;block&gt;
clobber_abi := "clobber_abi(" &lt;abi&gt; *("," &lt;abi&gt;) [","] ")"
option := "pure" / "nomem" / "readonly" / "preserves_flags" / "noreturn" / "nostack" / "att_syntax" / "raw"
options := "options(" option *("," option) [","] ")"
operand := reg_operand / clobber_abi / options
asm := "asm!(" format_string *("," format_string) *("," operand) [","] ")"
naked_asm := "naked_asm!(" format_string *("," format_string) *("," operand) [","] ")"
global_asm := "global_asm!(" format_string *("," format_string) *("," operand) [","] ")"
</pre> <div class="rule" id="r-asm.scope">
<a class="rule-link" href="#r-asm.scope" title="asm.scope"><span>[asm<wbr>.scope]</wbr></span></a> </div> <h2 id="scope">Scope</h2> <div class="rule" id="r-asm.scope.intro">
<a class="rule-link" href="#r-asm.scope.intro" title="asm.scope.intro"><span>[asm<wbr>.scope<wbr>.intro]</wbr></wbr></span></a> </div> <p>Inline assembly can be used in one of three ways.</p> <div class="rule" id="r-asm.scope.asm">
<a class="rule-link" href="#r-asm.scope.asm" title="asm.scope.asm"><span>[asm<wbr>.scope<wbr>.asm]</wbr></wbr></span></a> </div> <p>With the <code>asm!</code> macro, the assembly code is emitted in a function scope and integrated into the compiler-generated assembly code of a function. This assembly code must obey <a href="#rules-for-inline-assembly">strict rules</a> to avoid undefined behavior. Note that in some cases the compiler may choose to emit the assembly code as a separate function and generate a call to it.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
unsafe { core::arch::asm!("/* {} */", in(reg) 0); }
}
}</pre> <div class="rule" id="r-asm.scope.naked_asm">
<a class="rule-link" href="#r-asm.scope.naked_asm" title="asm.scope.naked_asm"><span>[asm<wbr>.scope<wbr>.naked_asm]</wbr></wbr></span></a> </div> <p>With the <code>naked_asm!</code> macro, the assembly code is emitted in a function scope and constitutes the full assembly code of a function. The <code>naked_asm!</code> macro is only allowed in <a href="attributes/codegen#the-naked-attribute">naked functions</a>.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
#[unsafe(naked)]
extern "C" fn wrapper() {
core::arch::naked_asm!("/* {} */", const 0);
}
}
}</pre> <div class="rule" id="r-asm.scope.global_asm">
<a class="rule-link" href="#r-asm.scope.global_asm" title="asm.scope.global_asm"><span>[asm<wbr>.scope<wbr>.global_asm]</wbr></wbr></span></a> </div> <p>With the <code>global_asm!</code> macro, the assembly code is emitted in a global scope, outside a function. This can be used to hand-write entire functions using assembly code, and generally provides much more freedom to use arbitrary registers and assembler directives.</p> <pre data-language="rust">fn main() {}
#[cfg(target_arch = "x86_64")]
core::arch::global_asm!("/* {} */", const 0);</pre> <div class="rule" id="r-asm.ts-args">
<a class="rule-link" href="#r-asm.ts-args" title="asm.ts-args"><span>[asm<wbr>.ts-args]</wbr></span></a> </div> <h2 id="template-string-arguments">Template string arguments</h2> <div class="rule" id="r-asm.ts-args.syntax">
<a class="rule-link" href="#r-asm.ts-args.syntax" title="asm.ts-args.syntax"><span>[asm<wbr>.ts-args<wbr>.syntax]</wbr></wbr></span></a> </div> <p>The assembler template uses the same syntax as <a href="https://doc.rust-lang.org/alloc/fmt/index.html#syntax">format strings</a> (i.e. placeholders are specified by curly braces).</p> <div class="rule" id="r-asm.ts-args.order">
<a class="rule-link" href="#r-asm.ts-args.order" title="asm.ts-args.order"><span>[asm<wbr>.ts-args<wbr>.order]</wbr></wbr></span></a> </div> <p>The corresponding arguments are accessed in order, by index, or by name.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
let x: i64;
let y: i64;
let z: i64;
// This
unsafe { core::arch::asm!("mov {}, {}", out(reg) x, in(reg) 5); }
// ... this
unsafe { core::arch::asm!("mov {0}, {1}", out(reg) y, in(reg) 5); }
// ... and this
unsafe { core::arch::asm!("mov {out}, {in}", out = out(reg) z, in = in(reg) 5); }
// all have the same behavior
assert_eq!(x, y);
assert_eq!(y, z);
}
}</pre> <div class="rule" id="r-asm.ts-args.no-implicit">
<a class="rule-link" href="#r-asm.ts-args.no-implicit" title="asm.ts-args.no-implicit"><span>[asm<wbr>.ts-args<wbr>.no-implicit]</wbr></wbr></span></a> </div> <p>However, implicit named arguments (introduced by <a href="https://github.com/rust-lang/rfcs/pull/2795">RFC #2795</a>) are not supported.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
let x = 5;
// We can't refer to `x` from the scope directly, we need an operand like `in(reg) x`
unsafe { core::arch::asm!("/* {x} */"); } // ERROR: no argument named x
}
#[cfg(not(target_arch = "x86_64"))] core::compile_error!("Test not supported on this arch");
}</pre> <div class="rule" id="r-asm.ts-args.one-or-more">
<a class="rule-link" href="#r-asm.ts-args.one-or-more" title="asm.ts-args.one-or-more"><span>[asm<wbr>.ts-args<wbr>.one-or-more]</wbr></wbr></span></a> </div> <p>An <code>asm!</code> invocation may have one or more template string arguments; an <code>asm!</code> with multiple template string arguments is treated as if all the strings were concatenated with a <code>\n</code> between them. The expected usage is for each template string argument to correspond to a line of assembly code.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
let x: i64;
let y: i64;
// We can separate multiple strings as if they were written together
unsafe { core::arch::asm!("mov eax, 5", "mov ecx, eax", out("rax") x, out("rcx") y); }
assert_eq!(x, y);
}
}</pre> <div class="rule" id="r-asm.ts-args.before-other-args">
<a class="rule-link" href="#r-asm.ts-args.before-other-args" title="asm.ts-args.before-other-args"><span>[asm<wbr>.ts-args<wbr>.before-other-args]</wbr></wbr></span></a> </div> <p>All template string arguments must appear before any other arguments.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
let x = 5;
#[cfg(target_arch = "x86_64")] {
// The template strings need to appear first in the asm invocation
unsafe { core::arch::asm!("/* {x} */", x = const 5, "ud2"); } // ERROR: unexpected token
}
#[cfg(not(target_arch = "x86_64"))] core::compile_error!("Test not supported on this arch");
}</pre> <div class="rule" id="r-asm.ts-args.positional-first">
<a class="rule-link" href="#r-asm.ts-args.positional-first" title="asm.ts-args.positional-first"><span>[asm<wbr>.ts-args<wbr>.positional-first]</wbr></wbr></span></a> </div> <p>As with format strings, positional arguments must appear before named arguments and explicit <a href="#register-operands">register operands</a>.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
// Named operands need to come after positional ones
unsafe { core::arch::asm!("/* {x} {} */", x = const 5, in(reg) 5); }
// ERROR: positional arguments cannot follow named arguments or explicit register arguments
}
#[cfg(not(target_arch = "x86_64"))] core::compile_error!("Test not supported on this arch");
}</pre> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
// We also can't put explicit registers before positional operands
unsafe { core::arch::asm!("/* {} */", in("eax") 0, in(reg) 5); }
// ERROR: positional arguments cannot follow named arguments or explicit register arguments
}
#[cfg(not(target_arch = "x86_64"))] core::compile_error!("Test not supported on this arch");
}</pre> <div class="rule" id="r-asm.ts-args.register-operands">
<a class="rule-link" href="#r-asm.ts-args.register-operands" title="asm.ts-args.register-operands"><span>[asm<wbr>.ts-args<wbr>.register-operands]</wbr></wbr></span></a> </div> <p>Explicit register operands cannot be used by placeholders in the template string.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
// Explicit register operands don't get substituted, use `eax` explicitly in the string
unsafe { core::arch::asm!("/* {} */", in("eax") 5); }
// ERROR: invalid reference to argument at index 0
}
#[cfg(not(target_arch = "x86_64"))] core::compile_error!("Test not supported on this arch");
}</pre> <div class="rule" id="r-asm.ts-args.at-least-once">
<a class="rule-link" href="#r-asm.ts-args.at-least-once" title="asm.ts-args.at-least-once"><span>[asm<wbr>.ts-args<wbr>.at-least-once]</wbr></wbr></span></a> </div> <p>All other named and positional operands must appear at least once in the template string, otherwise a compiler error is generated.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
// We have to name all of the operands in the format string
unsafe { core::arch::asm!("", in(reg) 5, x = const 5); }
// ERROR: multiple unused asm arguments
}
#[cfg(not(target_arch = "x86_64"))] core::compile_error!("Test not supported on this arch");
}</pre> <div class="rule" id="r-asm.ts-args.opaque">
<a class="rule-link" href="#r-asm.ts-args.opaque" title="asm.ts-args.opaque"><span>[asm<wbr>.ts-args<wbr>.opaque]</wbr></wbr></span></a> </div> <p>The exact assembly code syntax is target-specific and opaque to the compiler except for the way operands are substituted into the template string to form the code passed to the assembler.</p> <div class="rule" id="r-asm.ts-args.llvm-syntax">
<a class="rule-link" href="#r-asm.ts-args.llvm-syntax" title="asm.ts-args.llvm-syntax"><span>[asm<wbr>.ts-args<wbr>.llvm-syntax]</wbr></wbr></span></a> </div> <p>Currently, all supported targets follow the assembly code syntax used by LLVM’s internal assembler which usually corresponds to that of the GNU assembler (GAS). On x86, the <code>.intel_syntax noprefix</code> mode of GAS is used by default. On ARM, the <code>.syntax unified</code> mode is used. These targets impose an additional restriction on the assembly code: any assembler state (e.g. the current section which can be changed with <code>.section</code>) must be restored to its original value at the end of the asm string. Assembly code that does not conform to the GAS syntax will result in assembler-specific behavior. Further constraints on the directives used by inline assembly are indicated by <a href="#directives-support">Directives Support</a>.</p> <div class="rule" id="r-asm.operand-type">
<a class="rule-link" href="#r-asm.operand-type" title="asm.operand-type"><span>[asm<wbr>.operand-type]</wbr></span></a> </div> <h2 id="operand-type">Operand type</h2> <div class="rule" id="r-asm.operand-type.supported-operands">
<a class="rule-link" href="#r-asm.operand-type.supported-operands" title="asm.operand-type.supported-operands"><span>[asm<wbr>.operand-type<wbr>.supported-operands]</wbr></wbr></span></a> </div> <p>Several types of operands are supported:</p> <div class="rule" id="r-asm.operand-type.supported-operands.in">
<a class="rule-link" href="#r-asm.operand-type.supported-operands.in" title="asm.operand-type.supported-operands.in"><span>[asm<wbr>.operand-type<wbr>.supported-operands<wbr>.in]</wbr></wbr></wbr></span></a> </div> <ul> <li>
<code>in(&lt;reg&gt;) &lt;expr&gt;</code> <ul> <li>
<code>&lt;reg&gt;</code> can refer to a register class or an explicit register. The allocated register name is substituted into the asm template string.</li> <li>The allocated register will contain the value of <code>&lt;expr&gt;</code> at the start of the assembly code.</li> <li>The allocated register must contain the same value at the end of the assembly code (except if a <code>lateout</code> is allocated to the same register).</li> </ul> </li> </ul> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
// ``in` can be used to pass values into inline assembly...
unsafe { core::arch::asm!("/* {} */", in(reg) 5); }
}
}</pre> <div class="rule" id="r-asm.operand-type.supported-operands.out">
<a class="rule-link" href="#r-asm.operand-type.supported-operands.out" title="asm.operand-type.supported-operands.out"><span>[asm<wbr>.operand-type<wbr>.supported-operands<wbr>.out]</wbr></wbr></wbr></span></a> </div> <ul> <li>
<code>out(&lt;reg&gt;) &lt;expr&gt;</code> <ul> <li>
<code>&lt;reg&gt;</code> can refer to a register class or an explicit register. The allocated register name is substituted into the asm template string.</li> <li>The allocated register will contain an undefined value at the start of the assembly code.</li> <li>
<code>&lt;expr&gt;</code> must be a (possibly uninitialized) place expression, to which the contents of the allocated register are written at the end of the assembly code.</li> <li>An underscore (<code>_</code>) may be specified instead of an expression, which will cause the contents of the register to be discarded at the end of the assembly code (effectively acting as a clobber).</li> </ul> </li> </ul> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
let x: i64;
// and `out` can be used to pass values back to rust.
unsafe { core::arch::asm!("/* {} */", out(reg) x); }
}
}</pre> <div class="rule" id="r-asm.operand-type.supported-operands.lateout">
<a class="rule-link" href="#r-asm.operand-type.supported-operands.lateout" title="asm.operand-type.supported-operands.lateout"><span>[asm<wbr>.operand-type<wbr>.supported-operands<wbr>.lateout]</wbr></wbr></wbr></span></a> </div> <ul> <li>
<code>lateout(&lt;reg&gt;) &lt;expr&gt;</code> <ul> <li>Identical to <code>out</code> except that the register allocator can reuse a register allocated to an <code>in</code>.</li> <li>You should only write to the register after all inputs are read, otherwise you may clobber an input.</li> </ul> </li> </ul> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
let x: i64;
// `lateout` is the same as `out`
// but the compiler knows we don't care about the value of any inputs by the
// time we overwrite it.
unsafe { core::arch::asm!("mov {}, 5", lateout(reg) x); }
assert_eq!(x, 5)
}
}</pre> <div class="rule" id="r-asm.operand-type.supported-operands.inout">
<a class="rule-link" href="#r-asm.operand-type.supported-operands.inout" title="asm.operand-type.supported-operands.inout"><span>[asm<wbr>.operand-type<wbr>.supported-operands<wbr>.inout]</wbr></wbr></wbr></span></a> </div> <ul> <li>
<code>inout(&lt;reg&gt;) &lt;expr&gt;</code> <ul> <li>
<code>&lt;reg&gt;</code> can refer to a register class or an explicit register. The allocated register name is substituted into the asm template string.</li> <li>The allocated register will contain the value of <code>&lt;expr&gt;</code> at the start of the assembly code.</li> <li>
<code>&lt;expr&gt;</code> must be a mutable initialized place expression, to which the contents of the allocated register are written at the end of the assembly code.</li> </ul> </li> </ul> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
let mut x: i64 = 4;
// `inout` can be used to modify values in-register
unsafe { core::arch::asm!("inc {}", inout(reg) x); }
assert_eq!(x, 5);
}
}</pre> <div class="rule" id="r-asm.operand-type.supported-operands.inout-arrow">
<a class="rule-link" href="#r-asm.operand-type.supported-operands.inout-arrow" title="asm.operand-type.supported-operands.inout-arrow"><span>[asm<wbr>.operand-type<wbr>.supported-operands<wbr>.inout-arrow]</wbr></wbr></wbr></span></a> </div> <ul> <li>
<code>inout(&lt;reg&gt;) &lt;in expr&gt; =&gt; &lt;out expr&gt;</code> <ul> <li>Same as <code>inout</code> except that the initial value of the register is taken from the value of <code>&lt;in expr&gt;</code>.</li> <li>
<code>&lt;out expr&gt;</code> must be a (possibly uninitialized) place expression, to which the contents of the allocated register are written at the end of the assembly code.</li> <li>An underscore (<code>_</code>) may be specified instead of an expression for <code>&lt;out expr&gt;</code>, which will cause the contents of the register to be discarded at the end of the assembly code (effectively acting as a clobber).</li> <li>
<code>&lt;in expr&gt;</code> and <code>&lt;out expr&gt;</code> may have different types.</li> </ul> </li> </ul> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
let x: i64;
// `inout` can also move values to different places
unsafe { core::arch::asm!("inc {}", inout(reg) 4u64=&gt;x); }
assert_eq!(x, 5);
}
}</pre> <div class="rule" id="r-asm.operand-type.supported-operands.inlateout">
<a class="rule-link" href="#r-asm.operand-type.supported-operands.inlateout" title="asm.operand-type.supported-operands.inlateout"><span>[asm<wbr>.operand-type<wbr>.supported-operands<wbr>.inlateout]</wbr></wbr></wbr></span></a> </div> <ul> <li>
<code>inlateout(&lt;reg&gt;) &lt;expr&gt;</code> / <code>inlateout(&lt;reg&gt;) &lt;in expr&gt; =&gt; &lt;out expr&gt;</code> <ul> <li>Identical to <code>inout</code> except that the register allocator can reuse a register allocated to an <code>in</code> (this can happen if the compiler knows the <code>in</code> has the same initial value as the <code>inlateout</code>).</li> <li>You should only write to the register after all inputs are read, otherwise you may clobber an input.</li> </ul> </li> </ul> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
let mut x: i64 = 4;
// `inlateout` is `inout` using `lateout`
unsafe { core::arch::asm!("inc {}", inlateout(reg) x); }
assert_eq!(x, 5);
}
}</pre> <div class="rule" id="r-asm.operand-type.supported-operands.sym">
<a class="rule-link" href="#r-asm.operand-type.supported-operands.sym" title="asm.operand-type.supported-operands.sym"><span>[asm<wbr>.operand-type<wbr>.supported-operands<wbr>.sym]</wbr></wbr></wbr></span></a> </div> <ul> <li>
<code>sym &lt;path&gt;</code> <ul> <li>
<code>&lt;path&gt;</code> must refer to a <code>fn</code> or <code>static</code>.</li> <li>A mangled symbol name referring to the item is substituted into the asm template string.</li> <li>The substituted string does not include any modifiers (e.g. GOT, PLT, relocations, etc).</li> <li>
<code>&lt;path&gt;</code> is allowed to point to a <code>#[thread_local]</code> static, in which case the assembly code can combine the symbol with relocations (e.g. <code>@plt</code>, <code>@TPOFF</code>) to read from thread-local data.</li> </ul> </li> </ul> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
extern "C" fn foo() {
    println!("Hello from inline assembly")
}
// `sym` can be used to refer to a function (even if it doesn't have an
// external name we can directly write)
unsafe { core::arch::asm!("call {}", sym foo, clobber_abi("C")); }
}
}</pre> <ul> <li>
<code>const &lt;expr&gt;</code> <ul> <li>
<code>&lt;expr&gt;</code> must be an integer constant expression. This expression follows the same rules as inline <code>const</code> blocks.</li> <li>The type of the expression may be any integer type, but defaults to <code>i32</code> just like integer literals.</li> <li>The value of the expression is formatted as a string and substituted directly into the asm template string.</li> </ul> </li> </ul> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
// swizzle [0, 1, 2, 3] =&gt; [3, 2, 0, 1]
const SHUFFLE: u8 = 0b01_00_10_11;
let x: core::arch::x86_64::__m128 = unsafe { core::mem::transmute([0u32, 1u32, 2u32, 3u32]) };
let y: core::arch::x86_64::__m128;
// Pass a constant value into an instruction that expects an immediate like `pshufd`
unsafe {
    core::arch::asm!("pshufd {xmm}, {xmm}, {shuffle}",
        xmm = inlateout(xmm_reg) x=&gt;y,
        shuffle = const SHUFFLE
    );
}
let y: [u32; 4] = unsafe { core::mem::transmute(y) };
assert_eq!(y, [3, 2, 0, 1]);
}
}</pre> <div class="rule" id="r-asm.operand-type.supported-operands.label">
<a class="rule-link" href="#r-asm.operand-type.supported-operands.label" title="asm.operand-type.supported-operands.label"><span>[asm<wbr>.operand-type<wbr>.supported-operands<wbr>.label]</wbr></wbr></wbr></span></a> </div> <ul> <li>
<code>label &lt;block&gt;</code> <ul> <li>The address of the block is substituted into the asm template string. The assembly code may jump to the substituted address.</li> <li>For targets that distinguish between direct jumps and indirect jumps (e.g. x86-64 with <code>cf-protection</code> enabled), the assembly code must not jump to the substituted address indirectly.</li> <li>After execution of the block, the <code>asm!</code> expression returns.</li> <li>The type of the block must be unit or <code>!</code> (never).</li> <li>The block starts a new safety context; unsafe operations within the <code>label</code> block must be wrapped in an inner <code>unsafe</code> block, even though the entire <code>asm!</code> expression is already wrapped in <code>unsafe</code>.</li> </ul> </li> </ul> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")]
unsafe {
    core::arch::asm!("jmp {}", label {
        println!("Hello from inline assembly label");
    });
}
}</pre> <div class="rule" id="r-asm.operand-type.left-to-right">
<a class="rule-link" href="#r-asm.operand-type.left-to-right" title="asm.operand-type.left-to-right"><span>[asm<wbr>.operand-type<wbr>.left-to-right]</wbr></wbr></span></a> </div> <p>Operand expressions are evaluated from left to right, just like function call arguments. After the <code>asm!</code> has executed, outputs are written to in left to right order. This is significant if two outputs point to the same place: that place will contain the value of the rightmost output.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
let mut y: i64;
// y gets its value from the second output, rather than the first
unsafe { core::arch::asm!("mov {}, 0", "mov {}, 1", out(reg) y, out(reg) y); }
assert_eq!(y, 1);
}
}</pre> <div class="rule" id="r-asm.operand-type.naked_asm-restriction">
<a class="rule-link" href="#r-asm.operand-type.naked_asm-restriction" title="asm.operand-type.naked_asm-restriction"><span>[asm<wbr>.operand-type<wbr>.naked_asm-restriction]</wbr></wbr></span></a> </div> <p>Because <code>naked_asm!</code> defines a whole function body and the compiler cannot emit any additional code to handle operands, it can only use <code>sym</code> and <code>const</code> operands.</p> <div class="rule" id="r-asm.operand-type.global_asm-restriction">
<a class="rule-link" href="#r-asm.operand-type.global_asm-restriction" title="asm.operand-type.global_asm-restriction"><span>[asm<wbr>.operand-type<wbr>.global_asm-restriction]</wbr></wbr></span></a> </div> <p>Because <code>global_asm!</code> exists outside a function, it can only use <code>sym</code> and <code>const</code> operands.</p> <pre data-language="rust">fn main() {}
// register operands aren't allowed, since we aren't in a function
#[cfg(target_arch = "x86_64")]
core::arch::global_asm!("", in(reg) 5);
// ERROR: the `in` operand cannot be used with `global_asm!`
#[cfg(not(target_arch = "x86_64"))] core::compile_error!("Test not supported on this arch");</pre> <pre data-language="rust">fn main() {}
fn foo() {}

#[cfg(target_arch = "x86_64")]
// `const` and `sym` are both allowed, however
core::arch::global_asm!("/* {} {} */", const 0, sym foo);</pre> <div class="rule" id="r-asm.register-operands">
<a class="rule-link" href="#r-asm.register-operands" title="asm.register-operands"><span>[asm<wbr>.register-operands]</wbr></span></a> </div> <h2 id="register-operands">Register operands</h2> <div class="rule" id="r-asm.register-operands.register-or-class">
<a class="rule-link" href="#r-asm.register-operands.register-or-class" title="asm.register-operands.register-or-class"><span>[asm<wbr>.register-operands<wbr>.register-or-class]</wbr></wbr></span></a> </div> <p>Input and output operands can be specified either as an explicit register or as a register class from which the register allocator can select a register. Explicit registers are specified as string literals (e.g. <code>"eax"</code>) while register classes are specified as identifiers (e.g. <code>reg</code>).</p> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
let mut y: i64;
// We can name both `reg`, or an explicit register like `eax` to get an
// integer register
unsafe { core::arch::asm!("mov eax, {:e}", in(reg) 5, lateout("eax") y); }
assert_eq!(y, 5);
}
}</pre> <div class="rule" id="r-asm.register-operands.equivalence-to-base-register">
<a class="rule-link" href="#r-asm.register-operands.equivalence-to-base-register" title="asm.register-operands.equivalence-to-base-register"><span>[asm<wbr>.register-operands<wbr>.equivalence-to-base-register]</wbr></wbr></span></a> </div> <p>Note that explicit registers treat register aliases (e.g. <code>r14</code> vs <code>lr</code> on ARM) and smaller views of a register (e.g. <code>eax</code> vs <code>rax</code>) as equivalent to the base register.</p> <div class="rule" id="r-asm.register-operands.error-two-operands">
<a class="rule-link" href="#r-asm.register-operands.error-two-operands" title="asm.register-operands.error-two-operands"><span>[asm<wbr>.register-operands<wbr>.error-two-operands]</wbr></wbr></span></a> </div> <p>It is a compile-time error to use the same explicit register for two input operands or two output operands.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
// We can't name eax twice
unsafe { core::arch::asm!("", in("eax") 5, in("eax") 4); }
// ERROR: register `eax` conflicts with register `eax`
}
#[cfg(not(target_arch = "x86_64"))] core::compile_error!("Test not supported on this arch");
}</pre> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
// ... even using different aliases
unsafe { core::arch::asm!("", in("ax") 5, in("rax") 4); }
// ERROR: register `rax` conflicts with register `ax`
}
#[cfg(not(target_arch = "x86_64"))] core::compile_error!("Test not supported on this arch");
}</pre> <div class="rule" id="r-asm.register-operands.error-overlapping">
<a class="rule-link" href="#r-asm.register-operands.error-overlapping" title="asm.register-operands.error-overlapping"><span>[asm<wbr>.register-operands<wbr>.error-overlapping]</wbr></wbr></span></a> </div> <p>Additionally, it is also a compile-time error to use overlapping registers (e.g. ARM VFP) in input operands or in output operands.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
// al overlaps with ax, so we can't name both of them.
unsafe { core::arch::asm!("", in("ax") 5, in("al") 4i8); }
// ERROR: register `al` conflicts with register `ax`
}
#[cfg(not(target_arch = "x86_64"))] core::compile_error!("Test not supported on this arch");
}</pre> <div class="rule" id="r-asm.register-operands.allowed-types">
<a class="rule-link" href="#r-asm.register-operands.allowed-types" title="asm.register-operands.allowed-types"><span>[asm<wbr>.register-operands<wbr>.allowed-types]</wbr></wbr></span></a> </div> <p>Only the following types are allowed as operands for inline assembly:</p> <ul> <li>Integers (signed and unsigned)</li> <li>Floating-point numbers</li> <li>Pointers (thin only)</li> <li>Function pointers</li> <li>SIMD vectors (structs defined with <code>#[repr(simd)]</code> and which implement <code>Copy</code>). This includes architecture-specific vector types defined in <code>std::arch</code> such as <code>__m128</code> (x86) or <code>int8x16_t</code> (ARM).</li> </ul> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
extern "C" fn foo() {}

// Integers are allowed...
let y: i64 = 5;
unsafe { core::arch::asm!("/* {} */", in(reg) y); }

// and pointers...
let py = &amp;raw const y;
unsafe { core::arch::asm!("/* {} */", in(reg) py); }

// floats as well...
let f = 1.0f32;
unsafe { core::arch::asm!("/* {} */", in(xmm_reg) f); }

// even function pointers and simd vectors.
let func: extern "C" fn() = foo;
unsafe { core::arch::asm!("/* {} */", in(reg) func); }

let z = unsafe { core::arch::x86_64::_mm_set_epi64x(1, 0) };
unsafe { core::arch::asm!("/* {} */", in(xmm_reg) z); }
}
}</pre> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
struct Foo;
let x: Foo = Foo;
// Complex types like structs are not allowed
unsafe { core::arch::asm!("/* {} */", in(reg) x); }
// ERROR: cannot use value of type `Foo` for inline assembly
}
#[cfg(not(target_arch = "x86_64"))] core::compile_error!("Test not supported on this arch");
}</pre> <div class="rule" id="r-asm.register-operands.supported-register-classes">
<a class="rule-link" href="#r-asm.register-operands.supported-register-classes" title="asm.register-operands.supported-register-classes"><span>[asm<wbr>.register-operands<wbr>.supported-register-classes]</wbr></wbr></span></a> </div> <p>Here is the list of currently supported register classes:</p> <div class="table-wrapper">
<table>
<thead><tr>
<th>Architecture</th>
<th>Register class</th>
<th>Registers</th>
<th>LLVM constraint code</th>
</tr></thead>
<tbody> <tr>
<td>x86</td>
<td><code>reg</code></td>
<td>
<code>ax</code>, <code>bx</code>, <code>cx</code>, <code>dx</code>, <code>si</code>, <code>di</code>, <code>bp</code>, <code>r[8-15]</code> (x86-64 only)</td>
<td><code>r</code></td>
</tr> <tr>
<td>x86</td>
<td><code>reg_abcd</code></td>
<td>
<code>ax</code>, <code>bx</code>, <code>cx</code>, <code>dx</code>
</td>
<td><code>Q</code></td>
</tr> <tr>
<td>x86-32</td>
<td><code>reg_byte</code></td>
<td>
<code>al</code>, <code>bl</code>, <code>cl</code>, <code>dl</code>, <code>ah</code>, <code>bh</code>, <code>ch</code>, <code>dh</code>
</td>
<td><code>q</code></td>
</tr> <tr>
<td>x86-64</td>
<td>
<code>reg_byte</code>*</td>
<td>
<code>al</code>, <code>bl</code>, <code>cl</code>, <code>dl</code>, <code>sil</code>, <code>dil</code>, <code>bpl</code>, <code>r[8-15]b</code>
</td>
<td><code>q</code></td>
</tr> <tr>
<td>x86</td>
<td><code>xmm_reg</code></td>
<td>
<code>xmm[0-7]</code> (x86) <code>xmm[0-15]</code> (x86-64)</td>
<td><code>x</code></td>
</tr> <tr>
<td>x86</td>
<td><code>ymm_reg</code></td>
<td>
<code>ymm[0-7]</code> (x86) <code>ymm[0-15]</code> (x86-64)</td>
<td><code>x</code></td>
</tr> <tr>
<td>x86</td>
<td><code>zmm_reg</code></td>
<td>
<code>zmm[0-7]</code> (x86) <code>zmm[0-31]</code> (x86-64)</td>
<td><code>v</code></td>
</tr> <tr>
<td>x86</td>
<td><code>kreg</code></td>
<td><code>k[1-7]</code></td>
<td><code>Yk</code></td>
</tr> <tr>
<td>x86</td>
<td><code>kreg0</code></td>
<td><code>k0</code></td>
<td>Only clobbers</td>
</tr> <tr>
<td>x86</td>
<td><code>x87_reg</code></td>
<td><code>st([0-7])</code></td>
<td>Only clobbers</td>
</tr> <tr>
<td>x86</td>
<td><code>mmx_reg</code></td>
<td><code>mm[0-7]</code></td>
<td>Only clobbers</td>
</tr> <tr>
<td>x86-64</td>
<td><code>tmm_reg</code></td>
<td><code>tmm[0-7]</code></td>
<td>Only clobbers</td>
</tr> <tr>
<td>AArch64</td>
<td><code>reg</code></td>
<td><code>x[0-30]</code></td>
<td><code>r</code></td>
</tr> <tr>
<td>AArch64</td>
<td><code>vreg</code></td>
<td><code>v[0-31]</code></td>
<td><code>w</code></td>
</tr> <tr>
<td>AArch64</td>
<td><code>vreg_low16</code></td>
<td><code>v[0-15]</code></td>
<td><code>x</code></td>
</tr> <tr>
<td>AArch64</td>
<td><code>preg</code></td>
<td>
<code>p[0-15]</code>, <code>ffr</code>
</td>
<td>Only clobbers</td>
</tr> <tr>
<td>Arm64EC</td>
<td><code>reg</code></td>
<td>
<code>x[0-12]</code>, <code>x[15-22]</code>, <code>x[25-27]</code>, <code>x30</code>
</td>
<td><code>r</code></td>
</tr> <tr>
<td>Arm64EC</td>
<td><code>vreg</code></td>
<td><code>v[0-15]</code></td>
<td><code>w</code></td>
</tr> <tr>
<td>Arm64EC</td>
<td><code>vreg_low16</code></td>
<td><code>v[0-15]</code></td>
<td><code>x</code></td>
</tr> <tr>
<td>ARM (ARM/Thumb2)</td>
<td><code>reg</code></td>
<td>
<code>r[0-12]</code>, <code>r14</code>
</td>
<td><code>r</code></td>
</tr> <tr>
<td>ARM (Thumb1)</td>
<td><code>reg</code></td>
<td><code>r[0-7]</code></td>
<td><code>r</code></td>
</tr> <tr>
<td>ARM</td>
<td><code>sreg</code></td>
<td><code>s[0-31]</code></td>
<td><code>t</code></td>
</tr> <tr>
<td>ARM</td>
<td><code>sreg_low16</code></td>
<td><code>s[0-15]</code></td>
<td><code>x</code></td>
</tr> <tr>
<td>ARM</td>
<td><code>dreg</code></td>
<td><code>d[0-31]</code></td>
<td><code>w</code></td>
</tr> <tr>
<td>ARM</td>
<td><code>dreg_low16</code></td>
<td><code>d[0-15]</code></td>
<td><code>t</code></td>
</tr> <tr>
<td>ARM</td>
<td><code>dreg_low8</code></td>
<td><code>d[0-8]</code></td>
<td><code>x</code></td>
</tr> <tr>
<td>ARM</td>
<td><code>qreg</code></td>
<td><code>q[0-15]</code></td>
<td><code>w</code></td>
</tr> <tr>
<td>ARM</td>
<td><code>qreg_low8</code></td>
<td><code>q[0-7]</code></td>
<td><code>t</code></td>
</tr> <tr>
<td>ARM</td>
<td><code>qreg_low4</code></td>
<td><code>q[0-3]</code></td>
<td><code>x</code></td>
</tr> <tr>
<td>RISC-V</td>
<td><code>reg</code></td>
<td>
<code>x1</code>, <code>x[5-7]</code>, <code>x[9-15]</code>, <code>x[16-31]</code> (non-RV32E)</td>
<td><code>r</code></td>
</tr> <tr>
<td>RISC-V</td>
<td><code>freg</code></td>
<td><code>f[0-31]</code></td>
<td><code>f</code></td>
</tr> <tr>
<td>RISC-V</td>
<td><code>vreg</code></td>
<td><code>v[0-31]</code></td>
<td>Only clobbers</td>
</tr> <tr>
<td>LoongArch</td>
<td><code>reg</code></td>
<td>
<code>$r1</code>, <code>$r[4-20]</code>, <code>$r[23,30]</code>
</td>
<td><code>r</code></td>
</tr> <tr>
<td>LoongArch</td>
<td><code>freg</code></td>
<td><code>$f[0-31]</code></td>
<td><code>f</code></td>
</tr> <tr>
<td>s390x</td>
<td><code>reg</code></td>
<td>
<code>r[0-10]</code>, <code>r[12-14]</code>
</td>
<td><code>r</code></td>
</tr> <tr>
<td>s390x</td>
<td><code>reg_addr</code></td>
<td>
<code>r[1-10]</code>, <code>r[12-14]</code>
</td>
<td><code>a</code></td>
</tr> <tr>
<td>s390x</td>
<td><code>freg</code></td>
<td><code>f[0-15]</code></td>
<td><code>f</code></td>
</tr> <tr>
<td>s390x</td>
<td><code>vreg</code></td>
<td><code>v[0-31]</code></td>
<td>Only clobbers</td>
</tr> <tr>
<td>s390x</td>
<td><code>areg</code></td>
<td><code>a[2-15]</code></td>
<td>Only clobbers</td>
</tr> </tbody>
</table> </div>
<div class="alert alert-note"> <blockquote> <p class="alert-title">Note</p> <ul> <li>On x86 we treat <code>reg_byte</code> differently from <code>reg</code> because the compiler can allocate <code>al</code> and <code>ah</code> separately whereas <code>reg</code> reserves the whole register.</li> <li>On x86-64 the high byte registers (e.g. <code>ah</code>) are not available in the <code>reg_byte</code> register class.</li> <li>Some register classes are marked as “Only clobbers” which means that registers in these classes cannot be used for inputs or outputs, only clobbers of the form <code>out(&lt;explicit register&gt;) _</code> or <code>lateout(&lt;explicit register&gt;) _</code>.</li> </ul> </blockquote> </div> <div class="rule" id="r-asm.register-operands.value-type-constraints">
<a class="rule-link" href="#r-asm.register-operands.value-type-constraints" title="asm.register-operands.value-type-constraints"><span>[asm<wbr>.register-operands<wbr>.value-type-constraints]</wbr></wbr></span></a> </div> <p>Each register class has constraints on which value types they can be used with. This is necessary because the way a value is loaded into a register depends on its type. For example, on big-endian systems, loading a <code>i32x4</code> and a <code>i8x16</code> into a SIMD register may result in different register contents even if the byte-wise memory representation of both values is identical. The availability of supported types for a particular register class may depend on what target features are currently enabled.</p> <div class="table-wrapper">
<table>
<thead><tr>
<th>Architecture</th>
<th>Register class</th>
<th>Target feature</th>
<th>Allowed types</th>
</tr></thead>
<tbody> <tr>
<td>x86-32</td>
<td><code>reg</code></td>
<td>None</td>
<td>
<code>i16</code>, <code>i32</code>, <code>f32</code>
</td>
</tr> <tr>
<td>x86-64</td>
<td><code>reg</code></td>
<td>None</td>
<td>
<code>i16</code>, <code>i32</code>, <code>f32</code>, <code>i64</code>, <code>f64</code>
</td>
</tr> <tr>
<td>x86</td>
<td><code>reg_byte</code></td>
<td>None</td>
<td><code>i8</code></td>
</tr> <tr>
<td>x86</td>
<td><code>xmm_reg</code></td>
<td><code>sse</code></td>
<td>
<code>i32</code>, <code>f32</code>, <code>i64</code>, <code>f64</code>, <br> <code>i8x16</code>, <code>i16x8</code>, <code>i32x4</code>, <code>i64x2</code>, <code>f32x4</code>, <code>f64x2</code>
</td>
</tr> <tr>
<td>x86</td>
<td><code>ymm_reg</code></td>
<td><code>avx</code></td>
<td>
<code>i32</code>, <code>f32</code>, <code>i64</code>, <code>f64</code>, <br> <code>i8x16</code>, <code>i16x8</code>, <code>i32x4</code>, <code>i64x2</code>, <code>f32x4</code>, <code>f64x2</code> <br> <code>i8x32</code>, <code>i16x16</code>, <code>i32x8</code>, <code>i64x4</code>, <code>f32x8</code>, <code>f64x4</code>
</td>
</tr> <tr>
<td>x86</td>
<td><code>zmm_reg</code></td>
<td><code>avx512f</code></td>
<td>
<code>i32</code>, <code>f32</code>, <code>i64</code>, <code>f64</code>, <br> <code>i8x16</code>, <code>i16x8</code>, <code>i32x4</code>, <code>i64x2</code>, <code>f32x4</code>, <code>f64x2</code> <br> <code>i8x32</code>, <code>i16x16</code>, <code>i32x8</code>, <code>i64x4</code>, <code>f32x8</code>, <code>f64x4</code> <br> <code>i8x64</code>, <code>i16x32</code>, <code>i32x16</code>, <code>i64x8</code>, <code>f32x16</code>, <code>f64x8</code>
</td>
</tr> <tr>
<td>x86</td>
<td><code>kreg</code></td>
<td><code>avx512f</code></td>
<td>
<code>i8</code>, <code>i16</code>
</td>
</tr> <tr>
<td>x86</td>
<td><code>kreg</code></td>
<td><code>avx512bw</code></td>
<td>
<code>i32</code>, <code>i64</code>
</td>
</tr> <tr>
<td>x86</td>
<td><code>mmx_reg</code></td>
<td>N/A</td>
<td>Only clobbers</td>
</tr> <tr>
<td>x86</td>
<td><code>x87_reg</code></td>
<td>N/A</td>
<td>Only clobbers</td>
</tr> <tr>
<td>x86</td>
<td><code>tmm_reg</code></td>
<td>N/A</td>
<td>Only clobbers</td>
</tr> <tr>
<td>AArch64</td>
<td><code>reg</code></td>
<td>None</td>
<td>
<code>i8</code>, <code>i16</code>, <code>i32</code>, <code>f32</code>, <code>i64</code>, <code>f64</code>
</td>
</tr> <tr>
<td>AArch64</td>
<td><code>vreg</code></td>
<td><code>neon</code></td>
<td>
<code>i8</code>, <code>i16</code>, <code>i32</code>, <code>f32</code>, <code>i64</code>, <code>f64</code>, <br> <code>i8x8</code>, <code>i16x4</code>, <code>i32x2</code>, <code>i64x1</code>, <code>f32x2</code>, <code>f64x1</code>, <br> <code>i8x16</code>, <code>i16x8</code>, <code>i32x4</code>, <code>i64x2</code>, <code>f32x4</code>, <code>f64x2</code>
</td>
</tr> <tr>
<td>AArch64</td>
<td><code>preg</code></td>
<td>N/A</td>
<td>Only clobbers</td>
</tr> <tr>
<td>Arm64EC</td>
<td><code>reg</code></td>
<td>None</td>
<td>
<code>i8</code>, <code>i16</code>, <code>i32</code>, <code>f32</code>, <code>i64</code>, <code>f64</code>
</td>
</tr> <tr>
<td>Arm64EC</td>
<td><code>vreg</code></td>
<td><code>neon</code></td>
<td>
<code>i8</code>, <code>i16</code>, <code>i32</code>, <code>f32</code>, <code>i64</code>, <code>f64</code>, <br> <code>i8x8</code>, <code>i16x4</code>, <code>i32x2</code>, <code>i64x1</code>, <code>f32x2</code>, <code>f64x1</code>, <br> <code>i8x16</code>, <code>i16x8</code>, <code>i32x4</code>, <code>i64x2</code>, <code>f32x4</code>, <code>f64x2</code>
</td>
</tr> <tr>
<td>ARM</td>
<td><code>reg</code></td>
<td>None</td>
<td>
<code>i8</code>, <code>i16</code>, <code>i32</code>, <code>f32</code>
</td>
</tr> <tr>
<td>ARM</td>
<td><code>sreg</code></td>
<td><code>vfp2</code></td>
<td>
<code>i32</code>, <code>f32</code>
</td>
</tr> <tr>
<td>ARM</td>
<td><code>dreg</code></td>
<td><code>vfp2</code></td>
<td>
<code>i64</code>, <code>f64</code>, <code>i8x8</code>, <code>i16x4</code>, <code>i32x2</code>, <code>i64x1</code>, <code>f32x2</code>
</td>
</tr> <tr>
<td>ARM</td>
<td><code>qreg</code></td>
<td><code>neon</code></td>
<td>
<code>i8x16</code>, <code>i16x8</code>, <code>i32x4</code>, <code>i64x2</code>, <code>f32x4</code>
</td>
</tr> <tr>
<td>RISC-V32</td>
<td><code>reg</code></td>
<td>None</td>
<td>
<code>i8</code>, <code>i16</code>, <code>i32</code>, <code>f32</code>
</td>
</tr> <tr>
<td>RISC-V64</td>
<td><code>reg</code></td>
<td>None</td>
<td>
<code>i8</code>, <code>i16</code>, <code>i32</code>, <code>f32</code>, <code>i64</code>, <code>f64</code>
</td>
</tr> <tr>
<td>RISC-V</td>
<td><code>freg</code></td>
<td><code>f</code></td>
<td><code>f32</code></td>
</tr> <tr>
<td>RISC-V</td>
<td><code>freg</code></td>
<td><code>d</code></td>
<td><code>f64</code></td>
</tr> <tr>
<td>RISC-V</td>
<td><code>vreg</code></td>
<td>N/A</td>
<td>Only clobbers</td>
</tr> <tr>
<td>LoongArch64</td>
<td><code>reg</code></td>
<td>None</td>
<td>
<code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>f32</code>, <code>f64</code>
</td>
</tr> <tr>
<td>LoongArch64</td>
<td><code>freg</code></td>
<td><code>f</code></td>
<td><code>f32</code></td>
</tr> <tr>
<td>LoongArch64</td>
<td><code>freg</code></td>
<td><code>d</code></td>
<td><code>f64</code></td>
</tr> <tr>
<td>s390x</td>
<td>
<code>reg</code>, <code>reg_addr</code>
</td>
<td>None</td>
<td>
<code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>
</td>
</tr> <tr>
<td>s390x</td>
<td><code>freg</code></td>
<td>None</td>
<td>
<code>f32</code>, <code>f64</code>
</td>
</tr> <tr>
<td>s390x</td>
<td><code>vreg</code></td>
<td>N/A</td>
<td>Only clobbers</td>
</tr> <tr>
<td>s390x</td>
<td><code>areg</code></td>
<td>N/A</td>
<td>Only clobbers</td>
</tr> </tbody>
</table> </div>
<div class="alert alert-note"> <blockquote> <p class="alert-title">Note</p> <p>For the purposes of the above table pointers, function pointers and <code>isize</code>/<code>usize</code> are treated as the equivalent integer type (<code>i16</code>/<code>i32</code>/<code>i64</code> depending on the target).</p> </blockquote> </div> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
let x = 5i32;
let y = -1i8;
let z = unsafe { core::arch::x86_64::_mm_set_epi64x(1, 0) };

// reg is valid for `i32`, `reg_byte` is valid for `i8`, and xmm_reg is valid for `__m128i`
// We can't use `tmm0` as an input or output, but we can clobber it.
unsafe { core::arch::asm!("/* {} {} {} */", in(reg) x, in(reg_byte) y, in(xmm_reg) z, out("tmm0") _); }
}
}</pre> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
let z = unsafe { core::arch::x86_64::_mm_set_epi64x(1, 0) };
// We can't pass an `__m128i` to a `reg` input
unsafe { core::arch::asm!("/* {} */", in(reg) z); }
// ERROR: type `__m128i` cannot be used with this register class
}
#[cfg(not(target_arch = "x86_64"))] core::compile_error!("Test not supported on this arch");
}</pre> <div class="rule" id="r-asm.register-operands.smaller-value">
<a class="rule-link" href="#r-asm.register-operands.smaller-value" title="asm.register-operands.smaller-value"><span>[asm<wbr>.register-operands<wbr>.smaller-value]</wbr></wbr></span></a> </div> <p>If a value is of a smaller size than the register it is allocated in then the upper bits of that register will have an undefined value for inputs and will be ignored for outputs. The only exception is the <code>freg</code> register class on RISC-V where <code>f32</code> values are NaN-boxed in a <code>f64</code> as required by the RISC-V architecture.</p>  <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
let mut x: i64;
// Moving a 32-bit value into a 64-bit value, oops.
#[allow(asm_sub_register)] // rustc warns about this behavior
unsafe { core::arch::asm!("mov {}, {}", lateout(reg) x, in(reg) 4i32); }
// top 32-bits are indeterminate
assert_eq!(x, 4); // This assertion is not guaranteed to succeed
assert_eq!(x &amp; 0xFFFFFFFF, 4); // However, this one will succeed
}
}</pre> <div class="rule" id="r-asm.register-operands.separate-input-output">
<a class="rule-link" href="#r-asm.register-operands.separate-input-output" title="asm.register-operands.separate-input-output"><span>[asm<wbr>.register-operands<wbr>.separate-input-output]</wbr></wbr></span></a> </div> <p>When separate input and output expressions are specified for an <code>inout</code> operand, both expressions must have the same type. The only exception is if both operands are pointers or integers, in which case they are only required to have the same size. This restriction exists because the register allocators in LLVM and GCC sometimes cannot handle tied operands with different types.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
// Pointers and integers can mix (as long as they are the same size)
let x: isize = 0;
let y: *mut ();
// Transmute an `isize` to a `*mut ()`, using inline assembly magic
unsafe { core::arch::asm!("/*{}*/", inout(reg) x=&gt;y); }
assert!(y.is_null()); // Extremely roundabout way to make a null pointer
}
}</pre> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
let x: i32 = 0;
let y: f32;
// But we can't reinterpret an `i32` to an `f32` like this
unsafe { core::arch::asm!("/* {} */", inout(reg) x=&gt;y); }
// ERROR: incompatible types for asm inout argument
}
#[cfg(not(target_arch = "x86_64"))] core::compile_error!("Test not supported on this arch");
}</pre> <div class="rule" id="r-asm.register-names">
<a class="rule-link" href="#r-asm.register-names" title="asm.register-names"><span>[asm<wbr>.register-names]</wbr></span></a> </div> <h2 id="register-names">Register names</h2> <div class="rule" id="r-asm.register-names.supported-register-aliases">
<a class="rule-link" href="#r-asm.register-names.supported-register-aliases" title="asm.register-names.supported-register-aliases"><span>[asm<wbr>.register-names<wbr>.supported-register-aliases]</wbr></wbr></span></a> </div> <p>Some registers have multiple names. These are all treated by the compiler as identical to the base register name. Here is the list of all supported register aliases:</p> <div class="table-wrapper">
<table>
<thead><tr>
<th>Architecture</th>
<th>Base register</th>
<th>Aliases</th>
</tr></thead>
<tbody> <tr>
<td>x86</td>
<td><code>ax</code></td>
<td>
<code>eax</code>, <code>rax</code>
</td>
</tr> <tr>
<td>x86</td>
<td><code>bx</code></td>
<td>
<code>ebx</code>, <code>rbx</code>
</td>
</tr> <tr>
<td>x86</td>
<td><code>cx</code></td>
<td>
<code>ecx</code>, <code>rcx</code>
</td>
</tr> <tr>
<td>x86</td>
<td><code>dx</code></td>
<td>
<code>edx</code>, <code>rdx</code>
</td>
</tr> <tr>
<td>x86</td>
<td><code>si</code></td>
<td>
<code>esi</code>, <code>rsi</code>
</td>
</tr> <tr>
<td>x86</td>
<td><code>di</code></td>
<td>
<code>edi</code>, <code>rdi</code>
</td>
</tr> <tr>
<td>x86</td>
<td><code>bp</code></td>
<td>
<code>bpl</code>, <code>ebp</code>, <code>rbp</code>
</td>
</tr> <tr>
<td>x86</td>
<td><code>sp</code></td>
<td>
<code>spl</code>, <code>esp</code>, <code>rsp</code>
</td>
</tr> <tr>
<td>x86</td>
<td><code>ip</code></td>
<td>
<code>eip</code>, <code>rip</code>
</td>
</tr> <tr>
<td>x86</td>
<td><code>st(0)</code></td>
<td><code>st</code></td>
</tr> <tr>
<td>x86</td>
<td><code>r[8-15]</code></td>
<td>
<code>r[8-15]b</code>, <code>r[8-15]w</code>, <code>r[8-15]d</code>
</td>
</tr> <tr>
<td>x86</td>
<td><code>xmm[0-31]</code></td>
<td>
<code>ymm[0-31]</code>, <code>zmm[0-31]</code>
</td>
</tr> <tr>
<td>AArch64</td>
<td><code>x[0-30]</code></td>
<td><code>w[0-30]</code></td>
</tr> <tr>
<td>AArch64</td>
<td><code>x29</code></td>
<td><code>fp</code></td>
</tr> <tr>
<td>AArch64</td>
<td><code>x30</code></td>
<td><code>lr</code></td>
</tr> <tr>
<td>AArch64</td>
<td><code>sp</code></td>
<td><code>wsp</code></td>
</tr> <tr>
<td>AArch64</td>
<td><code>xzr</code></td>
<td><code>wzr</code></td>
</tr> <tr>
<td>AArch64</td>
<td><code>v[0-31]</code></td>
<td>
<code>b[0-31]</code>, <code>h[0-31]</code>, <code>s[0-31]</code>, <code>d[0-31]</code>, <code>q[0-31]</code>
</td>
</tr> <tr>
<td>Arm64EC</td>
<td><code>x[0-30]</code></td>
<td><code>w[0-30]</code></td>
</tr> <tr>
<td>Arm64EC</td>
<td><code>x29</code></td>
<td><code>fp</code></td>
</tr> <tr>
<td>Arm64EC</td>
<td><code>x30</code></td>
<td><code>lr</code></td>
</tr> <tr>
<td>Arm64EC</td>
<td><code>sp</code></td>
<td><code>wsp</code></td>
</tr> <tr>
<td>Arm64EC</td>
<td><code>xzr</code></td>
<td><code>wzr</code></td>
</tr> <tr>
<td>Arm64EC</td>
<td><code>v[0-15]</code></td>
<td>
<code>b[0-15]</code>, <code>h[0-15]</code>, <code>s[0-15]</code>, <code>d[0-15]</code>, <code>q[0-15]</code>
</td>
</tr> <tr>
<td>ARM</td>
<td><code>r[0-3]</code></td>
<td><code>a[1-4]</code></td>
</tr> <tr>
<td>ARM</td>
<td><code>r[4-9]</code></td>
<td><code>v[1-6]</code></td>
</tr> <tr>
<td>ARM</td>
<td><code>r9</code></td>
<td><code>rfp</code></td>
</tr> <tr>
<td>ARM</td>
<td><code>r10</code></td>
<td><code>sl</code></td>
</tr> <tr>
<td>ARM</td>
<td><code>r11</code></td>
<td><code>fp</code></td>
</tr> <tr>
<td>ARM</td>
<td><code>r12</code></td>
<td><code>ip</code></td>
</tr> <tr>
<td>ARM</td>
<td><code>r13</code></td>
<td><code>sp</code></td>
</tr> <tr>
<td>ARM</td>
<td><code>r14</code></td>
<td><code>lr</code></td>
</tr> <tr>
<td>ARM</td>
<td><code>r15</code></td>
<td><code>pc</code></td>
</tr> <tr>
<td>RISC-V</td>
<td><code>x0</code></td>
<td><code>zero</code></td>
</tr> <tr>
<td>RISC-V</td>
<td><code>x1</code></td>
<td><code>ra</code></td>
</tr> <tr>
<td>RISC-V</td>
<td><code>x2</code></td>
<td><code>sp</code></td>
</tr> <tr>
<td>RISC-V</td>
<td><code>x3</code></td>
<td><code>gp</code></td>
</tr> <tr>
<td>RISC-V</td>
<td><code>x4</code></td>
<td><code>tp</code></td>
</tr> <tr>
<td>RISC-V</td>
<td><code>x[5-7]</code></td>
<td><code>t[0-2]</code></td>
</tr> <tr>
<td>RISC-V</td>
<td><code>x8</code></td>
<td>
<code>fp</code>, <code>s0</code>
</td>
</tr> <tr>
<td>RISC-V</td>
<td><code>x9</code></td>
<td><code>s1</code></td>
</tr> <tr>
<td>RISC-V</td>
<td><code>x[10-17]</code></td>
<td><code>a[0-7]</code></td>
</tr> <tr>
<td>RISC-V</td>
<td><code>x[18-27]</code></td>
<td><code>s[2-11]</code></td>
</tr> <tr>
<td>RISC-V</td>
<td><code>x[28-31]</code></td>
<td><code>t[3-6]</code></td>
</tr> <tr>
<td>RISC-V</td>
<td><code>f[0-7]</code></td>
<td><code>ft[0-7]</code></td>
</tr> <tr>
<td>RISC-V</td>
<td><code>f[8-9]</code></td>
<td><code>fs[0-1]</code></td>
</tr> <tr>
<td>RISC-V</td>
<td><code>f[10-17]</code></td>
<td><code>fa[0-7]</code></td>
</tr> <tr>
<td>RISC-V</td>
<td><code>f[18-27]</code></td>
<td><code>fs[2-11]</code></td>
</tr> <tr>
<td>RISC-V</td>
<td><code>f[28-31]</code></td>
<td><code>ft[8-11]</code></td>
</tr> <tr>
<td>LoongArch</td>
<td><code>$r0</code></td>
<td><code>$zero</code></td>
</tr> <tr>
<td>LoongArch</td>
<td><code>$r1</code></td>
<td><code>$ra</code></td>
</tr> <tr>
<td>LoongArch</td>
<td><code>$r2</code></td>
<td><code>$tp</code></td>
</tr> <tr>
<td>LoongArch</td>
<td><code>$r3</code></td>
<td><code>$sp</code></td>
</tr> <tr>
<td>LoongArch</td>
<td><code>$r[4-11]</code></td>
<td><code>$a[0-7]</code></td>
</tr> <tr>
<td>LoongArch</td>
<td><code>$r[12-20]</code></td>
<td><code>$t[0-8]</code></td>
</tr> <tr>
<td>LoongArch</td>
<td><code>$r21</code></td>
<td></td>
</tr> <tr>
<td>LoongArch</td>
<td><code>$r22</code></td>
<td>
<code>$fp</code>, <code>$s9</code>
</td>
</tr> <tr>
<td>LoongArch</td>
<td><code>$r[23-31]</code></td>
<td><code>$s[0-8]</code></td>
</tr> <tr>
<td>LoongArch</td>
<td><code>$f[0-7]</code></td>
<td><code>$fa[0-7]</code></td>
</tr> <tr>
<td>LoongArch</td>
<td><code>$f[8-23]</code></td>
<td><code>$ft[0-15]</code></td>
</tr> <tr>
<td>LoongArch</td>
<td><code>$f[24-31]</code></td>
<td><code>$fs[0-7]</code></td>
</tr> </tbody>
</table> </div> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
let z = 0i64;
// rax is an alias for eax and ax
unsafe { core::arch::asm!("", in("rax") z); }
}
}</pre> <div class="rule" id="r-asm.register-names.not-for-io">
<a class="rule-link" href="#r-asm.register-names.not-for-io" title="asm.register-names.not-for-io"><span>[asm<wbr>.register-names<wbr>.not-for-io]</wbr></wbr></span></a> </div> <p>Some registers cannot be used for input or output operands:</p> <div class="table-wrapper">
<table>
<thead><tr>
<th>Architecture</th>
<th>Unsupported register</th>
<th>Reason</th>
</tr></thead>
<tbody> <tr>
<td>All</td>
<td>
<code>sp</code>, <code>r15</code> (s390x)</td>
<td>The stack pointer must be restored to its original value at the end of the assembly code or before jumping to a <code>label</code> block.</td>
</tr> <tr>
<td>All</td>
<td>
<code>bp</code> (x86), <code>x29</code> (AArch64 and Arm64EC), <code>x8</code> (RISC-V), <code>$fp</code> (LoongArch), <code>r11</code> (s390x)</td>
<td>The frame pointer cannot be used as an input or output.</td>
</tr> <tr>
<td>ARM</td>
<td>
<code>r7</code> or <code>r11</code>
</td>
<td>On ARM the frame pointer can be either <code>r7</code> or <code>r11</code> depending on the target. The frame pointer cannot be used as an input or output.</td>
</tr> <tr>
<td>All</td>
<td>
<code>si</code> (x86-32), <code>bx</code> (x86-64), <code>r6</code> (ARM), <code>x19</code> (AArch64 and Arm64EC), <code>x9</code> (RISC-V), <code>$s8</code> (LoongArch)</td>
<td>This is used internally by LLVM as a “base pointer” for functions with complex stack frames.</td>
</tr> <tr>
<td>x86</td>
<td><code>ip</code></td>
<td>This is the program counter, not a real register.</td>
</tr> <tr>
<td>AArch64</td>
<td><code>xzr</code></td>
<td>This is a constant zero register which can’t be modified.</td>
</tr> <tr>
<td>AArch64</td>
<td><code>x18</code></td>
<td>This is an OS-reserved register on some AArch64 targets.</td>
</tr> <tr>
<td>Arm64EC</td>
<td><code>xzr</code></td>
<td>This is a constant zero register which can’t be modified.</td>
</tr> <tr>
<td>Arm64EC</td>
<td><code>x18</code></td>
<td>This is an OS-reserved register.</td>
</tr> <tr>
<td>Arm64EC</td>
<td>
<code>x13</code>, <code>x14</code>, <code>x23</code>, <code>x24</code>, <code>x28</code>, <code>v[16-31]</code>, <code>p[0-15]</code>, <code>ffr</code>
</td>
<td>These are AArch64 registers that are not supported for Arm64EC.</td>
</tr> <tr>
<td>ARM</td>
<td><code>pc</code></td>
<td>This is the program counter, not a real register.</td>
</tr> <tr>
<td>ARM</td>
<td><code>r9</code></td>
<td>This is an OS-reserved register on some ARM targets.</td>
</tr> <tr>
<td>RISC-V</td>
<td><code>x0</code></td>
<td>This is a constant zero register which can’t be modified.</td>
</tr> <tr>
<td>RISC-V</td>
<td>
<code>gp</code>, <code>tp</code>
</td>
<td>These registers are reserved and cannot be used as inputs or outputs.</td>
</tr> <tr>
<td>LoongArch</td>
<td>
<code>$r0</code> or <code>$zero</code>
</td>
<td>This is a constant zero register which can’t be modified.</td>
</tr> <tr>
<td>LoongArch</td>
<td>
<code>$r2</code> or <code>$tp</code>
</td>
<td>This is reserved for TLS.</td>
</tr> <tr>
<td>LoongArch</td>
<td><code>$r21</code></td>
<td>This is reserved by the ABI.</td>
</tr> <tr>
<td>s390x</td>
<td><code>c[0-15]</code></td>
<td>Reserved by the kernel.</td>
</tr> <tr>
<td>s390x</td>
<td><code>a[0-1]</code></td>
<td>Reserved for system use.</td>
</tr> </tbody>
</table> </div> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
// bp is reserved
unsafe { core::arch::asm!("", in("bp") 5i32); }
// ERROR: invalid register `bp`: the frame pointer cannot be used as an operand for inline asm
}
#[cfg(not(target_arch = "x86_64"))] core::compile_error!("Test not supported on this arch");
}</pre> <div class="rule" id="r-asm.register-names.fp-bp-reserved">
<a class="rule-link" href="#r-asm.register-names.fp-bp-reserved" title="asm.register-names.fp-bp-reserved"><span>[asm<wbr>.register-names<wbr>.fp-bp-reserved]</wbr></wbr></span></a> </div> <p>The frame pointer and base pointer registers are reserved for internal use by LLVM. While <code>asm!</code> statements cannot explicitly specify the use of reserved registers, in some cases LLVM will allocate one of these reserved registers for <code>reg</code> operands. Assembly code making use of reserved registers should be careful since <code>reg</code> operands may use the same registers.</p> <div class="rule" id="r-asm.template-modifiers">
<a class="rule-link" href="#r-asm.template-modifiers" title="asm.template-modifiers"><span>[asm<wbr>.template-modifiers]</wbr></span></a> </div> <h2 id="template-modifiers">Template modifiers</h2> <div class="rule" id="r-asm.template-modifiers.intro">
<a class="rule-link" href="#r-asm.template-modifiers.intro" title="asm.template-modifiers.intro"><span>[asm<wbr>.template-modifiers<wbr>.intro]</wbr></wbr></span></a> </div> <p>The placeholders can be augmented by modifiers which are specified after the <code>:</code> in the curly braces. These modifiers do not affect register allocation, but change the way operands are formatted when inserted into the template string.</p> <div class="rule" id="r-asm.template-modifiers.only-one">
<a class="rule-link" href="#r-asm.template-modifiers.only-one" title="asm.template-modifiers.only-one"><span>[asm<wbr>.template-modifiers<wbr>.only-one]</wbr></wbr></span></a> </div> <p>Only one modifier is allowed per template placeholder.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
// We can't specify both `r` and `e` at the same time.
unsafe { core::arch::asm!("/* {:er}", in(reg) 5i32); }
// ERROR: asm template modifier must be a single character
}
#[cfg(not(target_arch = "x86_64"))] core::compile_error!("Test not supported on this arch");
}</pre> <div class="rule" id="r-asm.template-modifiers.supported-modifiers">
<a class="rule-link" href="#r-asm.template-modifiers.supported-modifiers" title="asm.template-modifiers.supported-modifiers"><span>[asm<wbr>.template-modifiers<wbr>.supported-modifiers]</wbr></wbr></span></a> </div> <p>The supported modifiers are a subset of LLVM’s (and GCC’s) <a href="http://llvm.org/docs/LangRef.html#asm-template-argument-modifiers">asm template argument modifiers</a>, but do not use the same letter codes.</p> <div class="table-wrapper">
<table>
<thead><tr>
<th>Architecture</th>
<th>Register class</th>
<th>Modifier</th>
<th>Example output</th>
<th>LLVM modifier</th>
</tr></thead>
<tbody> <tr>
<td>x86-32</td>
<td><code>reg</code></td>
<td>None</td>
<td><code>eax</code></td>
<td><code>k</code></td>
</tr> <tr>
<td>x86-64</td>
<td><code>reg</code></td>
<td>None</td>
<td><code>rax</code></td>
<td><code>q</code></td>
</tr> <tr>
<td>x86-32</td>
<td><code>reg_abcd</code></td>
<td><code>l</code></td>
<td><code>al</code></td>
<td><code>b</code></td>
</tr> <tr>
<td>x86-64</td>
<td><code>reg</code></td>
<td><code>l</code></td>
<td><code>al</code></td>
<td><code>b</code></td>
</tr> <tr>
<td>x86</td>
<td><code>reg_abcd</code></td>
<td><code>h</code></td>
<td><code>ah</code></td>
<td><code>h</code></td>
</tr> <tr>
<td>x86</td>
<td><code>reg</code></td>
<td><code>x</code></td>
<td><code>ax</code></td>
<td><code>w</code></td>
</tr> <tr>
<td>x86</td>
<td><code>reg</code></td>
<td><code>e</code></td>
<td><code>eax</code></td>
<td><code>k</code></td>
</tr> <tr>
<td>x86-64</td>
<td><code>reg</code></td>
<td><code>r</code></td>
<td><code>rax</code></td>
<td><code>q</code></td>
</tr> <tr>
<td>x86</td>
<td><code>reg_byte</code></td>
<td>None</td>
<td>
<code>al</code> / <code>ah</code>
</td>
<td>None</td>
</tr> <tr>
<td>x86</td>
<td><code>xmm_reg</code></td>
<td>None</td>
<td><code>xmm0</code></td>
<td><code>x</code></td>
</tr> <tr>
<td>x86</td>
<td><code>ymm_reg</code></td>
<td>None</td>
<td><code>ymm0</code></td>
<td><code>t</code></td>
</tr> <tr>
<td>x86</td>
<td><code>zmm_reg</code></td>
<td>None</td>
<td><code>zmm0</code></td>
<td><code>g</code></td>
</tr> <tr>
<td>x86</td>
<td><code>*mm_reg</code></td>
<td><code>x</code></td>
<td><code>xmm0</code></td>
<td><code>x</code></td>
</tr> <tr>
<td>x86</td>
<td><code>*mm_reg</code></td>
<td><code>y</code></td>
<td><code>ymm0</code></td>
<td><code>t</code></td>
</tr> <tr>
<td>x86</td>
<td><code>*mm_reg</code></td>
<td><code>z</code></td>
<td><code>zmm0</code></td>
<td><code>g</code></td>
</tr> <tr>
<td>x86</td>
<td><code>kreg</code></td>
<td>None</td>
<td><code>k1</code></td>
<td>None</td>
</tr> <tr>
<td>AArch64/Arm64EC</td>
<td><code>reg</code></td>
<td>None</td>
<td><code>x0</code></td>
<td><code>x</code></td>
</tr> <tr>
<td>AArch64/Arm64EC</td>
<td><code>reg</code></td>
<td><code>w</code></td>
<td><code>w0</code></td>
<td><code>w</code></td>
</tr> <tr>
<td>AArch64/Arm64EC</td>
<td><code>reg</code></td>
<td><code>x</code></td>
<td><code>x0</code></td>
<td><code>x</code></td>
</tr> <tr>
<td>AArch64/Arm64EC</td>
<td><code>vreg</code></td>
<td>None</td>
<td><code>v0</code></td>
<td>None</td>
</tr> <tr>
<td>AArch64/Arm64EC</td>
<td><code>vreg</code></td>
<td><code>v</code></td>
<td><code>v0</code></td>
<td>None</td>
</tr> <tr>
<td>AArch64/Arm64EC</td>
<td><code>vreg</code></td>
<td><code>b</code></td>
<td><code>b0</code></td>
<td><code>b</code></td>
</tr> <tr>
<td>AArch64/Arm64EC</td>
<td><code>vreg</code></td>
<td><code>h</code></td>
<td><code>h0</code></td>
<td><code>h</code></td>
</tr> <tr>
<td>AArch64/Arm64EC</td>
<td><code>vreg</code></td>
<td><code>s</code></td>
<td><code>s0</code></td>
<td><code>s</code></td>
</tr> <tr>
<td>AArch64/Arm64EC</td>
<td><code>vreg</code></td>
<td><code>d</code></td>
<td><code>d0</code></td>
<td><code>d</code></td>
</tr> <tr>
<td>AArch64/Arm64EC</td>
<td><code>vreg</code></td>
<td><code>q</code></td>
<td><code>q0</code></td>
<td><code>q</code></td>
</tr> <tr>
<td>ARM</td>
<td><code>reg</code></td>
<td>None</td>
<td><code>r0</code></td>
<td>None</td>
</tr> <tr>
<td>ARM</td>
<td><code>sreg</code></td>
<td>None</td>
<td><code>s0</code></td>
<td>None</td>
</tr> <tr>
<td>ARM</td>
<td><code>dreg</code></td>
<td>None</td>
<td><code>d0</code></td>
<td><code>P</code></td>
</tr> <tr>
<td>ARM</td>
<td><code>qreg</code></td>
<td>None</td>
<td><code>q0</code></td>
<td><code>q</code></td>
</tr> <tr>
<td>ARM</td>
<td><code>qreg</code></td>
<td>
<code>e</code> / <code>f</code>
</td>
<td>
<code>d0</code> / <code>d1</code>
</td>
<td>
<code>e</code> / <code>f</code>
</td>
</tr> <tr>
<td>RISC-V</td>
<td><code>reg</code></td>
<td>None</td>
<td><code>x1</code></td>
<td>None</td>
</tr> <tr>
<td>RISC-V</td>
<td><code>freg</code></td>
<td>None</td>
<td><code>f0</code></td>
<td>None</td>
</tr> <tr>
<td>LoongArch</td>
<td><code>reg</code></td>
<td>None</td>
<td><code>$r1</code></td>
<td>None</td>
</tr> <tr>
<td>LoongArch</td>
<td><code>freg</code></td>
<td>None</td>
<td><code>$f0</code></td>
<td>None</td>
</tr> <tr>
<td>s390x</td>
<td><code>reg</code></td>
<td>None</td>
<td><code>%r0</code></td>
<td>None</td>
</tr> <tr>
<td>s390x</td>
<td><code>reg_addr</code></td>
<td>None</td>
<td><code>%r1</code></td>
<td>None</td>
</tr> <tr>
<td>s390x</td>
<td><code>freg</code></td>
<td>None</td>
<td><code>%f0</code></td>
<td>None</td>
</tr> </tbody>
</table> </div>
<div class="alert alert-note"> <blockquote> <p class="alert-title">Note</p> <ul> <li>on ARM <code>e</code> / <code>f</code>: this prints the low or high doubleword register name of a NEON quad (128-bit) register.</li> <li>on x86: our behavior for <code>reg</code> with no modifiers differs from what GCC does. GCC will infer the modifier based on the operand value type, while we default to the full register size.</li> <li>on x86 <code>xmm_reg</code>: the <code>x</code>, <code>t</code> and <code>g</code> LLVM modifiers are not yet implemented in LLVM (they are supported by GCC only), but this should be a simple change.</li> </ul> </blockquote> </div> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
let mut x = 0x10u16;

// u16::swap_bytes using `xchg`
// low half of `{x}` is referred to by `{x:l}`, and the high half by `{x:h}`
unsafe { core::arch::asm!("xchg {x:l}, {x:h}", x = inout(reg_abcd) x); }
assert_eq!(x, 0x1000u16);
}
}</pre> <div class="rule" id="r-asm.template-modifiers.smaller-value">
<a class="rule-link" href="#r-asm.template-modifiers.smaller-value" title="asm.template-modifiers.smaller-value"><span>[asm<wbr>.template-modifiers<wbr>.smaller-value]</wbr></wbr></span></a> </div> <p>As stated in the previous section, passing an input value smaller than the register width will result in the upper bits of the register containing undefined values. This is not a problem if the inline asm only accesses the lower bits of the register, which can be done by using a template modifier to use a subregister name in the assembly code (e.g. <code>ax</code> instead of <code>rax</code>). Since this an easy pitfall, the compiler will suggest a template modifier to use where appropriate given the input type. If all references to an operand already have modifiers then the warning is suppressed for that operand.</p> <div class="rule" id="r-asm.abi-clobbers">
<a class="rule-link" href="#r-asm.abi-clobbers" title="asm.abi-clobbers"><span>[asm<wbr>.abi-clobbers]</wbr></span></a> </div> <h2 id="abi-clobbers">ABI clobbers</h2> <div class="rule" id="r-asm.abi-clobbers.intro">
<a class="rule-link" href="#r-asm.abi-clobbers.intro" title="asm.abi-clobbers.intro"><span>[asm<wbr>.abi-clobbers<wbr>.intro]</wbr></wbr></span></a> </div> <p>The <code>clobber_abi</code> keyword can be used to apply a default set of clobbers to the assembly code. This will automatically insert the necessary clobber constraints as needed for calling a function with a particular calling convention: if the calling convention does not fully preserve the value of a register across a call then <code>lateout("...") _</code> is implicitly added to the operands list (where the <code>...</code> is replaced by the register’s name).</p> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
extern "C" fn foo() -&gt; i32 { 0 }

let z: i32;
// To call a function, we have to inform the compiler that we're clobbering
// callee saved registers
unsafe { core::arch::asm!("call {}", sym foo, out("rax") z, clobber_abi("C")); }
assert_eq!(z, 0);
}
}</pre> <div class="rule" id="r-asm.abi-clobbers.many">
<a class="rule-link" href="#r-asm.abi-clobbers.many" title="asm.abi-clobbers.many"><span>[asm<wbr>.abi-clobbers<wbr>.many]</wbr></wbr></span></a> </div> <p><code>clobber_abi</code> may be specified any number of times. It will insert a clobber for all unique registers in the union of all specified calling conventions.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
extern "sysv64" fn foo() -&gt; i32 { 0 }
extern "win64" fn bar(x: i32) -&gt; i32 { x + 1}

let z: i32;
// We can even call multiple functions with different conventions and
// different saved registers
unsafe {
    core::arch::asm!(
        "call {}",
        "mov ecx, eax",
        "call {}",
        sym foo,
        sym bar,
        out("rax") z,
        clobber_abi("C")
    );
}
assert_eq!(z, 1);
}
}</pre> <div class="rule" id="r-asm.abi-clobbers.must-specify">
<a class="rule-link" href="#r-asm.abi-clobbers.must-specify" title="asm.abi-clobbers.must-specify"><span>[asm<wbr>.abi-clobbers<wbr>.must-specify]</wbr></wbr></span></a> </div> <p>Generic register class outputs are disallowed by the compiler when <code>clobber_abi</code> is used: all outputs must specify an explicit register.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
extern "C" fn foo(x: i32) -&gt; i32 { 0 }

let z: i32;
// explicit registers must be used to not accidentally overlap.
unsafe {
    core::arch::asm!(
        "mov eax, {:e}",
        "call {}",
        out(reg) z,
        sym foo,
        clobber_abi("C")
    );
    // ERROR: asm with `clobber_abi` must specify explicit registers for outputs
}
assert_eq!(z, 0);
}
#[cfg(not(target_arch = "x86_64"))] core::compile_error!("Test not supported on this arch");
}</pre> <div class="rule" id="r-asm.abi-clobbers.explicit-have-precedence">
<a class="rule-link" href="#r-asm.abi-clobbers.explicit-have-precedence" title="asm.abi-clobbers.explicit-have-precedence"><span>[asm<wbr>.abi-clobbers<wbr>.explicit-have-precedence]</wbr></wbr></span></a> </div> <p>Explicit register outputs have precedence over the implicit clobbers inserted by <code>clobber_abi</code>: a clobber will only be inserted for a register if that register is not used as an output.</p> <div class="rule" id="r-asm.abi-clobbers.supported-abis">
<a class="rule-link" href="#r-asm.abi-clobbers.supported-abis" title="asm.abi-clobbers.supported-abis"><span>[asm<wbr>.abi-clobbers<wbr>.supported-abis]</wbr></wbr></span></a> </div> <p>The following ABIs can be used with <code>clobber_abi</code>:</p> <div class="table-wrapper">
<table>
<thead><tr>
<th>Architecture</th>
<th>ABI name</th>
<th>Clobbered registers</th>
</tr></thead>
<tbody> <tr>
<td>x86-32</td>
<td>
<code>"C"</code>, <code>"system"</code>, <code>"efiapi"</code>, <code>"cdecl"</code>, <code>"stdcall"</code>, <code>"fastcall"</code>
</td>
<td>
<code>ax</code>, <code>cx</code>, <code>dx</code>, <code>xmm[0-7]</code>, <code>mm[0-7]</code>, <code>k[0-7]</code>, <code>st([0-7])</code>
</td>
</tr> <tr>
<td>x86-64</td>
<td>
<code>"C"</code>, <code>"system"</code> (on Windows), <code>"efiapi"</code>, <code>"win64"</code>
</td>
<td>
<code>ax</code>, <code>cx</code>, <code>dx</code>, <code>r[8-11]</code>, <code>xmm[0-31]</code>, <code>mm[0-7]</code>, <code>k[0-7]</code>, <code>st([0-7])</code>, <code>tmm[0-7]</code>
</td>
</tr> <tr>
<td>x86-64</td>
<td>
<code>"C"</code>, <code>"system"</code> (on non-Windows), <code>"sysv64"</code>
</td>
<td>
<code>ax</code>, <code>cx</code>, <code>dx</code>, <code>si</code>, <code>di</code>, <code>r[8-11]</code>, <code>xmm[0-31]</code>, <code>mm[0-7]</code>, <code>k[0-7]</code>, <code>st([0-7])</code>, <code>tmm[0-7]</code>
</td>
</tr> <tr>
<td>AArch64</td>
<td>
<code>"C"</code>, <code>"system"</code>, <code>"efiapi"</code>
</td>
<td>
<code>x[0-17]</code>, <code>x18</code>*, <code>x30</code>, <code>v[0-31]</code>, <code>p[0-15]</code>, <code>ffr</code>
</td>
</tr> <tr>
<td>Arm64EC</td>
<td>
<code>"C"</code>, <code>"system"</code>
</td>
<td>
<code>x[0-12]</code>, <code>x[15-17]</code>, <code>x30</code>, <code>v[0-15]</code>
</td>
</tr> <tr>
<td>ARM</td>
<td>
<code>"C"</code>, <code>"system"</code>, <code>"efiapi"</code>, <code>"aapcs"</code>
</td>
<td>
<code>r[0-3]</code>, <code>r12</code>, <code>r14</code>, <code>s[0-15]</code>, <code>d[0-7]</code>, <code>d[16-31]</code>
</td>
</tr> <tr>
<td>RISC-V</td>
<td>
<code>"C"</code>, <code>"system"</code>, <code>"efiapi"</code>
</td>
<td>
<code>x1</code>, <code>x[5-7]</code>, <code>x[10-17]</code>*, <code>x[28-31]</code>*, <code>f[0-7]</code>, <code>f[10-17]</code>, <code>f[28-31]</code>, <code>v[0-31]</code>
</td>
</tr> <tr>
<td>LoongArch</td>
<td>
<code>"C"</code>, <code>"system"</code>
</td>
<td>
<code>$r1</code>, <code>$r[4-20]</code>, <code>$f[0-23]</code>
</td>
</tr> <tr>
<td>s390x</td>
<td>
<code>"C"</code>, <code>"system"</code>
</td>
<td>
<code>r[0-5]</code>, <code>r14</code>, <code>f[0-7]</code>, <code>v[0-31]</code>, <code>a[2-15]</code>
</td>
</tr> </tbody>
</table> </div>
<div class="alert alert-note"> <blockquote> <p class="alert-title">Note</p> <ul> <li>On AArch64 <code>x18</code> only included in the clobber list if it is not considered as a reserved register on the target.</li> <li>On RISC-V <code>x[16-17]</code> and <code>x[28-31]</code> only included in the clobber list if they are not considered as reserved registers on the target.</li> </ul> </blockquote> </div> <p>The list of clobbered registers for each ABI is updated in rustc as architectures gain new registers: this ensures that <code>asm!</code> clobbers will continue to be correct when LLVM starts using these new registers in its generated code.</p> <div class="rule" id="r-asm.options">
<a class="rule-link" href="#r-asm.options" title="asm.options"><span>[asm<wbr>.options]</wbr></span></a> </div> <h2 id="options">Options</h2> <div class="rule" id="r-asm.options.supported-options">
<a class="rule-link" href="#r-asm.options.supported-options" title="asm.options.supported-options"><span>[asm<wbr>.options<wbr>.supported-options]</wbr></wbr></span></a> </div> <p>Flags are used to further influence the behavior of the inline assembly code. Currently the following options are defined:</p> <div class="rule" id="r-asm.options.supported-options.pure">
<a class="rule-link" href="#r-asm.options.supported-options.pure" title="asm.options.supported-options.pure"><span>[asm<wbr>.options<wbr>.supported-options<wbr>.pure]</wbr></wbr></wbr></span></a> </div> <ul> <li>
<code>pure</code>: The assembly code has no side effects, must eventually return, and its outputs depend only on its direct inputs (i.e. the values themselves, not what they point to) or values read from memory (unless the <code>nomem</code> options is also set). This allows the compiler to execute the assembly code fewer times than specified in the program (e.g. by hoisting it out of a loop) or even eliminate it entirely if the outputs are not used. The <code>pure</code> option must be combined with either the <code>nomem</code> or <code>readonly</code> options, otherwise a compile-time error is emitted.</li> </ul> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
let x: i32 = 0;
let z: i32;
// pure can be used to optimize by assuming the assembly has no side effects
unsafe { core::arch::asm!("inc {}", inout(reg) x =&gt; z, options(pure, nomem)); }
assert_eq!(z, 1);
}
}</pre> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
let x: i32 = 0;
let z: i32;
// Either nomem or readonly must be satisfied, to indicate whether or not
// memory is allowed to be read
unsafe { core::arch::asm!("inc {}", inout(reg) x =&gt; z, options(pure)); }
// ERROR: the `pure` option must be combined with either `nomem` or `readonly`
assert_eq!(z, 0);
}
#[cfg(not(target_arch = "x86_64"))] core::compile_error!("Test not supported on this arch");
}</pre> <div class="rule" id="r-asm.options.supported-options.nomem">
<a class="rule-link" href="#r-asm.options.supported-options.nomem" title="asm.options.supported-options.nomem"><span>[asm<wbr>.options<wbr>.supported-options<wbr>.nomem]</wbr></wbr></wbr></span></a> </div> <ul> <li>
<code>nomem</code>: The assembly code does not read from or write to any memory accessible outside of the assembly code. This allows the compiler to cache the values of modified global variables in registers across execution of the assembly code since it knows that they are not read from or written to by it. The compiler also assumes that the assembly code does not perform any kind of synchronization with other threads, e.g. via fences.</li> </ul>  <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
let mut x = 0i32;
let z: i32;
// Accessing outside memory from assembly when `nomem` is
// specified is disallowed
unsafe {
    core::arch::asm!("mov {val:e}, dword ptr [{ptr}]",
        ptr = in(reg) &amp;mut x,
        val = lateout(reg) z,
        options(nomem)
    )
}

// Writing to outside memory from assembly when `nomem` is
// specified is also undefined behaviour
unsafe {
    core::arch::asm!("mov  dword ptr [{ptr}], {val:e}",
        ptr = in(reg) &amp;mut x,
        val = in(reg) z,
        options(nomem)
    )
}
}
}</pre> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
let x: i32 = 0;
let z: i32;
// If we allocate our own memory, such as via `push`, however.
// we can still use it
unsafe {
    core::arch::asm!("push {x}", "add qword ptr [rsp], 1", "pop {x}",
        x = inout(reg) x =&gt; z,
        options(nomem)
    );
}
assert_eq!(z, 1);
}
}</pre> <div class="rule" id="r-asm.options.supported-options.readonly">
<a class="rule-link" href="#r-asm.options.supported-options.readonly" title="asm.options.supported-options.readonly"><span>[asm<wbr>.options<wbr>.supported-options<wbr>.readonly]</wbr></wbr></wbr></span></a> </div> <ul> <li>
<code>readonly</code>: The assembly code does not write to any memory accessible outside of the assembly code. This allows the compiler to cache the values of unmodified global variables in registers across execution of the assembly code since it knows that they are not written to by it. The compiler also assumes that this assembly code does not perform any kind of synchronization with other threads, e.g. via fences.</li> </ul>  <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
let mut x = 0;
// We cannot modify outside memory when `readonly` is specified
unsafe {
    core::arch::asm!("mov dword ptr[{}], 1", in(reg) &amp;mut x, options(readonly))
}
}
}</pre> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
let x: i64 = 0;
let z: i64;
// We can still read from it, though
unsafe {
    core::arch::asm!("mov {x}, qword ptr [{x}]",
        x = inout(reg) &amp;x =&gt; z,
        options(readonly)
    );
}
assert_eq!(z, 0);
}
}</pre> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
let x: i64 = 0;
let z: i64;
// Same exception applies as with nomem.
unsafe {
    core::arch::asm!("push {x}", "add qword ptr [rsp], 1", "pop {x}",
        x = inout(reg) x =&gt; z,
        options(readonly)
    );
}
assert_eq!(z, 1);
}
}</pre> <div class="rule" id="r-asm.options.supported-options.preserves_flags">
<a class="rule-link" href="#r-asm.options.supported-options.preserves_flags" title="asm.options.supported-options.preserves_flags"><span>[asm<wbr>.options<wbr>.supported-options<wbr>.preserves_flags]</wbr></wbr></wbr></span></a> </div> <ul> <li>
<code>preserves_flags</code>: The assembly code does not modify the flags register (defined in the rules below). This allows the compiler to avoid recomputing the condition flags after execution of the assembly code.</li> </ul> <div class="rule" id="r-asm.options.supported-options.noreturn">
<a class="rule-link" href="#r-asm.options.supported-options.noreturn" title="asm.options.supported-options.noreturn"><span>[asm<wbr>.options<wbr>.supported-options<wbr>.noreturn]</wbr></wbr></wbr></span></a> </div> <ul> <li>
<code>noreturn</code>: The assembly code does not fall through; behavior is undefined if it does. It may still jump to <code>label</code> blocks. If any <code>label</code> blocks return unit, the <code>asm!</code> block will return unit. Otherwise it will return <code>!</code> (never). As with a call to a function that does not return, local variables in scope are not dropped before execution of the assembly code.</li> </ul>  <pre data-language="rust">fn main() -&gt; ! {
#[cfg(target_arch = "x86_64")] {
    // We can use an instruction to trap execution inside of a noreturn block
    unsafe { core::arch::asm!("ud2", options(noreturn)); }
}
#[cfg(not(target_arch = "x86_64"))] panic!("no return");
}</pre>  <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
// You are responsible for not falling past the end of a noreturn asm block
unsafe { core::arch::asm!("", options(noreturn)); }
}
}</pre> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")]
let _: () = unsafe {
    // You may still jump to a `label` block
    core::arch::asm!("jmp {}", label {
        println!();
    }, options(noreturn));
};
}</pre> <div class="rule" id="r-asm.options.supported-options.nostack">
<a class="rule-link" href="#r-asm.options.supported-options.nostack" title="asm.options.supported-options.nostack"><span>[asm<wbr>.options<wbr>.supported-options<wbr>.nostack]</wbr></wbr></wbr></span></a> </div> <ul> <li>
<code>nostack</code>: The assembly code does not push data to the stack, or write to the stack red-zone (if supported by the target). If this option is <em>not</em> used then the stack pointer is guaranteed to be suitably aligned (according to the target ABI) for a function call.</li> </ul>  <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
// `push` and `pop` are UB when used with nostack
unsafe { core::arch::asm!("push rax", "pop rax", options(nostack)); }
}
}</pre> <div class="rule" id="r-asm.options.supported-options.att_syntax">
<a class="rule-link" href="#r-asm.options.supported-options.att_syntax" title="asm.options.supported-options.att_syntax"><span>[asm<wbr>.options<wbr>.supported-options<wbr>.att_syntax]</wbr></wbr></wbr></span></a> </div> <ul> <li>
<code>att_syntax</code>: This option is only valid on x86, and causes the assembler to use the <code>.att_syntax prefix</code> mode of the GNU assembler. Register operands are substituted in with a leading <code>%</code>.</li> </ul> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
let x: i32;
let y = 1i32;
// We need to use AT&amp;T Syntax here. src, dest order for operands
unsafe {
    core::arch::asm!("mov {y:e}, {x:e}",
        x = lateout(reg) x,
        y = in(reg) y,
        options(att_syntax)
    );
}
assert_eq!(x, y);
}
}</pre> <div class="rule" id="r-asm.options.supported-options.raw">
<a class="rule-link" href="#r-asm.options.supported-options.raw" title="asm.options.supported-options.raw"><span>[asm<wbr>.options<wbr>.supported-options<wbr>.raw]</wbr></wbr></wbr></span></a> </div> <ul> <li>
<code>raw</code>: This causes the template string to be parsed as a raw assembly string, with no special handling for <code>{</code> and <code>}</code>. This is primarily useful when including raw assembly code from an external file using <code>include_str!</code>.</li> </ul> <div class="rule" id="r-asm.options.checks">
<a class="rule-link" href="#r-asm.options.checks" title="asm.options.checks"><span>[asm<wbr>.options<wbr>.checks]</wbr></wbr></span></a> </div> <p>The compiler performs some additional checks on options:</p> <div class="rule" id="r-asm.options.checks.mutually-exclusive">
<a class="rule-link" href="#r-asm.options.checks.mutually-exclusive" title="asm.options.checks.mutually-exclusive"><span>[asm<wbr>.options<wbr>.checks<wbr>.mutually-exclusive]</wbr></wbr></wbr></span></a> </div> <ul> <li>The <code>nomem</code> and <code>readonly</code> options are mutually exclusive: it is a compile-time error to specify both.</li> </ul> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
// nomem is strictly stronger than readonly, they can't be specified together
unsafe { core::arch::asm!("", options(nomem, readonly)); }
// ERROR: the `nomem` and `readonly` options are mutually exclusive
}
#[cfg(not(target_arch = "x86_64"))] core::compile_error!("Test not supported on this arch");
}</pre> <div class="rule" id="r-asm.options.checks.pure">
<a class="rule-link" href="#r-asm.options.checks.pure" title="asm.options.checks.pure"><span>[asm<wbr>.options<wbr>.checks<wbr>.pure]</wbr></wbr></wbr></span></a> </div> <ul> <li>It is a compile-time error to specify <code>pure</code> on an asm block with no outputs or only discarded outputs (<code>_</code>).</li> </ul> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
// pure blocks need at least one output
unsafe { core::arch::asm!("", options(pure)); }
// ERROR: asm with the `pure` option must have at least one output
}
#[cfg(not(target_arch = "x86_64"))] core::compile_error!("Test not supported on this arch");
}</pre> <div class="rule" id="r-asm.options.checks.noreturn">
<a class="rule-link" href="#r-asm.options.checks.noreturn" title="asm.options.checks.noreturn"><span>[asm<wbr>.options<wbr>.checks<wbr>.noreturn]</wbr></wbr></wbr></span></a> </div> <ul> <li>It is a compile-time error to specify <code>noreturn</code> on an asm block with outputs and without labels.</li> </ul> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
let z: i32;
// noreturn can't have outputs
unsafe { core::arch::asm!("mov {:e}, 1", out(reg) z, options(noreturn)); }
// ERROR: asm outputs are not allowed with the `noreturn` option
}
#[cfg(not(target_arch = "x86_64"))] core::compile_error!("Test not supported on this arch");
}</pre> <div class="rule" id="r-asm.options.checks.label-with-outputs">
<a class="rule-link" href="#r-asm.options.checks.label-with-outputs" title="asm.options.checks.label-with-outputs"><span>[asm<wbr>.options<wbr>.checks<wbr>.label-with-outputs]</wbr></wbr></wbr></span></a> </div> <ul> <li>It is a compile-time error to have any <code>label</code> blocks in an asm block with outputs.</li> </ul> <div class="rule" id="r-asm.options.naked_asm-restriction">
<a class="rule-link" href="#r-asm.options.naked_asm-restriction" title="asm.options.naked_asm-restriction"><span>[asm<wbr>.options<wbr>.naked_asm-restriction]</wbr></wbr></span></a> </div> <p><code>naked_asm!</code> only supports the <code>att_syntax</code> and <code>raw</code> options. The remaining options are not meaningful because the inline assembly defines the whole function body.</p> <div class="rule" id="r-asm.options.global_asm-restriction">
<a class="rule-link" href="#r-asm.options.global_asm-restriction" title="asm.options.global_asm-restriction"><span>[asm<wbr>.options<wbr>.global_asm-restriction]</wbr></wbr></span></a> </div> <p><code>global_asm!</code> only supports the <code>att_syntax</code> and <code>raw</code> options. The remaining options are not meaningful for global-scope inline assembly.</p> <pre data-language="rust">fn main() {}
#[cfg(target_arch = "x86_64")]
// nomem is useless on global_asm!
core::arch::global_asm!("", options(nomem));
#[cfg(not(target_arch = "x86_64"))] core::compile_error!("Test not supported on this arch");</pre> <div class="rule" id="r-asm.rules">
<a class="rule-link" href="#r-asm.rules" title="asm.rules"><span>[asm<wbr>.rules]</wbr></span></a> </div> <h2 id="rules-for-inline-assembly">Rules for inline assembly</h2> <div class="rule" id="r-asm.rules.intro">
<a class="rule-link" href="#r-asm.rules.intro" title="asm.rules.intro"><span>[asm<wbr>.rules<wbr>.intro]</wbr></wbr></span></a> </div> <p>To avoid undefined behavior, these rules must be followed when using function-scope inline assembly (<code>asm!</code>):</p> <div class="rule" id="r-asm.rules.reg-not-input">
<a class="rule-link" href="#r-asm.rules.reg-not-input" title="asm.rules.reg-not-input"><span>[asm<wbr>.rules<wbr>.reg-not-input]</wbr></wbr></span></a> </div> <ul> <li>Any registers not specified as inputs will contain an undefined value on entry to the assembly code. <ul> <li>An “undefined value” in the context of inline assembly means that the register can (non-deterministically) have any one of the possible values allowed by the architecture. Notably it is not the same as an LLVM <code>undef</code> which can have a different value every time you read it (since such a concept does not exist in assembly code).</li> </ul> </li> </ul> <div class="rule" id="r-asm.rules.reg-not-output">
<a class="rule-link" href="#r-asm.rules.reg-not-output" title="asm.rules.reg-not-output"><span>[asm<wbr>.rules<wbr>.reg-not-output]</wbr></wbr></span></a> </div> <ul> <li>Any registers not specified as outputs must have the same value upon exiting the assembly code as they had on entry, otherwise behavior is undefined. <ul> <li>This only applies to registers which can be specified as an input or output. Other registers follow target-specific rules.</li> <li>Note that a <code>lateout</code> may be allocated to the same register as an <code>in</code>, in which case this rule does not apply. Code should not rely on this however since it depends on the results of register allocation.</li> </ul> </li> </ul> <div class="rule" id="r-asm.rules.unwind">
<a class="rule-link" href="#r-asm.rules.unwind" title="asm.rules.unwind"><span>[asm<wbr>.rules<wbr>.unwind]</wbr></wbr></span></a> </div> <ul> <li>Behavior is undefined if execution unwinds out of the assembly code. <ul> <li>This also applies if the assembly code calls a function which then unwinds.</li> </ul> </li> </ul> <div class="rule" id="r-asm.rules.mem-same-as-ffi">
<a class="rule-link" href="#r-asm.rules.mem-same-as-ffi" title="asm.rules.mem-same-as-ffi"><span>[asm<wbr>.rules<wbr>.mem-same-as-ffi]</wbr></wbr></span></a> </div> <ul> <li>The set of memory locations that assembly code is allowed to read and write are the same as those allowed for an FFI function. <ul> <li>If the <code>readonly</code> option is set, then only memory reads are allowed.</li> <li>If the <code>nomem</code> option is set then no reads or writes to memory are allowed.</li> <li>These rules do not apply to memory which is private to the assembly code, such as stack space allocated within it.</li> </ul> </li> </ul> <div class="rule" id="r-asm.rules.black-box">
<a class="rule-link" href="#r-asm.rules.black-box" title="asm.rules.black-box"><span>[asm<wbr>.rules<wbr>.black-box]</wbr></wbr></span></a> </div> <ul> <li>The compiler cannot assume that the instructions in the assembly code are the ones that will actually end up executed. <ul> <li>This effectively means that the compiler must treat the assembly code as a black box and only take the interface specification into account, not the instructions themselves.</li> <li>Runtime code patching is allowed, via target-specific mechanisms.</li> <li>However there is no guarantee that each block of assembly code in the source directly corresponds to a single instance of instructions in the object file; the compiler is free to duplicate or deduplicate the assembly code in <code>asm!</code> blocks.</li> </ul> </li> </ul> <div class="rule" id="r-asm.rules.stack-below-sp">
<a class="rule-link" href="#r-asm.rules.stack-below-sp" title="asm.rules.stack-below-sp"><span>[asm<wbr>.rules<wbr>.stack-below-sp]</wbr></wbr></span></a> </div> <ul> <li>Unless the <code>nostack</code> option is set, assembly code is allowed to use stack space below the stack pointer. <ul> <li>On entry to the assembly code the stack pointer is guaranteed to be suitably aligned (according to the target ABI) for a function call.</li> <li>You are responsible for making sure you don’t overflow the stack (e.g. use stack probing to ensure you hit a guard page).</li> <li>You should adjust the stack pointer when allocating stack memory as required by the target ABI.</li> <li>The stack pointer must be restored to its original value before leaving the assembly code.</li> </ul> </li> </ul> <div class="rule" id="r-asm.rules.noreturn">
<a class="rule-link" href="#r-asm.rules.noreturn" title="asm.rules.noreturn"><span>[asm<wbr>.rules<wbr>.noreturn]</wbr></wbr></span></a> </div> <ul> <li>If the <code>noreturn</code> option is set then behavior is undefined if execution falls through the end of the assembly code.</li> </ul> <div class="rule" id="r-asm.rules.pure">
<a class="rule-link" href="#r-asm.rules.pure" title="asm.rules.pure"><span>[asm<wbr>.rules<wbr>.pure]</wbr></wbr></span></a> </div> <ul> <li>If the <code>pure</code> option is set then behavior is undefined if the <code>asm!</code> has side-effects other than its direct outputs. Behavior is also undefined if two executions of the <code>asm!</code> code with the same inputs result in different outputs. <ul> <li>When used with the <code>nomem</code> option, “inputs” are just the direct inputs of the <code>asm!</code>.</li> <li>When used with the <code>readonly</code> option, “inputs” comprise the direct inputs of the assembly code and any memory that it is allowed to read.</li> </ul> </li> </ul> <div class="rule" id="r-asm.rules.preserved-registers">
<a class="rule-link" href="#r-asm.rules.preserved-registers" title="asm.rules.preserved-registers"><span>[asm<wbr>.rules<wbr>.preserved-registers]</wbr></wbr></span></a> </div> <ul> <li>These flags registers must be restored upon exiting the assembly code if the <code>preserves_flags</code> option is set: <ul> <li>x86 <ul> <li>Status flags in <code>EFLAGS</code> (CF, PF, AF, ZF, SF, OF).</li> <li>Floating-point status word (all).</li> <li>Floating-point exception flags in <code>MXCSR</code> (PE, UE, OE, ZE, DE, IE).</li> </ul> </li> <li>ARM <ul> <li>Condition flags in <code>CPSR</code> (N, Z, C, V)</li> <li>Saturation flag in <code>CPSR</code> (Q)</li> <li>Greater than or equal flags in <code>CPSR</code> (GE).</li> <li>Condition flags in <code>FPSCR</code> (N, Z, C, V)</li> <li>Saturation flag in <code>FPSCR</code> (QC)</li> <li>Floating-point exception flags in <code>FPSCR</code> (IDC, IXC, UFC, OFC, DZC, IOC).</li> </ul> </li> <li>AArch64 and Arm64EC <ul> <li>Condition flags (<code>NZCV</code> register).</li> <li>Floating-point status (<code>FPSR</code> register).</li> </ul> </li> <li>RISC-V <ul> <li>Floating-point exception flags in <code>fcsr</code> (<code>fflags</code>).</li> <li>Vector extension state (<code>vtype</code>, <code>vl</code>, <code>vcsr</code>).</li> </ul> </li> <li>LoongArch <ul> <li>Floating-point condition flags in <code>$fcc[0-7]</code>.</li> </ul> </li> <li>s390x <ul> <li>The condition code register <code>cc</code>.</li> </ul> </li> </ul> </li> </ul> <div class="rule" id="r-asm.rules.x86-df">
<a class="rule-link" href="#r-asm.rules.x86-df" title="asm.rules.x86-df"><span>[asm<wbr>.rules<wbr>.x86-df]</wbr></wbr></span></a> </div> <ul> <li>On x86, the direction flag (DF in <code>EFLAGS</code>) is clear on entry to the assembly code and must be clear on exit. <ul> <li>Behavior is undefined if the direction flag is set on exiting the assembly code.</li> </ul> </li> </ul> <div class="rule" id="r-asm.rules.x86-x87">
<a class="rule-link" href="#r-asm.rules.x86-x87" title="asm.rules.x86-x87"><span>[asm<wbr>.rules<wbr>.x86-x87]</wbr></wbr></span></a> </div> <ul> <li>On x86, the x87 floating-point register stack must remain unchanged unless all of the <code>st([0-7])</code> registers have been marked as clobbered with <code>out("st(0)") _, out("st(1)") _, ...</code>. <ul> <li>If all x87 registers are clobbered then the x87 register stack is guaranteed to be empty upon entering the assembly code. Assembly code must ensure that the x87 register stack is also empty when exiting the asssembly code.</li> </ul> </li> </ul> <pre data-language="rust">#[cfg(target_arch = "x86_64")]
pub fn fadd(x: f64, y: f64) -&gt; f64 {
  let mut out = 0f64;
  let mut top = 0u16;
  // we can do complex stuff with x87 if we clobber the entire x87 stack
  unsafe { core::arch::asm!(
    "fld qword ptr [{x}]",
    "fld qword ptr [{y}])",
    "faddp",
    "fstp qword ptr [{out}]",
    "xor eax, eax",
    "fstsw ax",
    "shl eax, 11",
    x = in(reg) &amp;x,
    y = in(reg) &amp;y,
    out = in(reg) &amp;mut out,
    out("st(0)") _, out("st(1)") _, out("st(2)") _, out("st(3)") _,
    out("st(4)") _, out("st(5)") _, out("st(6)") _, out("st(7)") _,
    out("eax") top
  );}

  assert_eq!(top &amp; 0x7, 0);
  out
}

pub fn main() {
#[cfg(target_arch = "x86_64")]{
  assert_eq!(fadd(1.0, 1.0), 2.0);
}
}</pre> <div class="rule" id="r-asm.rules.arm64ec">
<a class="rule-link" href="#r-asm.rules.arm64ec" title="asm.rules.arm64ec"><span>[asm<wbr>.rules<wbr>.arm64ec]</wbr></wbr></span></a> </div> <ul> <li>On arm64ec, <a href="https://learn.microsoft.com/en-us/windows/arm/arm64ec-abi#authoring-arm64ec-in-assembly">call checkers with appropriate thunks</a> are mandatory when calling functions.</li> </ul> <div class="rule" id="r-asm.rules.only-on-exit">
<a class="rule-link" href="#r-asm.rules.only-on-exit" title="asm.rules.only-on-exit"><span>[asm<wbr>.rules<wbr>.only-on-exit]</wbr></wbr></span></a> </div> <ul> <li>The requirement of restoring the stack pointer and non-output registers to their original value only applies when exiting the assembly code. <ul> <li>This means that assembly code that does not fall through and does not jump to any <code>label</code> blocks, even if not marked <code>noreturn</code>, doesn’t need to preserve these registers.</li> <li>When returning to the assembly code of a different <code>asm!</code> block than you entered (e.g. for context switching), these registers must contain the value they had upon entering the <code>asm!</code> block that you are <em>exiting</em>. <ul> <li>You cannot exit the assembly code of an <code>asm!</code> block that has not been entered. Neither can you exit the assembly code of an <code>asm!</code> block whose assembly code has already been exited (without first entering it again).</li> <li>You are responsible for switching any target-specific state (e.g. thread-local storage, stack bounds).</li> <li>You cannot jump from an address in one <code>asm!</code> block to an address in another, even within the same function or block, without treating their contexts as potentially different and requiring context switching. You cannot assume that any particular value in those contexts (e.g. current stack pointer or temporary values below the stack pointer) will remain unchanged between the two <code>asm!</code> blocks.</li> <li>The set of memory locations that you may access is the intersection of those allowed by the <code>asm!</code> blocks you entered and exited.</li> </ul> </li> </ul> </li> </ul> <div class="rule" id="r-asm.rules.not-successive">
<a class="rule-link" href="#r-asm.rules.not-successive" title="asm.rules.not-successive"><span>[asm<wbr>.rules<wbr>.not-successive]</wbr></wbr></span></a> </div> <ul> <li>You cannot assume that two <code>asm!</code> blocks adjacent in source code, even without any other code between them, will end up in successive addresses in the binary without any other instructions between them.</li> </ul> <div class="rule" id="r-asm.rules.not-exactly-once">
<a class="rule-link" href="#r-asm.rules.not-exactly-once" title="asm.rules.not-exactly-once"><span>[asm<wbr>.rules<wbr>.not-exactly-once]</wbr></wbr></span></a> </div> <ul> <li>You cannot assume that an <code>asm!</code> block will appear exactly once in the output binary. The compiler is allowed to instantiate multiple copies of the <code>asm!</code> block, for example when the function containing it is inlined in multiple places.</li> </ul> <div class="rule" id="r-asm.rules.x86-prefix-restriction">
<a class="rule-link" href="#r-asm.rules.x86-prefix-restriction" title="asm.rules.x86-prefix-restriction"><span>[asm<wbr>.rules<wbr>.x86-prefix-restriction]</wbr></wbr></span></a> </div> <ul> <li>On x86, inline assembly must not end with an instruction prefix (such as <code>LOCK</code>) that would apply to instructions generated by the compiler. <ul> <li>The compiler is currently unable to detect this due to the way inline assembly is compiled, but may catch and reject this in the future.</li> </ul> </li> </ul> <div class="rule" id="r-asm.rules.preserves_flags">
<a class="rule-link" href="#r-asm.rules.preserves_flags" title="asm.rules.preserves_flags"><span>[asm<wbr>.rules<wbr>.preserves_flags]</wbr></wbr></span></a> </div> <div class="alert alert-note"> <blockquote> <p class="alert-title">Note</p> <p>As a general rule, the flags covered by <code>preserves_flags</code> are those which are <em>not</em> preserved when performing a function call.</p> </blockquote> </div> <div class="rule" id="r-asm.naked-rules">
<a class="rule-link" href="#r-asm.naked-rules" title="asm.naked-rules"><span>[asm<wbr>.naked-rules]</wbr></span></a> </div> <h2 id="rules-for-naked-inline-assembly">Rules for naked inline assembly</h2> <div class="rule" id="r-asm.naked-rules.intro">
<a class="rule-link" href="#r-asm.naked-rules.intro" title="asm.naked-rules.intro"><span>[asm<wbr>.naked-rules<wbr>.intro]</wbr></wbr></span></a> </div> <p>To avoid undefined behavior, these rules must be followed when using function-scope inline assembly in naked functions (<code>naked_asm!</code>):</p> <div class="rule" id="r-asm.naked-rules.reg-not-input">
<a class="rule-link" href="#r-asm.naked-rules.reg-not-input" title="asm.naked-rules.reg-not-input"><span>[asm<wbr>.naked-rules<wbr>.reg-not-input]</wbr></wbr></span></a> </div> <ul> <li>Any registers not used for function inputs according to the calling convention and function signature will contain an undefined value on entry to the <code>naked_asm!</code> block. <ul> <li>An “undefined value” in the context of inline assembly means that the register can (non-deterministically) have any one of the possible values allowed by the architecture. Notably it is not the same as an LLVM <code>undef</code> which can have a different value every time you read it (since such a concept does not exist in assembly code).</li> </ul> </li> </ul> <div class="rule" id="r-asm.naked-rules.callee-saved-registers">
<a class="rule-link" href="#r-asm.naked-rules.callee-saved-registers" title="asm.naked-rules.callee-saved-registers"><span>[asm<wbr>.naked-rules<wbr>.callee-saved-registers]</wbr></wbr></span></a> </div> <ul> <li>All callee-saved registers must have the same value upon return as they had on entry.</li> </ul> <div class="rule" id="r-asm.naked-rules.caller-saved-registers">
<a class="rule-link" href="#r-asm.naked-rules.caller-saved-registers" title="asm.naked-rules.caller-saved-registers"><span>[asm<wbr>.naked-rules<wbr>.caller-saved-registers]</wbr></wbr></span></a> </div> <ul> <li>Caller-saved registers may be used freely.</li> </ul> <div class="rule" id="r-asm.naked-rules.noreturn">
<a class="rule-link" href="#r-asm.naked-rules.noreturn" title="asm.naked-rules.noreturn"><span>[asm<wbr>.naked-rules<wbr>.noreturn]</wbr></wbr></span></a> </div> <ul> <li>Behavior is undefined if execution falls through past the end of the assembly code. <ul> <li>Every path through the assembly code is expected to terminate with a return instruction or to diverge.</li> </ul> </li> </ul> <div class="rule" id="r-asm.naked-rules.mem-same-as-ffi">
<a class="rule-link" href="#r-asm.naked-rules.mem-same-as-ffi" title="asm.naked-rules.mem-same-as-ffi"><span>[asm<wbr>.naked-rules<wbr>.mem-same-as-ffi]</wbr></wbr></span></a> </div> <ul> <li>The set of memory locations that assembly code is allowed to read and write are the same as those allowed for an FFI function.</li> </ul> <div class="rule" id="r-asm.naked-rules.black-box">
<a class="rule-link" href="#r-asm.naked-rules.black-box" title="asm.naked-rules.black-box"><span>[asm<wbr>.naked-rules<wbr>.black-box]</wbr></wbr></span></a> </div> <ul> <li>The compiler cannot assume that the instructions in the <code>naked_asm!</code> block are the ones that will actually be executed. <ul> <li>This effectively means that the compiler must treat the <code>naked_asm!</code> as a black box and only take the interface specification into account, not the instructions themselves.</li> <li>Runtime code patching is allowed, via target-specific mechanisms.</li> </ul> </li> </ul> <div class="rule" id="r-asm.naked-rules.unwind">
<a class="rule-link" href="#r-asm.naked-rules.unwind" title="asm.naked-rules.unwind"><span>[asm<wbr>.naked-rules<wbr>.unwind]</wbr></wbr></span></a> </div> <ul> <li>Unwinding out of a <code>naked_asm!</code> block is allowed. <ul> <li>For correct behavior, the appropriate assembler directives that emit unwinding metadata must be used.</li> </ul> </li> </ul> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
#[unsafe(naked)]
extern "sysv64-unwind" fn unwinding_naked() {
    core::arch::naked_asm!(
        // "CFI" here stands for "call frame information".
        ".cfi_startproc",
        // The CFA (canonical frame address) is the value of `rsp`
        // before the `call`, i.e. before the return address, `rip`,
        // was pushed to `rsp`, so it's eight bytes higher in memory
        // than `rsp` upon function entry (after `rip` has been
        // pushed).
        //
        // This is the default, so we don't have to write it.
        //".cfi_def_cfa rsp, 8",
        //
        // The traditional thing to do is to preserve the base
        // pointer, so we'll do that.
        "push rbp",
        // Since we've now extended the stack downward by 8 bytes in
        // memory, we need to adjust the offset to the CFA from `rsp`
        // by another 8 bytes.
        ".cfi_adjust_cfa_offset 8",
        // We also then annotate where we've stored the caller's value
        // of `rbp`, relative to the CFA, so that when unwinding into
        // the caller we can find it, in case we need it to calculate
        // the caller's CFA relative to it.
        //
        // Here, we've stored the caller's `rbp` starting 16 bytes
        // below the CFA.  I.e., starting from the CFA, there's first
        // the `rip` (which starts 8 bytes below the CFA and continues
        // up to it), then there's the caller's `rbp` that we just
        // pushed.
        ".cfi_offset rbp, -16",
        // As is traditional, we set the base pointer to the value of
        // the stack pointer.  This way, the base pointer stays the
        // same throughout the function body.
        "mov rbp, rsp",
        // We can now track the offset to the CFA from the base
        // pointer.  This means we don't need to make any further
        // adjustments until the end, as we don't change `rbp`.
        ".cfi_def_cfa_register rbp",
        // We can now call a function that may panic.
        "call {f}",
        // Upon return, we restore `rbp` in preparation for returning
        // ourselves.
        "pop rbp",
        // Now that we've restored `rbp`, we must specify the offset
        // to the CFA again in terms of `rsp`.
        ".cfi_def_cfa rsp, 8",
        // Now we can return.
        "ret",
        ".cfi_endproc",
        f = sym may_panic,
    )
}

extern "sysv64-unwind" fn may_panic() {
    panic!("unwind");
}
}
}</pre> <div class="alert alert-note"> <blockquote> <p class="alert-title">Note</p> <p>For more information on the <code>cfi</code> assembler directives above, see these resources:</p> <ul> <li><a href="https://sourceware.org/binutils/docs/as/CFI-directives.html">Using <code>as</code> - CFI directives</a></li> <li><a href="https://dwarfstd.org/doc/DWARF5.pdf">DWARF Debugging Information Format Version 5</a></li> <li><a href="https://www.imperialviolet.org/2017/01/18/cfi.html">ImperialViolet - CFI directives in assembly files</a></li> </ul> </blockquote> </div> <div class="rule" id="r-asm.validity">
<a class="rule-link" href="#r-asm.validity" title="asm.validity"><span>[asm<wbr>.validity]</wbr></span></a> </div> <h3 id="correctness-and-validity">Correctness and Validity</h3> <div class="rule" id="r-asm.validity.necessary-but-not-sufficient">
<a class="rule-link" href="#r-asm.validity.necessary-but-not-sufficient" title="asm.validity.necessary-but-not-sufficient"><span>[asm<wbr>.validity<wbr>.necessary-but-not-sufficient]</wbr></wbr></span></a> </div> <p>In addition to all of the previous rules, the string argument to <code>asm!</code> must ultimately become— after all other arguments are evaluated, formatting is performed, and operands are translated— assembly that is both syntactically correct and semantically valid for the target architecture. The formatting rules allow the compiler to generate assembly with correct syntax. Rules concerning operands permit valid translation of Rust operands into and out of the assembly code. Adherence to these rules is necessary, but not sufficient, for the final expanded assembly to be both correct and valid. For instance:</p> <ul> <li>arguments may be placed in positions which are syntactically incorrect after formatting</li> <li>an instruction may be correctly written, but given architecturally invalid operands</li> <li>an architecturally unspecified instruction may be assembled into unspecified code</li> <li>a set of instructions, each correct and valid, may cause undefined behavior if placed in immediate succession</li> </ul> <div class="rule" id="r-asm.validity.non-exhaustive">
<a class="rule-link" href="#r-asm.validity.non-exhaustive" title="asm.validity.non-exhaustive"><span>[asm<wbr>.validity<wbr>.non-exhaustive]</wbr></wbr></span></a> </div> <p>As a result, these rules are <em>non-exhaustive</em>. The compiler is not required to check the correctness and validity of the initial string nor the final assembly that is generated. The assembler may check for correctness and validity but is not required to do so. When using <code>asm!</code>, a typographical error may be sufficient to make a program unsound, and the rules for assembly may include thousands of pages of architectural reference manuals. Programmers should exercise appropriate care, as invoking this <code>unsafe</code> capability comes with assuming the responsibility of not violating rules of both the compiler or the architecture.</p> <div class="rule" id="r-asm.directives">
<a class="rule-link" href="#r-asm.directives" title="asm.directives"><span>[asm<wbr>.directives]</wbr></span></a> </div> <h3 id="directives-support">Directives Support</h3> <div class="rule" id="r-asm.directives.subset-supported">
<a class="rule-link" href="#r-asm.directives.subset-supported" title="asm.directives.subset-supported"><span>[asm<wbr>.directives<wbr>.subset-supported]</wbr></wbr></span></a> </div> <p>Inline assembly supports a subset of the directives supported by both GNU AS and LLVM’s internal assembler, given as follows. The result of using other directives is assembler-specific (and may cause an error, or may be accepted as-is).</p> <div class="rule" id="r-asm.directives.stateful">
<a class="rule-link" href="#r-asm.directives.stateful" title="asm.directives.stateful"><span>[asm<wbr>.directives<wbr>.stateful]</wbr></wbr></span></a> </div> <p>If inline assembly includes any “stateful” directive that modifies how subsequent assembly is processed, the assembly code must undo the effects of any such directives before the inline assembly ends.</p> <div class="rule" id="r-asm.directives.supported-directives">
<a class="rule-link" href="#r-asm.directives.supported-directives" title="asm.directives.supported-directives"><span>[asm<wbr>.directives<wbr>.supported-directives]</wbr></wbr></span></a> </div> <p>The following directives are guaranteed to be supported by the assembler:</p> <ul> <li><code>.2byte</code></li> <li><code>.4byte</code></li> <li><code>.8byte</code></li> <li><code>.align</code></li> <li><code>.alt_entry</code></li> <li><code>.ascii</code></li> <li><code>.asciz</code></li> <li><code>.balign</code></li> <li><code>.balignl</code></li> <li><code>.balignw</code></li> <li><code>.bss</code></li> <li><code>.byte</code></li> <li><code>.comm</code></li> <li><code>.data</code></li> <li><code>.def</code></li> <li><code>.double</code></li> <li><code>.endef</code></li> <li><code>.equ</code></li> <li><code>.equiv</code></li> <li><code>.eqv</code></li> <li><code>.fill</code></li> <li><code>.float</code></li> <li><code>.global</code></li> <li><code>.globl</code></li> <li><code>.inst</code></li> <li><code>.insn</code></li> <li><code>.lcomm</code></li> <li><code>.long</code></li> <li><code>.octa</code></li> <li><code>.option</code></li> <li><code>.p2align</code></li> <li><code>.popsection</code></li> <li><code>.private_extern</code></li> <li><code>.pushsection</code></li> <li><code>.quad</code></li> <li><code>.scl</code></li> <li><code>.section</code></li> <li><code>.set</code></li> <li><code>.short</code></li> <li><code>.size</code></li> <li><code>.skip</code></li> <li><code>.sleb128</code></li> <li><code>.space</code></li> <li><code>.string</code></li> <li><code>.text</code></li> <li><code>.type</code></li> <li><code>.uleb128</code></li> <li><code>.word</code></li> </ul> <pre data-language="rust">#![allow(unused)]
fn main() {
#[cfg(target_arch = "x86_64")] {
let bytes: *const u8;
let len: usize;
unsafe {
    core::arch::asm!(
        "jmp 3f", "2: .ascii \"Hello World!\"",
        "3: lea {bytes}, [2b+rip]",
        "mov {len}, 12",
        bytes = out(reg) bytes,
        len = out(reg) len
    );
}

let s = unsafe { core::str::from_utf8_unchecked(core::slice::from_raw_parts(bytes, len)) };

assert_eq!(s, "Hello World!");
}
}</pre> <div class="rule" id="r-asm.target-specific-directives">
<a class="rule-link" href="#r-asm.target-specific-directives" title="asm.target-specific-directives"><span>[asm<wbr>.target-specific-directives]</wbr></span></a> </div> <h4 id="target-specific-directive-support">Target Specific Directive Support</h4> <div class="rule" id="r-asm.target-specific-directives.dwarf-unwinding">
<a class="rule-link" href="#r-asm.target-specific-directives.dwarf-unwinding" title="asm.target-specific-directives.dwarf-unwinding"><span>[asm<wbr>.target-specific-directives<wbr>.dwarf-unwinding]</wbr></wbr></span></a> </div> <h5 id="dwarf-unwinding">Dwarf Unwinding</h5> <p>The following directives are supported on ELF targets that support DWARF unwind info:</p> <ul> <li><code>.cfi_adjust_cfa_offset</code></li> <li><code>.cfi_def_cfa</code></li> <li><code>.cfi_def_cfa_offset</code></li> <li><code>.cfi_def_cfa_register</code></li> <li><code>.cfi_endproc</code></li> <li><code>.cfi_escape</code></li> <li><code>.cfi_lsda</code></li> <li><code>.cfi_offset</code></li> <li><code>.cfi_personality</code></li> <li><code>.cfi_register</code></li> <li><code>.cfi_rel_offset</code></li> <li><code>.cfi_remember_state</code></li> <li><code>.cfi_restore</code></li> <li><code>.cfi_restore_state</code></li> <li><code>.cfi_return_column</code></li> <li><code>.cfi_same_value</code></li> <li><code>.cfi_sections</code></li> <li><code>.cfi_signal_frame</code></li> <li><code>.cfi_startproc</code></li> <li><code>.cfi_undefined</code></li> <li><code>.cfi_window_save</code></li> </ul> <div class="rule" id="r-asm.target-specific-directives.structured-exception-handling">
<a class="rule-link" href="#r-asm.target-specific-directives.structured-exception-handling" title="asm.target-specific-directives.structured-exception-handling"><span>[asm<wbr>.target-specific-directives<wbr>.structured-exception-handling]</wbr></wbr></span></a> </div> <h5 id="structured-exception-handling">Structured Exception Handling</h5> <p>On targets with structured exception Handling, the following additional directives are guaranteed to be supported:</p> <ul> <li><code>.seh_endproc</code></li> <li><code>.seh_endprologue</code></li> <li><code>.seh_proc</code></li> <li><code>.seh_pushreg</code></li> <li><code>.seh_savereg</code></li> <li><code>.seh_setframe</code></li> <li><code>.seh_stackalloc</code></li> </ul> <div class="rule" id="r-asm.target-specific-directives.x86">
<a class="rule-link" href="#r-asm.target-specific-directives.x86" title="asm.target-specific-directives.x86"><span>[asm<wbr>.target-specific-directives<wbr>.x86]</wbr></wbr></span></a> </div> <h5 id="x86-32-bit-and-64-bit">x86 (32-bit and 64-bit)</h5> <p>On x86 targets, both 32-bit and 64-bit, the following additional directives are guaranteed to be supported:</p> <ul> <li><code>.nops</code></li> <li><code>.code16</code></li> <li><code>.code32</code></li> <li><code>.code64</code></li> </ul> <p>Use of <code>.code16</code>, <code>.code32</code>, and <code>.code64</code> directives are only supported if the state is reset to the default before exiting the assembly code. 32-bit x86 uses <code>.code32</code> by default, and x86_64 uses <code>.code64</code> by default.</p> <div class="rule" id="r-asm.target-specific-directives.arm-32-bit">
<a class="rule-link" href="#r-asm.target-specific-directives.arm-32-bit" title="asm.target-specific-directives.arm-32-bit"><span>[asm<wbr>.target-specific-directives<wbr>.arm-32-bit]</wbr></wbr></span></a> </div> <h5 id="arm-32-bit">ARM (32-bit)</h5> <p>On ARM, the following additional directives are guaranteed to be supported:</p> <ul> <li><code>.even</code></li> <li><code>.fnstart</code></li> <li><code>.fnend</code></li> <li><code>.save</code></li> <li><code>.movsp</code></li> <li><code>.code</code></li> <li><code>.thumb</code></li> <li><code>.thumb_func</code></li> </ul><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/reference/inline-assembly.html" class="_attribution-link">https://doc.rust-lang.org/reference/inline-assembly.html</a>
  </p>
</div>
</div>
            </main>
        </div>
    </div>
    <script type="text/javascript" src="../assets/index.js"></script>
</body>

</html>