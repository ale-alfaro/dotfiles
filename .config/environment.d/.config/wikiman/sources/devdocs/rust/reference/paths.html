<html class="_theme-default">
<head>
    <meta charset="utf-8">
    <title>.. Types of paths</title>
    
    <link rel="preload" href="../assets/index.js" as="script" type="text/javascript" />

    <link rel="stylesheet" type="text/css" href="../application.css" />
    <link rel="stylesheet" type="text/css" href="../assets/index.css" />
</head>
<body>
    <div class="_app">
        <devdocs-navbar current="reference/paths" prefix="../" listing-src="../navbar.json"></devdocs-navbar>
        <div class="_container">
            <main class="_content">
                <div class="_page _rust"><h1 class="rule" id="r-paths">
<a class="rule-link" href="#r-paths" title="paths"><span>[paths]</span></a> </h1> <h1 id="paths">Paths</h1> <div class="rule" id="r-paths.intro">
<a class="rule-link" href="#r-paths.intro" title="paths.intro"><span>[paths<wbr>.intro]</wbr></span></a> </div> <p>A <em>path</em> is a sequence of one or more path segments separated by <code>::</code> tokens. Paths are used to refer to <a href="items">items</a>, values, <a href="types">types</a>, <a href="macros">macros</a>, and <a href="attributes">attributes</a>.</p> <p>Two examples of simple paths consisting of only identifier segments:</p>  <pre data-language="rust">x;
x::y::z;</pre> <h2 id="types-of-paths">Types of paths</h2> <div class="rule" id="r-paths.simple">
<a class="rule-link" href="#r-paths.simple" title="paths.simple"><span>[paths<wbr>.simple]</wbr></span></a> </div> <h3 id="simple-paths">Simple Paths</h3> <div class="rule" id="r-paths.simple.syntax">
<a class="rule-link" href="#r-paths.simple.syntax" title="paths.simple.syntax"><span>[paths<wbr>.simple<wbr>.syntax]</wbr></wbr></span></a> </div> <div class="grammar-container"> <p><strong><sup>Syntax</sup></strong> <br> <span class="grammar-text grammar-production" id="grammar-SimplePath" onclick="show_railroad()"><a href="paths#railroad-SimplePath">SimplePath</a></span> → <br> <span class="grammar-literal">::</span><sup>?</sup> <span class="grammar-text"><a href="paths#grammar-SimplePathSegment">SimplePathSegment</a></span> ( <span class="grammar-literal">::</span> <span class="grammar-text"><a href="paths#grammar-SimplePathSegment">SimplePathSegment</a></span> )<sup>*</sup></p> <p><span class="grammar-text grammar-production" id="grammar-SimplePathSegment" onclick="show_railroad()"><a href="paths#railroad-SimplePathSegment">SimplePathSegment</a></span> → <br> <span class="grammar-text"><a href="identifiers#grammar-IDENTIFIER">IDENTIFIER</a></span> | <span class="grammar-literal">super</span> | <span class="grammar-literal">self</span> | <span class="grammar-literal">crate</span> | <span class="grammar-literal">$crate</span></p> <p><button class="grammar-toggle-railroad" type="button" title="Toggle railroad display" onclick="toggle_railroad()">Show Railroad</button></p> </div> <div class="grammar-railroad grammar-hidden"> <div style="width: 604px; height: auto; max-width: 100%; max-height: 100%" class="railroad-production" id="railroad-SimplePath">
<svg class="railroad" viewbox="0 0 604 100" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">  <g class="verticalgrid"> <a class="link" xlink:href="paths.html#grammar-SimplePath"> <text class="comment" x="50" y="25"> SimplePath</text> </a> <g class="sequence">  <g class="sequence"> <g class="optional">  <g class="terminal">  <text x="77" y="71"> ::</text> </g> </g> <a class="link" xlink:href="paths.html#railroad-SimplePathSegment"> <g class="nonterminal">  <text x="207" y="71"> SimplePathSegment</text> </g> </a> <g class="optional">  <g class="repeat">   <g class="sequence"> <g class="terminal">  <text x="349" y="71"> ::</text> </g> <a class="link" xlink:href="paths.html#railroad-SimplePathSegment"> <g class="nonterminal">  <text x="455" y="71"> SimplePathSegment</text> </g> </a>  </g> </g> </g>   </g>    </g> </g> </svg> </div> <div style="width: 218px; height: auto; max-width: 100%; max-height: 100%" class="railroad-production" id="railroad-SimplePathSegment">
<svg class="railroad" viewbox="0 0 218 206" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">  <g class="verticalgrid"> <a class="link" xlink:href="paths.html#grammar-SimplePathSegment"> <text class="comment" x="74" y="25"> SimplePathSegment</text> </a> <g class="sequence">  <g class="choice">  <g class="sequence"> <a class="link" xlink:href="identifiers.html#railroad-IDENTIFIER"> <g class="nonterminal">  <text x="109" y="58"> IDENTIFIER</text> </g> </a> </g>      <g class="terminal">  <text x="89" y="91"> super</text> </g>  <g class="terminal">  <text x="85" y="124"> self</text> </g>  <g class="terminal">  <text x="89" y="157"> crate</text> </g>  <g class="terminal">  <text x="93" y="190"> $crate</text> </g> </g>    </g> </g> </svg> </div> </div> <div class="rule" id="r-paths.simple.intro">
<a class="rule-link" href="#r-paths.simple.intro" title="paths.simple.intro"><span>[paths<wbr>.simple<wbr>.intro]</wbr></wbr></span></a> </div> <p>Simple paths are used in <a href="visibility-and-privacy">visibility</a> markers, <a href="attributes">attributes</a>, <a href="macros-by-example">macros</a>, and <a href="items/use-declarations"><code>use</code></a> items. For example:</p> <pre data-language="rust">#![allow(unused)]
fn main() {
use std::io::{self, Write};
mod m {
    #[clippy::cyclomatic_complexity = "0"]
    pub (in super) fn f1() {}
}
}</pre> <div class="rule" id="r-paths.expr">
<a class="rule-link" href="#r-paths.expr" title="paths.expr"><span>[paths<wbr>.expr]</wbr></span></a> </div> <h3 id="paths-in-expressions">Paths in expressions</h3> <div class="rule" id="r-paths.expr.syntax">
<a class="rule-link" href="#r-paths.expr.syntax" title="paths.expr.syntax"><span>[paths<wbr>.expr<wbr>.syntax]</wbr></wbr></span></a> </div> <div class="grammar-container"> <p><strong><sup>Syntax</sup></strong> <br> <span class="grammar-text grammar-production" id="grammar-PathInExpression" onclick="show_railroad()"><a href="paths#railroad-PathInExpression">PathInExpression</a></span> → <br> <span class="grammar-literal">::</span><sup>?</sup> <span class="grammar-text"><a href="paths#grammar-PathExprSegment">PathExprSegment</a></span> ( <span class="grammar-literal">::</span> <span class="grammar-text"><a href="paths#grammar-PathExprSegment">PathExprSegment</a></span> )<sup>*</sup></p> <p><span class="grammar-text grammar-production" id="grammar-PathExprSegment" onclick="show_railroad()"><a href="paths#railroad-PathExprSegment">PathExprSegment</a></span> → <br> <span class="grammar-text"><a href="paths#grammar-PathIdentSegment">PathIdentSegment</a></span> ( <span class="grammar-literal">::</span> <span class="grammar-text"><a href="paths#grammar-GenericArgs">GenericArgs</a></span> )<sup>?</sup></p> <p><span class="grammar-text grammar-production" id="grammar-PathIdentSegment" onclick="show_railroad()"><a href="paths#railroad-PathIdentSegment">PathIdentSegment</a></span> → <br> <span class="grammar-text"><a href="identifiers#grammar-IDENTIFIER">IDENTIFIER</a></span> | <span class="grammar-literal">super</span> | <span class="grammar-literal">self</span> | <span class="grammar-literal">Self</span> | <span class="grammar-literal">crate</span> | <span class="grammar-literal">$crate</span></p> <p><span class="grammar-text grammar-production" id="grammar-GenericArgs" onclick="show_railroad()"><a href="paths#railroad-GenericArgs">GenericArgs</a></span> → <br> <span class="grammar-literal">&lt;</span> <span class="grammar-literal">&gt;</span> <br> | <span class="grammar-literal">&lt;</span> ( <span class="grammar-text"><a href="paths#grammar-GenericArg">GenericArg</a></span> <span class="grammar-literal">,</span> )<sup>*</sup> <span class="grammar-text"><a href="paths#grammar-GenericArg">GenericArg</a></span> <span class="grammar-literal">,</span><sup>?</sup> <span class="grammar-literal">&gt;</span></p> <p><span class="grammar-text grammar-production" id="grammar-GenericArg" onclick="show_railroad()"><a href="paths#railroad-GenericArg">GenericArg</a></span> → <br> <span class="grammar-text"><a href="trait-bounds#grammar-Lifetime">Lifetime</a></span> | <span class="grammar-text"><a href="types#grammar-Type">Type</a></span> | <span class="grammar-text"><a href="paths#grammar-GenericArgsConst">GenericArgsConst</a></span> | <span class="grammar-text"><a href="paths#grammar-GenericArgsBinding">GenericArgsBinding</a></span> | <span class="grammar-text"><a href="paths#grammar-GenericArgsBounds">GenericArgsBounds</a></span></p> <p><span class="grammar-text grammar-production" id="grammar-GenericArgsConst" onclick="show_railroad()"><a href="paths#railroad-GenericArgsConst">GenericArgsConst</a></span> → <br> <span class="grammar-text"><a href="expressions/block-expr#grammar-BlockExpression">BlockExpression</a></span> <br> | <span class="grammar-text"><a href="expressions/literal-expr#grammar-LiteralExpression">LiteralExpression</a></span> <br> | <span class="grammar-literal">-</span> <span class="grammar-text"><a href="expressions/literal-expr#grammar-LiteralExpression">LiteralExpression</a></span> <br> | <span class="grammar-text"><a href="paths#grammar-SimplePathSegment">SimplePathSegment</a></span></p> <p><span class="grammar-text grammar-production" id="grammar-GenericArgsBinding" onclick="show_railroad()"><a href="paths#railroad-GenericArgsBinding">GenericArgsBinding</a></span> → <br> <span class="grammar-text"><a href="identifiers#grammar-IDENTIFIER">IDENTIFIER</a></span> <span class="grammar-text"><a href="paths#grammar-GenericArgs">GenericArgs</a></span><sup>?</sup> <span class="grammar-literal">=</span> <span class="grammar-text"><a href="types#grammar-Type">Type</a></span></p> <p><span class="grammar-text grammar-production" id="grammar-GenericArgsBounds" onclick="show_railroad()"><a href="paths#railroad-GenericArgsBounds">GenericArgsBounds</a></span> → <br> <span class="grammar-text"><a href="identifiers#grammar-IDENTIFIER">IDENTIFIER</a></span> <span class="grammar-text"><a href="paths#grammar-GenericArgs">GenericArgs</a></span><sup>?</sup> <span class="grammar-literal">:</span> <span class="grammar-text"><a href="trait-bounds#grammar-TypeParamBounds">TypeParamBounds</a></span></p> <p><button class="grammar-toggle-railroad" type="button" title="Toggle railroad display" onclick="toggle_railroad()">Show Railroad</button></p> </div> <div class="grammar-railroad grammar-hidden"> <div style="width: 572px; height: auto; max-width: 100%; max-height: 100%" class="railroad-production" id="railroad-PathInExpression">
<svg class="railroad" viewbox="0 0 572 100" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">  <g class="verticalgrid"> <a class="link" xlink:href="paths.html#grammar-PathInExpression"> <text class="comment" x="71" y="25"> PathInExpression</text> </a> <g class="sequence">  <g class="sequence"> <g class="optional">  <g class="terminal">  <text x="77" y="71"> ::</text> </g> </g> <a class="link" xlink:href="paths.html#railroad-PathExprSegment"> <g class="nonterminal">  <text x="199" y="71"> PathExprSegment</text> </g> </a> <g class="optional">  <g class="repeat">   <g class="sequence"> <g class="terminal">  <text x="333" y="71"> ::</text> </g> <a class="link" xlink:href="paths.html#railroad-PathExprSegment"> <g class="nonterminal">  <text x="431" y="71"> PathExprSegment</text> </g> </a>  </g> </g> </g>   </g>    </g> </g> </svg> </div> <div style="width: 430px; height: auto; max-width: 100%; max-height: 100%" class="railroad-production" id="railroad-PathExprSegment">
<svg class="railroad" viewbox="0 0 430 87" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">  <g class="verticalgrid"> <a class="link" xlink:href="paths.html#grammar-PathExprSegment"> <text class="comment" x="67" y="25"> PathExprSegment</text> </a> <g class="sequence">  <g class="sequence"> <a class="link" xlink:href="paths.html#railroad-PathIdentSegment"> <g class="nonterminal">  <text x="109" y="71"> PathIdentSegment</text> </g> </a> <g class="optional">  <g class="sequence"> <g class="terminal">  <text x="235" y="71"> ::</text> </g> <a class="link" xlink:href="paths.html#railroad-GenericArgs"> <g class="nonterminal">  <text x="317" y="71"> GenericArgs</text> </g> </a>  </g> </g>  </g>    </g> </g> </svg> </div> <div style="width: 218px; height: auto; max-width: 100%; max-height: 100%" class="railroad-production" id="railroad-PathIdentSegment">
<svg class="railroad" viewbox="0 0 218 239" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">  <g class="verticalgrid"> <a class="link" xlink:href="paths.html#grammar-PathIdentSegment"> <text class="comment" x="71" y="25"> PathIdentSegment</text> </a> <g class="sequence">  <g class="choice">  <g class="sequence"> <a class="link" xlink:href="identifiers.html#railroad-IDENTIFIER"> <g class="nonterminal">  <text x="109" y="58"> IDENTIFIER</text> </g> </a> </g>       <g class="terminal">  <text x="89" y="91"> super</text> </g>  <g class="terminal">  <text x="85" y="124"> self</text> </g>  <g class="terminal">  <text x="85" y="157"> Self</text> </g>  <g class="terminal">  <text x="89" y="190"> crate</text> </g>  <g class="terminal">  <text x="93" y="223"> $crate</text> </g> </g>    </g> </g> </svg> </div> <div style="width: 600px; height: auto; max-width: 100%; max-height: 100%" class="railroad-production" id="railroad-GenericArgs">
<svg class="railroad" viewbox="0 0 600 132" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">  <g class="verticalgrid"> <a class="link" xlink:href="paths.html#grammar-GenericArgs"> <text class="comment" x="53" y="25"> GenericArgs</text> </a> <g class="sequence">  <g class="choice">  <g class="sequence"> <g class="terminal">  <text x="73" y="58"> &lt;</text> </g> <g class="terminal">  <text x="111" y="58"> &gt;</text> </g>  </g>   <g class="sequence"> <g class="terminal">  <text x="73" y="103"> &lt;</text> </g> <g class="optional">  <g class="repeat">   <g class="sequence"> <a class="link" xlink:href="paths.html#railroad-GenericArg"> <g class="nonterminal">  <text x="183" y="103"> GenericArg</text> </g> </a> <g class="terminal">  <text x="257" y="103"> ,</text> </g>  </g> </g> </g> <a class="link" xlink:href="paths.html#railroad-GenericArg"> <g class="nonterminal">  <text x="367" y="103"> GenericArg</text> </g> </a> <g class="optional">  <g class="terminal">  <text x="465" y="103"> ,</text> </g> </g> <g class="terminal">  <text x="527" y="103"> &gt;</text> </g>     </g> </g>    </g> </g> </svg> </div> <div style="width: 282px; height: auto; max-width: 100%; max-height: 100%" class="railroad-production" id="railroad-GenericArg">
<svg class="railroad" viewbox="0 0 282 206" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">  <g class="verticalgrid"> <a class="link" xlink:href="paths.html#grammar-GenericArg"> <text class="comment" x="50" y="25"> GenericArg</text> </a> <g class="sequence">  <g class="choice">  <g class="sequence"> <a class="link" xlink:href="trait-bounds.html#railroad-Lifetime"> <g class="nonterminal">  <text x="101" y="58"> Lifetime</text> </g> </a> </g>      <a class="link" xlink:href="types.html#railroad-Type"> <g class="nonterminal">  <text x="85" y="91"> Type</text> </g> </a>  <a class="link" xlink:href="paths.html#railroad-GenericArgsConst"> <g class="nonterminal">  <text x="133" y="124"> GenericArgsConst</text> </g> </a>  <a class="link" xlink:href="paths.html#railroad-GenericArgsBinding"> <g class="nonterminal">  <text x="141" y="157"> GenericArgsBinding</text> </g> </a>  <a class="link" xlink:href="paths.html#railroad-GenericArgsBounds"> <g class="nonterminal">  <text x="137" y="190"> GenericArgsBounds</text> </g> </a> </g>    </g> </g> </svg> </div> <div style="width: 312px; height: auto; max-width: 100%; max-height: 100%" class="railroad-production" id="railroad-GenericArgsConst">
<svg class="railroad" viewbox="0 0 312 173" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">  <g class="verticalgrid"> <a class="link" xlink:href="paths.html#grammar-GenericArgsConst"> <text class="comment" x="71" y="25"> GenericArgsConst</text> </a> <g class="sequence">  <g class="choice">  <g class="sequence"> <a class="link" xlink:href="expressions/block-expr.html#railroad-BlockExpression"> <g class="nonterminal">  <text x="129" y="58"> BlockExpression</text> </g> </a> </g>     <g class="sequence"> <a class="link" xlink:href="expressions/literal-expr.html#railroad-LiteralExpression"> <g class="nonterminal">  <text x="137" y="91"> LiteralExpression</text> </g> </a> </g>  <g class="sequence"> <g class="terminal">  <text x="73" y="124"> -</text> </g> <a class="link" xlink:href="expressions/literal-expr.html#railroad-LiteralExpression"> <g class="nonterminal">  <text x="175" y="124"> LiteralExpression</text> </g> </a>  </g>  <a class="link" xlink:href="paths.html#railroad-SimplePathSegment"> <g class="nonterminal">  <text x="137" y="157"> SimplePathSegment</text> </g> </a> </g>    </g> </g> </svg> </div> <div style="width: 436px; height: auto; max-width: 100%; max-height: 100%" class="railroad-production" id="railroad-GenericArgsBinding">
<svg class="railroad" viewbox="0 0 436 87" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">  <g class="verticalgrid"> <a class="link" xlink:href="paths.html#grammar-GenericArgsBinding"> <text class="comment" x="78" y="25"> GenericArgsBinding</text> </a> <g class="sequence">  <g class="sequence"> <a class="link" xlink:href="identifiers.html#railroad-IDENTIFIER"> <g class="nonterminal">  <text x="85" y="71"> IDENTIFIER</text> </g> </a> <g class="optional">  <a class="link" xlink:href="paths.html#railroad-GenericArgs"> <g class="nonterminal">  <text x="223" y="71"> GenericArgs</text> </g> </a> </g> <g class="terminal">  <text x="325" y="71"> =</text> </g> <a class="link" xlink:href="types.html#railroad-Type"> <g class="nonterminal">  <text x="375" y="71"> Type</text> </g> </a>    </g>    </g> </g> </svg> </div> <div style="width: 524px; height: auto; max-width: 100%; max-height: 100%" class="railroad-production" id="railroad-GenericArgsBounds">
<svg class="railroad" viewbox="0 0 524 87" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">  <g class="verticalgrid"> <a class="link" xlink:href="paths.html#grammar-GenericArgsBounds"> <text class="comment" x="74" y="25"> GenericArgsBounds</text> </a> <g class="sequence">  <g class="sequence"> <a class="link" xlink:href="identifiers.html#railroad-IDENTIFIER"> <g class="nonterminal">  <text x="85" y="71"> IDENTIFIER</text> </g> </a> <g class="optional">  <a class="link" xlink:href="paths.html#railroad-GenericArgs"> <g class="nonterminal">  <text x="223" y="71"> GenericArgs</text> </g> </a> </g> <g class="terminal">  <text x="325" y="71"> :</text> </g> <a class="link" xlink:href="trait-bounds.html#railroad-TypeParamBounds"> <g class="nonterminal">  <text x="419" y="71"> TypeParamBounds</text> </g> </a>    </g>    </g> </g> </svg> </div> </div> <div class="rule" id="r-paths.expr.intro">
<a class="rule-link" href="#r-paths.expr.intro" title="paths.expr.intro"><span>[paths<wbr>.expr<wbr>.intro]</wbr></wbr></span></a> </div> <p>Paths in expressions allow for paths with generic arguments to be specified. They are used in various places in <a href="expressions">expressions</a> and <a href="patterns">patterns</a>.</p> <div class="rule" id="r-paths.expr.turbofish">
<a class="rule-link" href="#r-paths.expr.turbofish" title="paths.expr.turbofish"><span>[paths<wbr>.expr<wbr>.turbofish]</wbr></wbr></span></a> </div> <p>The <code>::</code> token is required before the opening <code>&lt;</code> for generic arguments to avoid ambiguity with the less-than operator. This is colloquially known as “turbofish” syntax.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
(0..10).collect::&lt;Vec&lt;_&gt;&gt;();
Vec::&lt;u8&gt;::with_capacity(1024);
}</pre> <div class="rule" id="r-paths.expr.argument-order">
<a class="rule-link" href="#r-paths.expr.argument-order" title="paths.expr.argument-order"><span>[paths<wbr>.expr<wbr>.argument-order]</wbr></wbr></span></a> </div> <p>The order of generic arguments is restricted to lifetime arguments, then type arguments, then const arguments, then equality constraints.</p> <div class="rule" id="r-paths.expr.complex-const-params">
<a class="rule-link" href="#r-paths.expr.complex-const-params" title="paths.expr.complex-const-params"><span>[paths<wbr>.expr<wbr>.complex-const-params]</wbr></wbr></span></a> </div> <p>Const arguments must be surrounded by braces unless they are a <a href="expressions/literal-expr">literal</a> or a single segment path.</p> <div class="rule" id="r-paths.expr.impl-trait-params">
<a class="rule-link" href="#r-paths.expr.impl-trait-params" title="paths.expr.impl-trait-params"><span>[paths<wbr>.expr<wbr>.impl-trait-params]</wbr></wbr></span></a> </div> <p>The synthetic type parameters corresponding to <code>impl Trait</code> types are implicit, and these cannot be explicitly specified.</p> <div class="rule" id="r-paths.qualified">
<a class="rule-link" href="#r-paths.qualified" title="paths.qualified"><span>[paths<wbr>.qualified]</wbr></span></a> </div> <h2 id="qualified-paths">Qualified paths</h2> <div class="rule" id="r-paths.qualified.syntax">
<a class="rule-link" href="#r-paths.qualified.syntax" title="paths.qualified.syntax"><span>[paths<wbr>.qualified<wbr>.syntax]</wbr></wbr></span></a> </div> <div class="grammar-container"> <p><strong><sup>Syntax</sup></strong> <br> <span class="grammar-text grammar-production" id="grammar-QualifiedPathInExpression" onclick="show_railroad()"><a href="paths#railroad-QualifiedPathInExpression">QualifiedPathInExpression</a></span> → <span class="grammar-text"><a href="paths#grammar-QualifiedPathType">QualifiedPathType</a></span> ( <span class="grammar-literal">::</span> <span class="grammar-text"><a href="paths#grammar-PathExprSegment">PathExprSegment</a></span> )<sup>+</sup></p> <p><span class="grammar-text grammar-production" id="grammar-QualifiedPathType" onclick="show_railroad()"><a href="paths#railroad-QualifiedPathType">QualifiedPathType</a></span> → <span class="grammar-literal">&lt;</span> <span class="grammar-text"><a href="types#grammar-Type">Type</a></span> ( <span class="grammar-literal">as</span> <span class="grammar-text"><a href="paths#grammar-TypePath">TypePath</a></span> )<sup>?</sup> <span class="grammar-literal">&gt;</span></p> <p><span class="grammar-text grammar-production" id="grammar-QualifiedPathInType" onclick="show_railroad()"><a href="paths#railroad-QualifiedPathInType">QualifiedPathInType</a></span> → <span class="grammar-text"><a href="paths#grammar-QualifiedPathType">QualifiedPathType</a></span> ( <span class="grammar-literal">::</span> <span class="grammar-text"><a href="paths#grammar-TypePathSegment">TypePathSegment</a></span> )<sup>+</sup></p> <p><button class="grammar-toggle-railroad" type="button" title="Toggle railroad display" onclick="toggle_railroad()">Show Railroad</button></p> </div> <div class="grammar-railroad grammar-hidden"> <div style="width: 446px; height: auto; max-width: 100%; max-height: 100%" class="railroad-production" id="railroad-QualifiedPathInExpression">
<svg class="railroad" viewbox="0 0 446 87" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">  <g class="verticalgrid"> <a class="link" xlink:href="paths.html#grammar-QualifiedPathInExpression"> <text class="comment" x="106" y="25"> QualifiedPathInExpression</text> </a> <g class="sequence">  <g class="sequence"> <a class="link" xlink:href="paths.html#railroad-QualifiedPathType"> <g class="nonterminal">  <text x="113" y="58"> QualifiedPathType</text> </g> </a> <g class="repeat">   <g class="sequence"> <g class="terminal">  <text x="231" y="58"> ::</text> </g> <a class="link" xlink:href="paths.html#railroad-PathExprSegment"> <g class="nonterminal">  <text x="329" y="58"> PathExprSegment</text> </g> </a>  </g> </g>  </g>    </g> </g> </svg> </div> <div style="width: 386px; height: auto; max-width: 100%; max-height: 100%" class="railroad-production" id="railroad-QualifiedPathType">
<svg class="railroad" viewbox="0 0 386 87" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">  <g class="verticalgrid"> <a class="link" xlink:href="paths.html#grammar-QualifiedPathType"> <text class="comment" x="74" y="25"> QualifiedPathType</text> </a> <g class="sequence">  <g class="sequence"> <g class="terminal">  <text x="49" y="71"> &lt;</text> </g> <a class="link" xlink:href="types.html#railroad-Type"> <g class="nonterminal">  <text x="99" y="71"> Type</text> </g> </a> <g class="optional">  <g class="sequence"> <g class="terminal">  <text x="177" y="71"> as</text> </g> <a class="link" xlink:href="paths.html#railroad-TypePath"> <g class="nonterminal">  <text x="247" y="71"> TypePath</text> </g> </a>  </g> </g> <g class="terminal">  <text x="337" y="71"> &gt;</text> </g>    </g>    </g> </g> </svg> </div> <div style="width: 446px; height: auto; max-width: 100%; max-height: 100%" class="railroad-production" id="railroad-QualifiedPathInType">
<svg class="railroad" viewbox="0 0 446 87" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">  <g class="verticalgrid"> <a class="link" xlink:href="paths.html#grammar-QualifiedPathInType"> <text class="comment" x="81" y="25"> QualifiedPathInType</text> </a> <g class="sequence">  <g class="sequence"> <a class="link" xlink:href="paths.html#railroad-QualifiedPathType"> <g class="nonterminal">  <text x="113" y="58"> QualifiedPathType</text> </g> </a> <g class="repeat">   <g class="sequence"> <g class="terminal">  <text x="231" y="58"> ::</text> </g> <a class="link" xlink:href="paths.html#railroad-TypePathSegment"> <g class="nonterminal">  <text x="329" y="58"> TypePathSegment</text> </g> </a>  </g> </g>  </g>    </g> </g> </svg> </div> </div> <div class="rule" id="r-paths.qualified.intro">
<a class="rule-link" href="#r-paths.qualified.intro" title="paths.qualified.intro"><span>[paths<wbr>.qualified<wbr>.intro]</wbr></wbr></span></a> </div> <p>Fully qualified paths allow for disambiguating the path for <a href="items/implementations#trait-implementations">trait implementations</a> and for specifying <a href="#canonical-paths">canonical paths</a>. When used in a type specification, it supports using the type syntax specified below.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
struct S;
impl S {
    fn f() { println!("S"); }
}
trait T1 {
    fn f() { println!("T1 f"); }
}
impl T1 for S {}
trait T2 {
    fn f() { println!("T2 f"); }
}
impl T2 for S {}
S::f();  // Calls the inherent impl.
&lt;S as T1&gt;::f();  // Calls the T1 trait function.
&lt;S as T2&gt;::f();  // Calls the T2 trait function.
}</pre> <div class="rule" id="r-paths.type">
<a class="rule-link" href="#r-paths.type" title="paths.type"><span>[paths<wbr>.type]</wbr></span></a> </div> <h3 id="paths-in-types">Paths in types</h3> <div class="rule" id="r-paths.type.syntax">
<a class="rule-link" href="#r-paths.type.syntax" title="paths.type.syntax"><span>[paths<wbr>.type<wbr>.syntax]</wbr></wbr></span></a> </div> <div class="grammar-container"> <p><strong><sup>Syntax</sup></strong> <br> <span class="grammar-text grammar-production" id="grammar-TypePath" onclick="show_railroad()"><a href="paths#railroad-TypePath">TypePath</a></span> → <span class="grammar-literal">::</span><sup>?</sup> <span class="grammar-text"><a href="paths#grammar-TypePathSegment">TypePathSegment</a></span> ( <span class="grammar-literal">::</span> <span class="grammar-text"><a href="paths#grammar-TypePathSegment">TypePathSegment</a></span> )<sup>*</sup></p> <p><span class="grammar-text grammar-production" id="grammar-TypePathSegment" onclick="show_railroad()"><a href="paths#railroad-TypePathSegment">TypePathSegment</a></span> → <span class="grammar-text"><a href="paths#grammar-PathIdentSegment">PathIdentSegment</a></span> ( <span class="grammar-literal">::</span><sup>?</sup> ( <span class="grammar-text"><a href="paths#grammar-GenericArgs">GenericArgs</a></span> | <span class="grammar-text"><a href="paths#grammar-TypePathFn">TypePathFn</a></span> ) )<sup>?</sup></p> <p><span class="grammar-text grammar-production" id="grammar-TypePathFn" onclick="show_railroad()"><a href="paths#railroad-TypePathFn">TypePathFn</a></span> → <span class="grammar-literal">(</span> <span class="grammar-text"><a href="paths#grammar-TypePathFnInputs">TypePathFnInputs</a></span><sup>?</sup> <span class="grammar-literal">)</span> ( <span class="grammar-literal">-&gt;</span> <span class="grammar-text"><a href="types#grammar-TypeNoBounds">TypeNoBounds</a></span> )<sup>?</sup></p> <p><span class="grammar-text grammar-production" id="grammar-TypePathFnInputs" onclick="show_railroad()"><a href="paths#railroad-TypePathFnInputs">TypePathFnInputs</a></span> → <span class="grammar-text"><a href="types#grammar-Type">Type</a></span> ( <span class="grammar-literal">,</span> <span class="grammar-text"><a href="types#grammar-Type">Type</a></span> )<sup>*</sup> <span class="grammar-literal">,</span><sup>?</sup></p> <p><button class="grammar-toggle-railroad" type="button" title="Toggle railroad display" onclick="toggle_railroad()">Show Railroad</button></p> </div> <div class="grammar-railroad grammar-hidden"> <div style="width: 572px; height: auto; max-width: 100%; max-height: 100%" class="railroad-production" id="railroad-TypePath">
<svg class="railroad" viewbox="0 0 572 100" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">  <g class="verticalgrid"> <a class="link" xlink:href="paths.html#grammar-TypePath"> <text class="comment" x="43" y="25"> TypePath</text> </a> <g class="sequence">  <g class="sequence"> <g class="optional">  <g class="terminal">  <text x="77" y="71"> ::</text> </g> </g> <a class="link" xlink:href="paths.html#railroad-TypePathSegment"> <g class="nonterminal">  <text x="199" y="71"> TypePathSegment</text> </g> </a> <g class="optional">  <g class="repeat">   <g class="sequence"> <g class="terminal">  <text x="333" y="71"> ::</text> </g> <a class="link" xlink:href="paths.html#railroad-TypePathSegment"> <g class="nonterminal">  <text x="431" y="71"> TypePathSegment</text> </g> </a>  </g> </g> </g>   </g>    </g> </g> </svg> </div> <div style="width: 526px; height: auto; max-width: 100%; max-height: 100%" class="railroad-production" id="railroad-TypePathSegment">
<svg class="railroad" viewbox="0 0 526 132" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">  <g class="verticalgrid"> <a class="link" xlink:href="paths.html#grammar-TypePathSegment"> <text class="comment" x="67" y="25"> TypePathSegment</text> </a> <g class="sequence">  <g class="sequence"> <a class="link" xlink:href="paths.html#railroad-PathIdentSegment"> <g class="nonterminal">  <text x="109" y="83"> PathIdentSegment</text> </g> </a> <g class="optional">  <g class="sequence"> <g class="optional">  <g class="terminal">  <text x="259" y="83"> ::</text> </g> </g> <g class="choice">  <a class="link" xlink:href="paths.html#railroad-GenericArgs"> <g class="nonterminal">  <text x="389" y="83"> GenericArgs</text> </g> </a>   <a class="link" xlink:href="paths.html#railroad-TypePathFn"> <g class="nonterminal">  <text x="385" y="116"> TypePathFn</text> </g> </a> </g>  </g> </g>  </g>    </g> </g> </svg> </div> <div style="width: 562px; height: auto; max-width: 100%; max-height: 100%" class="railroad-production" id="railroad-TypePathFn">
<svg class="railroad" viewbox="0 0 562 87" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">  <g class="verticalgrid"> <a class="link" xlink:href="paths.html#grammar-TypePathFn"> <text class="comment" x="50" y="25"> TypePathFn</text> </a> <g class="sequence">  <g class="sequence"> <g class="terminal">  <text x="49" y="71"> (</text> </g> <g class="optional">  <a class="link" xlink:href="paths.html#railroad-TypePathFnInputs"> <g class="nonterminal">  <text x="171" y="71"> TypePathFnInputs</text> </g> </a> </g> <g class="terminal">  <text x="293" y="71"> )</text> </g> <g class="optional">  <g class="sequence"> <g class="terminal">  <text x="359" y="71"> -&gt;</text> </g> <a class="link" xlink:href="types.html#railroad-TypeNoBounds"> <g class="nonterminal">  <text x="445" y="71"> TypeNoBounds</text> </g> </a>  </g> </g>    </g>    </g> </g> </svg> </div> <div style="width: 380px; height: auto; max-width: 100%; max-height: 100%" class="railroad-production" id="railroad-TypePathFnInputs">
<svg class="railroad" viewbox="0 0 380 100" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">  <g class="verticalgrid"> <a class="link" xlink:href="paths.html#grammar-TypePathFnInputs"> <text class="comment" x="71" y="25"> TypePathFnInputs</text> </a> <g class="sequence">  <g class="sequence"> <a class="link" xlink:href="types.html#railroad-Type"> <g class="nonterminal">  <text x="61" y="71"> Type</text> </g> </a> <g class="optional">  <g class="repeat">   <g class="sequence"> <g class="terminal">  <text x="147" y="71"> ,</text> </g> <a class="link" xlink:href="types.html#railroad-Type"> <g class="nonterminal">  <text x="197" y="71"> Type</text> </g> </a>  </g> </g> </g> <g class="optional">  <g class="terminal">  <text x="307" y="71"> ,</text> </g> </g>   </g>    </g> </g> </svg> </div> </div> <div class="rule" id="r-paths.type.intro">
<a class="rule-link" href="#r-paths.type.intro" title="paths.type.intro"><span>[paths<wbr>.type<wbr>.intro]</wbr></wbr></span></a> </div> <p>Type paths are used within type definitions, trait bounds, type parameter bounds, and qualified paths.</p> <div class="rule" id="r-paths.type.turbofish">
<a class="rule-link" href="#r-paths.type.turbofish" title="paths.type.turbofish"><span>[paths<wbr>.type<wbr>.turbofish]</wbr></wbr></span></a> </div> <p>Although the <code>::</code> token is allowed before the generics arguments, it is not required because there is no ambiguity like there is in <em>PathInExpression</em>.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
mod ops {
    pub struct Range&lt;T&gt; {f1: T}
    pub trait Index&lt;T&gt; {}
    pub struct Example&lt;'a&gt; {f1: &amp;'a i32}
}
struct S;
impl ops::Index&lt;ops::Range&lt;usize&gt;&gt; for S { /*...*/ }
fn i&lt;'a&gt;() -&gt; impl Iterator&lt;Item = ops::Example&lt;'a&gt;&gt; {
    // ...
   const EXAMPLE: Vec&lt;ops::Example&lt;'static&gt;&gt; = Vec::new();
   EXAMPLE.into_iter()
}
type G = std::boxed::Box&lt;dyn std::ops::FnOnce(isize) -&gt; isize&gt;;
}</pre> <div class="rule" id="r-paths.qualifiers">
<a class="rule-link" href="#r-paths.qualifiers" title="paths.qualifiers"><span>[paths<wbr>.qualifiers]</wbr></span></a> </div> <h2 id="path-qualifiers">Path qualifiers</h2> <p>Paths can be denoted with various leading qualifiers to change the meaning of how it is resolved.</p> <div class="rule" id="r-paths.qualifiers.global-root">
<a class="rule-link" href="#r-paths.qualifiers.global-root" title="paths.qualifiers.global-root"><span>[paths<wbr>.qualifiers<wbr>.global-root]</wbr></wbr></span></a> </div> <h3 id=""><code id="">::</code></h3> <div class="rule" id="r-paths.qualifiers.global-root.intro">
<a class="rule-link" href="#r-paths.qualifiers.global-root.intro" title="paths.qualifiers.global-root.intro"><span>[paths<wbr>.qualifiers<wbr>.global-root<wbr>.intro]</wbr></wbr></wbr></span></a> </div> <p>Paths starting with <code>::</code> are considered to be <em>global paths</em> where the segments of the path start being resolved from a place which differs based on edition. Each identifier in the path must resolve to an item.</p> <div class="rule" id="r-paths.qualifiers.global-root.edition2018">
<a class="rule-link" href="#r-paths.qualifiers.global-root.edition2018" title="paths.qualifiers.global-root.edition2018"><span>[paths<wbr>.qualifiers<wbr>.global-root<wbr>.edition2018]</wbr></wbr></wbr></span></a> </div> <div class="alert alert-edition"> <blockquote> <p class="alert-title"><span class="alert-title-edition">2018</span> Edition differences</p> <p>In the 2015 Edition, identifiers resolve from the “crate root” (<code>crate::</code> in the 2018 edition), which contains a variety of different items, including external crates, default crates such as <code>std</code> or <code>core</code>, and items in the top level of the crate (including <code>use</code> imports).</p> <p>Beginning with the 2018 Edition, paths starting with <code>::</code> resolve from crates in the <a href="names/preludes#extern-prelude">extern prelude</a>. That is, they must be followed by the name of a crate.</p> </blockquote> </div> <pre data-language="rust">#![allow(unused)]
fn main() {
pub fn foo() {
    // In the 2018 edition, this accesses `std` via the extern prelude.
    // In the 2015 edition, this accesses `std` via the crate root.
    let now = ::std::time::Instant::now();
    println!("{:?}", now);
}
}</pre> <pre data-language="rust">// 2015 Edition
mod a {
    pub fn foo() {}
}
mod b {
    pub fn foo() {
        ::a::foo(); // call `a`'s foo function
        // In Rust 2018, `::a` would be interpreted as the crate `a`.
    }
}
fn main() {}</pre> <div class="rule" id="r-paths.qualifiers.mod-self">
<a class="rule-link" href="#r-paths.qualifiers.mod-self" title="paths.qualifiers.mod-self"><span>[paths<wbr>.qualifiers<wbr>.mod-self]</wbr></wbr></span></a> </div> <h3 id="self"><code id="">self</code></h3> <div class="rule" id="r-paths.qualifiers.mod-self.intro">
<a class="rule-link" href="#r-paths.qualifiers.mod-self.intro" title="paths.qualifiers.mod-self.intro"><span>[paths<wbr>.qualifiers<wbr>.mod-self<wbr>.intro]</wbr></wbr></wbr></span></a> </div> <p><code>self</code> resolves the path relative to the current module.</p> <div class="rule" id="r-paths.qualifiers.mod-self.restriction">
<a class="rule-link" href="#r-paths.qualifiers.mod-self.restriction" title="paths.qualifiers.mod-self.restriction"><span>[paths<wbr>.qualifiers<wbr>.mod-self<wbr>.restriction]</wbr></wbr></wbr></span></a> </div> <p><code>self</code> can only be used as the first segment, without a preceding <code>::</code>.</p> <div class="rule" id="r-paths.qualifiers.self-pat">
<a class="rule-link" href="#r-paths.qualifiers.self-pat" title="paths.qualifiers.self-pat"><span>[paths<wbr>.qualifiers<wbr>.self-pat]</wbr></wbr></span></a> </div> <p>In a method body, a path which consists of a single <code>self</code> segment resolves to the method’s self parameter.</p> <pre data-language="rust">fn foo() {}
fn bar() {
    self::foo();
}
struct S(bool);
impl S {
  fn baz(self) {
        self.0;
    }
}
fn main() {}</pre> <div class="rule" id="r-paths.qualifiers.type-self">
<a class="rule-link" href="#r-paths.qualifiers.type-self" title="paths.qualifiers.type-self"><span>[paths<wbr>.qualifiers<wbr>.type-self]</wbr></wbr></span></a> </div> <h3 id="self-1"><code id="">Self</code></h3> <div class="rule" id="r-paths.qualifiers.type-self.intro">
<a class="rule-link" href="#r-paths.qualifiers.type-self.intro" title="paths.qualifiers.type-self.intro"><span>[paths<wbr>.qualifiers<wbr>.type-self<wbr>.intro]</wbr></wbr></wbr></span></a> </div> <p><code>Self</code>, with a capital “S”, is used to refer to the current type being implemented or defined. It may be used in the following situations:</p> <div class="rule" id="r-paths.qualifiers.type-self.trait">
<a class="rule-link" href="#r-paths.qualifiers.type-self.trait" title="paths.qualifiers.type-self.trait"><span>[paths<wbr>.qualifiers<wbr>.type-self<wbr>.trait]</wbr></wbr></wbr></span></a> </div> <ul> <li>In a <a href="items/traits">trait</a> definition, it refers to the type implementing the trait.</li> </ul> <div class="rule" id="r-paths.qualifiers.type-self.impl">
<a class="rule-link" href="#r-paths.qualifiers.type-self.impl" title="paths.qualifiers.type-self.impl"><span>[paths<wbr>.qualifiers<wbr>.type-self<wbr>.impl]</wbr></wbr></wbr></span></a> </div> <ul> <li>In an <a href="items/implementations">implementation</a>, it refers to the type being implemented. When implementing a tuple or unit <a href="items/structs">struct</a>, it also refers to the constructor in the <a href="names/namespaces">value namespace</a>.</li> </ul> <div class="rule" id="r-paths.qualifiers.type-self.type">
<a class="rule-link" href="#r-paths.qualifiers.type-self.type" title="paths.qualifiers.type-self.type"><span>[paths<wbr>.qualifiers<wbr>.type-self<wbr>.type]</wbr></wbr></wbr></span></a> </div> <ul> <li>In the definition of a <a href="items/structs">struct</a>, <a href="items/enumerations">enumeration</a>, or <a href="items/unions">union</a>, it refers to the type being defined. The definition is not allowed to be infinitely recursive (there must be an indirection).</li> </ul> <div class="rule" id="r-paths.qualifiers.type-self.scope">
<a class="rule-link" href="#r-paths.qualifiers.type-self.scope" title="paths.qualifiers.type-self.scope"><span>[paths<wbr>.qualifiers<wbr>.type-self<wbr>.scope]</wbr></wbr></wbr></span></a> </div> <p>The scope of <code>Self</code> behaves similarly to a generic parameter; see the <a href="names/scopes#self-scope"><code>Self</code> scope</a> section for more details.</p> <div class="rule" id="r-paths.qualifiers.type-self.allowed-positions">
<a class="rule-link" href="#r-paths.qualifiers.type-self.allowed-positions" title="paths.qualifiers.type-self.allowed-positions"><span>[paths<wbr>.qualifiers<wbr>.type-self<wbr>.allowed-positions]</wbr></wbr></wbr></span></a> </div> <p><code>Self</code> can only be used as the first segment, without a preceding <code>::</code>.</p> <div class="rule" id="r-paths.qualifiers.type-self.no-generics">
<a class="rule-link" href="#r-paths.qualifiers.type-self.no-generics" title="paths.qualifiers.type-self.no-generics"><span>[paths<wbr>.qualifiers<wbr>.type-self<wbr>.no-generics]</wbr></wbr></wbr></span></a> </div> <p>The <code>Self</code> path cannot include generic arguments (as in <code>Self::&lt;i32&gt;</code>).</p> <pre data-language="rust">#![allow(unused)]
fn main() {
trait T {
    type Item;
    const C: i32;
    // `Self` will be whatever type that implements `T`.
    fn new() -&gt; Self;
    // `Self::Item` will be the type alias in the implementation.
    fn f(&amp;self) -&gt; Self::Item;
}
struct S;
impl T for S {
    type Item = i32;
    const C: i32 = 9;
    fn new() -&gt; Self {           // `Self` is the type `S`.
        S
    }
    fn f(&amp;self) -&gt; Self::Item {  // `Self::Item` is the type `i32`.
        Self::C                  // `Self::C` is the constant value `9`.
    }
}

// `Self` is in scope within the generics of a trait definition,
// to refer to the type being defined.
trait Add&lt;Rhs = Self&gt; {
    type Output;
    // `Self` can also reference associated items of the
    // type being implemented.
    fn add(self, rhs: Rhs) -&gt; Self::Output;
}

struct NonEmptyList&lt;T&gt; {
    head: T,
    // A struct can reference itself (as long as it is not
    // infinitely recursive).
    tail: Option&lt;Box&lt;Self&gt;&gt;,
}
}</pre> <div class="rule" id="r-paths.qualifiers.super">
<a class="rule-link" href="#r-paths.qualifiers.super" title="paths.qualifiers.super"><span>[paths<wbr>.qualifiers<wbr>.super]</wbr></wbr></span></a> </div> <h3 id="super"><code id="">super</code></h3> <div class="rule" id="r-paths.qualifiers.super.intro">
<a class="rule-link" href="#r-paths.qualifiers.super.intro" title="paths.qualifiers.super.intro"><span>[paths<wbr>.qualifiers<wbr>.super<wbr>.intro]</wbr></wbr></wbr></span></a> </div> <p><code>super</code> in a path resolves to the parent module.</p> <div class="rule" id="r-paths.qualifiers.super.allowed-positions">
<a class="rule-link" href="#r-paths.qualifiers.super.allowed-positions" title="paths.qualifiers.super.allowed-positions"><span>[paths<wbr>.qualifiers<wbr>.super<wbr>.allowed-positions]</wbr></wbr></wbr></span></a> </div> <p>It may only be used in leading segments of the path, possibly after an initial <code>self</code> segment.</p> <pre data-language="rust">mod a {
    pub fn foo() {}
}
mod b {
    pub fn foo() {
        super::a::foo(); // call a's foo function
    }
}
fn main() {}</pre> <div class="rule" id="r-paths.qualifiers.super.repetition">
<a class="rule-link" href="#r-paths.qualifiers.super.repetition" title="paths.qualifiers.super.repetition"><span>[paths<wbr>.qualifiers<wbr>.super<wbr>.repetition]</wbr></wbr></wbr></span></a> </div> <p><code>super</code> may be repeated several times after the first <code>super</code> or <code>self</code> to refer to ancestor modules.</p> <pre data-language="rust">mod a {
    fn foo() {}

    mod b {
        mod c {
            fn foo() {
                super::super::foo(); // call a's foo function
                self::super::super::foo(); // call a's foo function
            }
        }
    }
}
fn main() {}</pre> <div class="rule" id="r-paths.qualifiers.crate">
<a class="rule-link" href="#r-paths.qualifiers.crate" title="paths.qualifiers.crate"><span>[paths<wbr>.qualifiers<wbr>.crate]</wbr></wbr></span></a> </div> <h3 id="crate"><code id="">crate</code></h3> <div class="rule" id="r-paths.qualifiers.crate.intro">
<a class="rule-link" href="#r-paths.qualifiers.crate.intro" title="paths.qualifiers.crate.intro"><span>[paths<wbr>.qualifiers<wbr>.crate<wbr>.intro]</wbr></wbr></wbr></span></a> </div> <p><code>crate</code> resolves the path relative to the current crate.</p> <div class="rule" id="r-paths.qualifiers.crate.allowed-positions">
<a class="rule-link" href="#r-paths.qualifiers.crate.allowed-positions" title="paths.qualifiers.crate.allowed-positions"><span>[paths<wbr>.qualifiers<wbr>.crate<wbr>.allowed-positions]</wbr></wbr></wbr></span></a> </div> <p><code>crate</code> can only be used as the first segment, without a preceding <code>::</code>.</p> <pre data-language="rust">fn foo() {}
mod a {
    fn bar() {
        crate::foo();
    }
}
fn main() {}</pre> <div class="rule" id="r-paths.qualifiers.macro-crate">
<a class="rule-link" href="#r-paths.qualifiers.macro-crate" title="paths.qualifiers.macro-crate"><span>[paths<wbr>.qualifiers<wbr>.macro-crate]</wbr></wbr></span></a> </div> <h3 id="crate-1"><code id="">$crate</code></h3> <div class="rule" id="r-paths.qualifiers.macro-crate.allowed-positions">
<a class="rule-link" href="#r-paths.qualifiers.macro-crate.allowed-positions" title="paths.qualifiers.macro-crate.allowed-positions"><span>[paths<wbr>.qualifiers<wbr>.macro-crate<wbr>.allowed-positions]</wbr></wbr></wbr></span></a> </div> <p><code>$crate</code> is only used within <a href="macros-by-example">macro transcribers</a>, and can only be used as the first segment, without a preceding <code>::</code>.</p> <div class="rule" id="r-paths.qualifiers.macro-crate.hygiene">
<a class="rule-link" href="#r-paths.qualifiers.macro-crate.hygiene" title="paths.qualifiers.macro-crate.hygiene"><span>[paths<wbr>.qualifiers<wbr>.macro-crate<wbr>.hygiene]</wbr></wbr></wbr></span></a> </div> <p><code>$crate</code> will expand to a path to access items from the top level of the crate where the macro is defined, regardless of which crate the macro is invoked.</p> <pre data-language="rust">pub fn increment(x: u32) -&gt; u32 {
    x + 1
}

#[macro_export]
macro_rules! inc {
    ($x:expr) =&gt; ( $crate::increment($x) )
}
fn main() { }</pre> <div class="rule" id="r-paths.canonical">
<a class="rule-link" href="#r-paths.canonical" title="paths.canonical"><span>[paths<wbr>.canonical]</wbr></span></a> </div> <h2 id="canonical-paths">Canonical paths</h2> <div class="rule" id="r-paths.canonical.intro">
<a class="rule-link" href="#r-paths.canonical.intro" title="paths.canonical.intro"><span>[paths<wbr>.canonical<wbr>.intro]</wbr></wbr></span></a> </div> <p>Items defined in a module or implementation have a <em>canonical path</em> that corresponds to where within its crate it is defined.</p> <div class="rule" id="r-paths.canonical.alias">
<a class="rule-link" href="#r-paths.canonical.alias" title="paths.canonical.alias"><span>[paths<wbr>.canonical<wbr>.alias]</wbr></wbr></span></a> </div> <p>All other paths to these items are aliases.</p> <div class="rule" id="r-paths.canonical.def">
<a class="rule-link" href="#r-paths.canonical.def" title="paths.canonical.def"><span>[paths<wbr>.canonical<wbr>.def]</wbr></wbr></span></a> </div> <p>The canonical path is defined as a <em>path prefix</em> appended by the path segment the item itself defines.</p> <div class="rule" id="r-paths.canonical.non-canonical">
<a class="rule-link" href="#r-paths.canonical.non-canonical" title="paths.canonical.non-canonical"><span>[paths<wbr>.canonical<wbr>.non-canonical]</wbr></wbr></span></a> </div> <p><a href="items/implementations">Implementations</a> and <a href="items/use-declarations">use declarations</a> do not have canonical paths, although the items that implementations define do have them. Items defined in block expressions do not have canonical paths. Items defined in a module that does not have a canonical path do not have a canonical path. Associated items defined in an implementation that refers to an item without a canonical path, e.g. as the implementing type, the trait being implemented, a type parameter or bound on a type parameter, do not have canonical paths.</p> <div class="rule" id="r-paths.canonical.module-prefix">
<a class="rule-link" href="#r-paths.canonical.module-prefix" title="paths.canonical.module-prefix"><span>[paths<wbr>.canonical<wbr>.module-prefix]</wbr></wbr></span></a> </div> <p>The path prefix for modules is the canonical path to that module.</p> <div class="rule" id="r-paths.canonical.bare-impl-prefix">
<a class="rule-link" href="#r-paths.canonical.bare-impl-prefix" title="paths.canonical.bare-impl-prefix"><span>[paths<wbr>.canonical<wbr>.bare-impl-prefix]</wbr></wbr></span></a> </div> <p>For bare implementations, it is the canonical path of the item being implemented surrounded by <span class="parenthetical">angle (<code>&lt;&gt;</code>)</span> brackets.</p> <div class="rule" id="r-paths.canonical.trait-impl-prefix">
<a class="rule-link" href="#r-paths.canonical.trait-impl-prefix" title="paths.canonical.trait-impl-prefix"><span>[paths<wbr>.canonical<wbr>.trait-impl-prefix]</wbr></wbr></span></a> </div> <p>For <a href="items/implementations#trait-implementations">trait implementations</a>, it is the canonical path of the item being implemented followed by <code>as</code> followed by the canonical path to the trait all surrounded in <span class="parenthetical">angle (<code>&lt;&gt;</code>)</span> brackets.</p> <div class="rule" id="r-paths.canonical.local-canonical-path">
<a class="rule-link" href="#r-paths.canonical.local-canonical-path" title="paths.canonical.local-canonical-path"><span>[paths<wbr>.canonical<wbr>.local-canonical-path]</wbr></wbr></span></a> </div> <p>The canonical path is only meaningful within a given crate. There is no global namespace across crates; an item’s canonical path merely identifies it within the crate.</p> <pre data-language="rust">// Comments show the canonical path of the item.

mod a { // crate::a
    pub struct Struct; // crate::a::Struct

    pub trait Trait { // crate::a::Trait
        fn f(&amp;self); // crate::a::Trait::f
    }

    impl Trait for Struct {
        fn f(&amp;self) {} // &lt;crate::a::Struct as crate::a::Trait&gt;::f
    }

    impl Struct {
        fn g(&amp;self) {} // &lt;crate::a::Struct&gt;::g
    }
}

mod without { // crate::without
    fn canonicals() { // crate::without::canonicals
        struct OtherStruct; // None

        trait OtherTrait { // None
            fn g(&amp;self); // None
        }

        impl OtherTrait for OtherStruct {
            fn g(&amp;self) {} // None
        }

        impl OtherTrait for crate::a::Struct {
            fn g(&amp;self) {} // None
        }

        impl crate::a::Trait for OtherStruct {
            fn f(&amp;self) {} // None
        }
    }
}

fn main() {}</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/reference/paths.html" class="_attribution-link">https://doc.rust-lang.org/reference/paths.html</a>
  </p>
</div>
</div>
            </main>
        </div>
    </div>
    <script type="text/javascript" src="../assets/index.js"></script>
</body>

</html>