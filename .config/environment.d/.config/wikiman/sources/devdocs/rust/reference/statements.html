<html class="_theme-default">
<head>
    <meta charset="utf-8">
    <title>.. Declaration statements</title>
    
    <link rel="preload" href="../assets/index.js" as="script" type="text/javascript" />

    <link rel="stylesheet" type="text/css" href="../application.css" />
    <link rel="stylesheet" type="text/css" href="../assets/index.css" />
</head>
<body>
    <div class="_app">
        <devdocs-navbar current="reference/statements" prefix="../" listing-src="../navbar.json"></devdocs-navbar>
        <div class="_container">
            <main class="_content">
                <div class="_page _rust"><h1 class="rule" id="r-statement">
<a class="rule-link" href="#r-statement" title="statement"><span>[statement]</span></a> </h1> <h1 id="statements">Statements</h1> <div class="rule" id="r-statement.syntax">
<a class="rule-link" href="#r-statement.syntax" title="statement.syntax"><span>[statement<wbr>.syntax]</wbr></span></a> </div> <div class="grammar-container"> <p><strong><sup>Syntax</sup></strong> <br> <span class="grammar-text grammar-production" id="grammar-Statement" onclick="show_railroad()"><a href="statements#railroad-Statement">Statement</a></span> → <br> <span class="grammar-literal">;</span> <br> | <span class="grammar-text"><a href="items#grammar-Item">Item</a></span> <br> | <span class="grammar-text"><a href="statements#grammar-LetStatement">LetStatement</a></span> <br> | <span class="grammar-text"><a href="statements#grammar-ExpressionStatement">ExpressionStatement</a></span> <br> | <span class="grammar-text"><a href="macros#grammar-MacroInvocationSemi">MacroInvocationSemi</a></span></p> <p><button class="grammar-toggle-railroad" type="button" title="Toggle railroad display" onclick="toggle_railroad()">Show Railroad</button></p> </div> <div class="grammar-railroad grammar-hidden"> <div style="width: 290px; height: auto; max-width: 100%; max-height: 100%" class="railroad-production" id="railroad-Statement">
<svg class="railroad" viewbox="0 0 290 206" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">  <g class="verticalgrid"> <a class="link" xlink:href="statements.html#grammar-Statement"> <text class="comment" x="46" y="25"> Statement</text> </a> <g class="sequence">  <g class="choice">  <g class="sequence"> <g class="terminal">  <text x="73" y="58"> ;</text> </g> </g>      <g class="sequence"> <a class="link" xlink:href="items.html#railroad-Item"> <g class="nonterminal">  <text x="85" y="91"> Item</text> </g> </a> </g>  <g class="sequence"> <a class="link" xlink:href="statements.html#railroad-LetStatement"> <g class="nonterminal">  <text x="117" y="124"> LetStatement</text> </g> </a> </g>  <g class="sequence"> <a class="link" xlink:href="statements.html#railroad-ExpressionStatement"> <g class="nonterminal">  <text x="145" y="157"> ExpressionStatement</text> </g> </a> </g>  <a class="link" xlink:href="macros.html#railroad-MacroInvocationSemi"> <g class="nonterminal">  <text x="145" y="190"> MacroInvocationSemi</text> </g> </a> </g>    </g> </g> </svg> </div> </div> <div class="rule" id="r-statement.intro">
<a class="rule-link" href="#r-statement.intro" title="statement.intro"><span>[statement<wbr>.intro]</wbr></span></a> </div> <p>A <em>statement</em> is a component of a <a href="expressions/block-expr">block</a>, which is in turn a component of an outer <a href="expressions">expression</a> or <a href="items/functions">function</a>.</p> <div class="rule" id="r-statement.kind">
<a class="rule-link" href="#r-statement.kind" title="statement.kind"><span>[statement<wbr>.kind]</wbr></span></a> </div> <p>Rust has two kinds of statement: <a href="#declaration-statements">declaration statements</a> and <a href="#expression-statements">expression statements</a>.</p> <div class="rule" id="r-statement.decl">
<a class="rule-link" href="#r-statement.decl" title="statement.decl"><span>[statement<wbr>.decl]</wbr></span></a> </div> <h2 id="declaration-statements">Declaration statements</h2> <p>A <em>declaration statement</em> is one that introduces one or more <em>names</em> into the enclosing statement block. The declared names may denote new variables or new <a href="items">items</a>.</p> <p>The two kinds of declaration statements are item declarations and <code>let</code> statements.</p> <div class="rule" id="r-statement.item">
<a class="rule-link" href="#r-statement.item" title="statement.item"><span>[statement<wbr>.item]</wbr></span></a> </div> <h3 id="item-declarations">Item declarations</h3> <div class="rule" id="r-statement.item.intro">
<a class="rule-link" href="#r-statement.item.intro" title="statement.item.intro"><span>[statement<wbr>.item<wbr>.intro]</wbr></wbr></span></a> </div> <p>An <em>item declaration statement</em> has a syntactic form identical to an <a href="items">item declaration</a> within a <a href="items/modules">module</a>.</p> <div class="rule" id="r-statement.item.scope">
<a class="rule-link" href="#r-statement.item.scope" title="statement.item.scope"><span>[statement<wbr>.item<wbr>.scope]</wbr></wbr></span></a> </div> <p>Declaring an item within a statement block restricts its <a href="names/scopes">scope</a> to the block containing the statement. The item is not given a <a href="paths#canonical-paths">canonical path</a> nor are any sub-items it may declare.</p> <div class="rule" id="r-statement.item.associated-scope">
<a class="rule-link" href="#r-statement.item.associated-scope" title="statement.item.associated-scope"><span>[statement<wbr>.item<wbr>.associated-scope]</wbr></wbr></span></a> </div> <p>The exception to this is that associated items defined by <a href="items/implementations">implementations</a> are still accessible in outer scopes as long as the item and, if applicable, trait are accessible. It is otherwise identical in meaning to declaring the item inside a module.</p> <div class="rule" id="r-statement.item.outer-generics">
<a class="rule-link" href="#r-statement.item.outer-generics" title="statement.item.outer-generics"><span>[statement<wbr>.item<wbr>.outer-generics]</wbr></wbr></span></a> </div> <p>There is no implicit capture of the containing function’s generic parameters, parameters, and local variables. For example, <code>inner</code> may not access <code>outer_var</code>.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
fn outer() {
  let outer_var = true;

  fn inner() { /* outer_var is not in scope here */ }

  inner();
}
}</pre> <div class="rule" id="r-statement.let">
<a class="rule-link" href="#r-statement.let" title="statement.let"><span>[statement<wbr>.let]</wbr></span></a> </div> <h3 id="let-statements">
<code id="">let</code> statements</h3> <div class="rule" id="r-statement.let.syntax">
<a class="rule-link" href="#r-statement.let.syntax" title="statement.let.syntax"><span>[statement<wbr>.let<wbr>.syntax]</wbr></wbr></span></a> </div> <div class="grammar-container"> <p><strong><sup>Syntax</sup></strong> <br> <span class="grammar-text grammar-production" id="grammar-LetStatement" onclick="show_railroad()"><a href="statements#railroad-LetStatement">LetStatement</a></span> → <br> <span class="grammar-text"><a href="attributes#grammar-OuterAttribute">OuterAttribute</a></span><sup>*</sup> <span class="grammar-literal">let</span> <span class="grammar-text"><a href="patterns#grammar-PatternNoTopAlt">PatternNoTopAlt</a></span> ( <span class="grammar-literal">:</span> <span class="grammar-text"><a href="types#grammar-Type">Type</a></span> )<sup>?</sup> <br> ( <br> <span class="grammar-literal">=</span> <span class="grammar-text"><a href="expressions#grammar-Expression">Expression</a></span> <br> | <span class="grammar-literal">=</span> <span class="grammar-text"><a href="expressions#grammar-Expression">Expression</a></span><sub class="grammar-text">except <a href="expressions/operator-expr#grammar-LazyBooleanExpression">LazyBooleanExpression</a> or end with a <code>}</code></sub> <span class="grammar-literal">else</span> <span class="grammar-text"><a href="expressions/block-expr#grammar-BlockExpression">BlockExpression</a></span> <br> )<sup>?</sup> <span class="grammar-literal">;</span></p> <p><button class="grammar-toggle-railroad" type="button" title="Toggle railroad display" onclick="toggle_railroad()">Show Railroad</button></p> </div> <div class="grammar-railroad grammar-hidden"> <div style="width: 852px; height: auto; max-width: 100%; max-height: 100%" class="railroad-production" id="railroad-LetStatement">
<svg class="railroad" viewbox="0 0 852 235" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">  <g class="verticalgrid"> <a class="link" xlink:href="statements.html#grammar-LetStatement"> <text class="comment" x="57" y="25"> LetStatement</text> </a> <g class="sequence">  <g class="stack">   <g class="sequence"> <g class="optional">  <g class="repeat">   <a class="link" xlink:href="attributes.html#railroad-OuterAttribute"> <g class="nonterminal">  <text x="149" y="71"> OuterAttribute</text> </g> </a> </g> </g> <g class="terminal">  <text x="283" y="71"> let</text> </g> <a class="link" xlink:href="patterns.html#railroad-PatternNoTopAlt"> <g class="nonterminal">  <text x="385" y="71"> PatternNoTopAlt</text> </g> </a> <g class="optional">  <g class="sequence"> <g class="terminal">  <text x="503" y="71"> :</text> </g> <a class="link" xlink:href="types.html#railroad-Type"> <g class="nonterminal">  <text x="553" y="71"> Type</text> </g> </a>  </g> </g>    </g>  <g class="sequence"> <g class="optional">  <g class="choice">  <g class="sequence"> <g class="terminal">  <text x="109" y="143"> =</text> </g> <a class="link" xlink:href="expressions.html#railroad-Expression"> <g class="nonterminal">  <text x="183" y="143"> Expression</text> </g> </a>  </g>   <g class="sequence"> <g class="terminal">  <text x="109" y="211"> =</text> </g> <g class="labeledbox">   <text class="comment" x="314" y="182"> except LazyBooleanExpression or end with a `}`</text> <a class="link" xlink:href="expressions.html#railroad-Expression"> <g class="nonterminal">  <text x="191" y="211"> Expression</text> </g> </a> </g> <g class="terminal">  <text x="531" y="211"> else</text> </g> <a class="link" xlink:href="expressions/block-expr.html#railroad-BlockExpression"> <g class="nonterminal">  <text x="637" y="211"> BlockExpression</text> </g> </a>    </g> </g> </g> <g class="terminal">  <text x="779" y="143"> ;</text> </g>  </g> </g>    </g> </g> </svg> </div> </div> <div class="rule" id="r-statement.let.intro">
<a class="rule-link" href="#r-statement.let.intro" title="statement.let.intro"><span>[statement<wbr>.let<wbr>.intro]</wbr></wbr></span></a> </div> <p>A <em><code>let</code> statement</em> introduces a new set of <a href="variables">variables</a>, given by a <a href="patterns">pattern</a>. The pattern is followed optionally by a type annotation and then either ends, or is followed by an initializer expression plus an optional <code>else</code> block.</p> <div class="rule" id="r-statement.let.inference">
<a class="rule-link" href="#r-statement.let.inference" title="statement.let.inference"><span>[statement<wbr>.let<wbr>.inference]</wbr></wbr></span></a> </div> <p>When no type annotation is given, the compiler will infer the type, or signal an error if insufficient type information is available for definite inference.</p> <div class="rule" id="r-statement.let.scope">
<a class="rule-link" href="#r-statement.let.scope" title="statement.let.scope"><span>[statement<wbr>.let<wbr>.scope]</wbr></wbr></span></a> </div> <p>Any variables introduced by a variable declaration are visible from the point of declaration until the end of the enclosing block scope, except when they are shadowed by another variable declaration.</p> <div class="rule" id="r-statement.let.constraint">
<a class="rule-link" href="#r-statement.let.constraint" title="statement.let.constraint"><span>[statement<wbr>.let<wbr>.constraint]</wbr></wbr></span></a> </div> <p>If an <code>else</code> block is not present, the pattern must be irrefutable. If an <code>else</code> block is present, the pattern may be refutable.</p> <div class="rule" id="r-statement.let.behavior">
<a class="rule-link" href="#r-statement.let.behavior" title="statement.let.behavior"><span>[statement<wbr>.let<wbr>.behavior]</wbr></wbr></span></a> </div> <p>If the pattern does not match (this requires it to be refutable), the <code>else</code> block is executed. The <code>else</code> block must always diverge (evaluate to the <a href="types/never">never type</a>).</p> <pre data-language="rust">#![allow(unused)]
fn main() {
let (mut v, w) = (vec![1, 2, 3], 42); // The bindings may be mut or const
let Some(t) = v.pop() else { // Refutable patterns require an else block
    panic!(); // The else block must diverge
};
let [u, v] = [v[0], v[1]] else { // This pattern is irrefutable, so the compiler
                                 // will lint as the else block is redundant.
    panic!();
};
}</pre> <div class="rule" id="r-statement.expr">
<a class="rule-link" href="#r-statement.expr" title="statement.expr"><span>[statement<wbr>.expr]</wbr></span></a> </div> <h2 id="expression-statements">Expression statements</h2> <div class="rule" id="r-statement.expr.syntax">
<a class="rule-link" href="#r-statement.expr.syntax" title="statement.expr.syntax"><span>[statement<wbr>.expr<wbr>.syntax]</wbr></wbr></span></a> </div> <div class="grammar-container"> <p><strong><sup>Syntax</sup></strong> <br> <span class="grammar-text grammar-production" id="grammar-ExpressionStatement" onclick="show_railroad()"><a href="statements#railroad-ExpressionStatement">ExpressionStatement</a></span> → <br> <span class="grammar-text"><a href="expressions#grammar-ExpressionWithoutBlock">ExpressionWithoutBlock</a></span> <span class="grammar-literal">;</span> <br> | <span class="grammar-text"><a href="expressions#grammar-ExpressionWithBlock">ExpressionWithBlock</a></span> <span class="grammar-literal">;</span><sup>?</sup></p> <p><button class="grammar-toggle-railroad" type="button" title="Toggle railroad display" onclick="toggle_railroad()">Show Railroad</button></p> </div> <div class="grammar-railroad grammar-hidden"> <div style="width: 376px; height: auto; max-width: 100%; max-height: 100%" class="railroad-production" id="railroad-ExpressionStatement">
<svg class="railroad" viewbox="0 0 376 119" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">  <g class="verticalgrid"> <a class="link" xlink:href="statements.html#grammar-ExpressionStatement"> <text class="comment" x="81" y="25"> ExpressionStatement</text> </a> <g class="sequence">  <g class="choice">  <g class="sequence"> <a class="link" xlink:href="expressions.html#railroad-ExpressionWithoutBlock"> <g class="nonterminal">  <text x="161" y="58"> ExpressionWithoutBlock</text> </g> </a> <g class="terminal">  <text x="287" y="58"> ;</text> </g>  </g>   <g class="sequence"> <a class="link" xlink:href="expressions.html#railroad-ExpressionWithBlock"> <g class="nonterminal">  <text x="145" y="103"> ExpressionWithBlock</text> </g> </a> <g class="optional">  <g class="terminal">  <text x="279" y="103"> ;</text> </g> </g>  </g> </g>    </g> </g> </svg> </div> </div> <div class="rule" id="r-statement.expr.intro">
<a class="rule-link" href="#r-statement.expr.intro" title="statement.expr.intro"><span>[statement<wbr>.expr<wbr>.intro]</wbr></wbr></span></a> </div> <p>An <em>expression statement</em> is one that evaluates an <a href="expressions">expression</a> and ignores its result. As a rule, an expression statement’s purpose is to trigger the effects of evaluating its expression.</p> <div class="rule" id="r-statement.expr.restriction-semicolon">
<a class="rule-link" href="#r-statement.expr.restriction-semicolon" title="statement.expr.restriction-semicolon"><span>[statement<wbr>.expr<wbr>.restriction-semicolon]</wbr></wbr></span></a> </div> <p>An expression that consists of only a <a href="expressions/block-expr">block expression</a> or control flow expression, if used in a context where a statement is permitted, can omit the trailing semicolon. This can cause an ambiguity between it being parsed as a standalone statement and as a part of another expression; in this case, it is parsed as a statement.</p> <div class="rule" id="r-statement.expr.constraint-block">
<a class="rule-link" href="#r-statement.expr.constraint-block" title="statement.expr.constraint-block"><span>[statement<wbr>.expr<wbr>.constraint-block]</wbr></wbr></span></a> </div> <p>The type of <a href="expressions#grammar-ExpressionWithBlock">ExpressionWithBlock</a> expressions when used as statements must be the unit type.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
let mut v = vec![1, 2, 3];
v.pop();          // Ignore the element returned from pop
if v.is_empty() {
    v.push(5);
} else {
    v.remove(0);
}                 // Semicolon can be omitted.
[1];              // Separate expression statement, not an indexing expression.
}</pre> <p>When the trailing semicolon is omitted, the result must be type <code>()</code>.</p> <pre data-language="rust">#![allow(unused)]
fn main() {
// bad: the block's type is i32, not ()
// Error: expected `()` because of default return type
// if true {
//   1
// }

// good: the block's type is i32
if true {
  1
} else {
  2
};
}</pre> <div class="rule" id="r-statement.attribute">
<a class="rule-link" href="#r-statement.attribute" title="statement.attribute"><span>[statement<wbr>.attribute]</wbr></span></a> </div> <h2 id="attributes-on-statements">Attributes on Statements</h2> <p>Statements accept <a href="attributes">outer attributes</a>. The attributes that have meaning on a statement are <a href="conditional-compilation"><code>cfg</code></a>, and <a href="attributes/diagnostics#lint-check-attributes">the lint check attributes</a>.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/reference/statements.html" class="_attribution-link">https://doc.rust-lang.org/reference/statements.html</a>
  </p>
</div>
</div>
            </main>
        </div>
    </div>
    <script type="text/javascript" src="../assets/index.js"></script>
</body>

</html>