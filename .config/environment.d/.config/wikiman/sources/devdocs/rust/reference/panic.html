<html class="_theme-default">
<head>
    <meta charset="utf-8">
    <title>.. The panic_handler attribute</title>
    
    <link rel="preload" href="../assets/index.js" as="script" type="text/javascript" />

    <link rel="stylesheet" type="text/css" href="../application.css" />
    <link rel="stylesheet" type="text/css" href="../assets/index.css" />
</head>
<body>
    <div class="_app">
        <devdocs-navbar current="reference/panic" prefix="../" listing-src="../navbar.json"></devdocs-navbar>
        <div class="_container">
            <main class="_content">
                <div class="_page _rust"><h1 class="rule" id="r-panic">
<a class="rule-link" href="#r-panic" title="panic"><span>[panic]</span></a> </h1> <h1 id="panic">Panic</h1> <div class="rule" id="r-panic.intro">
<a class="rule-link" href="#r-panic.intro" title="panic.intro"><span>[panic<wbr>.intro]</wbr></span></a> </div> <p>Rust provides a mechanism to prevent a function from returning normally, and instead “panic,” which is a response to an error condition that is typically not expected to be recoverable within the context in which the error is encountered.</p> <div class="rule" id="r-panic.lang-ops">
<a class="rule-link" href="#r-panic.lang-ops" title="panic.lang-ops"><span>[panic<wbr>.lang-ops]</wbr></span></a> </div> <p>Some language constructs, such as out-of-bounds <a href="expressions/array-expr#array-and-slice-indexing-expressions">array indexing</a>, panic automatically.</p> <div class="rule" id="r-panic.control">
<a class="rule-link" href="#r-panic.control" title="panic.control"><span>[panic<wbr>.control]</wbr></span></a> </div> <p>There are also language features that provide a level of control over panic behavior:</p> <ul> <li>A <a href="#the-panic_handler-attribute"><em>panic handler</em></a> defines the behavior of a panic.</li> <li>
<a href="items/functions#unwinding">FFI ABIs</a> may alter how panics behave.</li> </ul> <div class="alert alert-note"> <blockquote> <p class="alert-title">Note</p> <p>The standard library provides the capability to explicitly panic via the <a href="../std/macro.panic"><code>panic!</code> macro</a>.</p> </blockquote> </div> <div class="rule" id="r-panic.panic_handler">
<a class="rule-link" href="#r-panic.panic_handler" title="panic.panic_handler"><span>[panic<wbr>.panic_handler]</wbr></span></a> </div> <h2 id="the-panic_handler-attribute">The <code id="">panic_handler</code> attribute</h2> <div class="rule" id="r-panic.panic_handler.intro">
<a class="rule-link" href="#r-panic.panic_handler.intro" title="panic.panic_handler.intro"><span>[panic<wbr>.panic_handler<wbr>.intro]</wbr></wbr></span></a> </div> <p>The <em><code>panic_handler</code> attribute</em> can be applied to a function to define the behavior of panics.</p> <div class="rule" id="r-panic.panic_handler.allowed-positions">
<a class="rule-link" href="#r-panic.panic_handler.allowed-positions" title="panic.panic_handler.allowed-positions"><span>[panic<wbr>.panic_handler<wbr>.allowed-positions]</wbr></wbr></span></a> </div> <p>The <code>panic_handler</code> attribute can only be applied to a function with signature <code>fn(&amp;PanicInfo) -&gt; !</code>.</p> <div class="alert alert-note"> <blockquote> <p class="alert-title">Note</p> <p>The <a href="https://doc.rust-lang.org/core/panic/panic_info/struct.PanicInfo.html"><code>PanicInfo</code></a> struct contains information about the location of the panic.</p> </blockquote> </div> <div class="rule" id="r-panic.panic_handler.unique">
<a class="rule-link" href="#r-panic.panic_handler.unique" title="panic.panic_handler.unique"><span>[panic<wbr>.panic_handler<wbr>.unique]</wbr></wbr></span></a> </div> <p>There must be a single <code>panic_handler</code> function in the dependency graph.</p> <p>Below is shown a <code>panic_handler</code> function that logs the panic message and then halts the thread.</p>  <pre data-language="rust">#![no_std]

use core::fmt::{self, Write};
use core::panic::PanicInfo;

struct Sink {
    // ..
   _0: (),
}

impl Sink {
    fn new() -&gt; Sink { Sink { _0: () }}
}

impl fmt::Write for Sink {
    fn write_str(&amp;mut self, _: &amp;str) -&gt; fmt::Result { Ok(()) }
}

#[panic_handler]
fn panic(info: &amp;PanicInfo) -&gt; ! {
    let mut sink = Sink::new();

    // logs "panicked at '$reason', src/main.rs:27:4" to some `sink`
    let _ = writeln!(sink, "{}", info);

    loop {}
}</pre> <div class="rule" id="r-panic.panic_handler.std">
<a class="rule-link" href="#r-panic.panic_handler.std" title="panic.panic_handler.std"><span>[panic<wbr>.panic_handler<wbr>.std]</wbr></wbr></span></a> </div> <h3 id="standard-behavior">Standard behavior</h3> <div class="rule" id="r-panic.panic_handler.std.kinds">
<a class="rule-link" href="#r-panic.panic_handler.std.kinds" title="panic.panic_handler.std.kinds"><span>[panic<wbr>.panic_handler<wbr>.std<wbr>.kinds]</wbr></wbr></wbr></span></a> </div> <p><code>std</code> provides two different panic handlers:</p> <ul> <li>
<code>unwind</code> — unwinds the stack and is potentially recoverable.</li> <li>
<code>abort</code> –– aborts the process and is non-recoverable.</li> </ul> <p>Not all targets may provide the <code>unwind</code> handler.</p> <div class="alert alert-note"> <blockquote> <p class="alert-title">Note</p> <p>The panic handler used when linking with <code>std</code> can be set with the <a href="https://doc.rust-lang.org/rustc/codegen-options/index.html#panic"><code>-C panic</code></a> CLI flag. The default for most targets is <code>unwind</code>.</p> <p>The standard library’s panic behavior can be modified at runtime with the <a href="../std/panicking/fn.set_hook"><code>std::panic::set_hook</code></a> function.</p> </blockquote> </div> <div class="rule" id="r-panic.panic_handler.std.no_std">
<a class="rule-link" href="#r-panic.panic_handler.std.no_std" title="panic.panic_handler.std.no_std"><span>[panic<wbr>.panic_handler<wbr>.std<wbr>.no_std]</wbr></wbr></wbr></span></a> </div> <p>Linking a <a href="names/preludes#the-no_std-attribute"><code>no_std</code></a> binary, dylib, cdylib, or staticlib will require specifying your own panic handler.</p> <div class="rule" id="r-panic.strategy">
<a class="rule-link" href="#r-panic.strategy" title="panic.strategy"><span>[panic<wbr>.strategy]</wbr></span></a> </div> <h2 id="panic-strategy">Panic strategy</h2> <div class="rule" id="r-panic.strategy.intro">
<a class="rule-link" href="#r-panic.strategy.intro" title="panic.strategy.intro"><span>[panic<wbr>.strategy<wbr>.intro]</wbr></wbr></span></a> </div> <p>The <em>panic strategy</em> defines the kind of panic behavior that a crate is built to support.</p> <div class="alert alert-note"> <blockquote> <p class="alert-title">Note</p> <p>The panic strategy can be chosen in <code>rustc</code> with the <a href="https://doc.rust-lang.org/rustc/codegen-options/index.html#panic"><code>-C panic</code></a> CLI flag.</p> <p>When generating a binary, dylib, cdylib, or staticlib and linking with <code>std</code>, the <code>-C panic</code> CLI flag also influences which <a href="#the-panic_handler-attribute">panic handler</a> is used.</p> </blockquote> </div> <div class="alert alert-note"> <blockquote> <p class="alert-title">Note</p> <p>When compiling code with the <code>abort</code> panic strategy, the optimizer may assume that unwinding across Rust frames is impossible, which can result in both code-size and runtime speed improvements.</p> </blockquote> </div> <div class="alert alert-note"> <blockquote> <p class="alert-title">Note</p> <p>See <a href="linkage#r-link.unwinding">link.unwinding</a> for restrictions on linking crates with different panic strategies. An implication is that crates built with the <code>unwind</code> strategy can use the <code>abort</code> panic handler, but the <code>abort</code> strategy cannot use the <code>unwind</code> panic handler.</p> </blockquote> </div> <div class="rule" id="r-panic.unwind">
<a class="rule-link" href="#r-panic.unwind" title="panic.unwind"><span>[panic<wbr>.unwind]</wbr></span></a> </div> <h2 id="unwinding">Unwinding</h2> <div class="rule" id="r-panic.unwind.intro">
<a class="rule-link" href="#r-panic.unwind.intro" title="panic.unwind.intro"><span>[panic<wbr>.unwind<wbr>.intro]</wbr></wbr></span></a> </div> <p>Panicking may either be recoverable or non-recoverable, though it can be configured (by choosing a non-unwinding panic handler) to always be non-recoverable. (The converse is not true: the <code>unwind</code> handler does not guarantee that all panics are recoverable, only that panicking via the <code>panic!</code> macro and similar standard library mechanisms is recoverable.)</p> <div class="rule" id="r-panic.unwind.destruction">
<a class="rule-link" href="#r-panic.unwind.destruction" title="panic.unwind.destruction"><span>[panic<wbr>.unwind<wbr>.destruction]</wbr></wbr></span></a> </div> <p>When a panic occurs, the <code>unwind</code> handler “unwinds” Rust frames, just as C++’s <code>throw</code> unwinds C++ frames, until the panic reaches the point of recovery (for instance at a thread boundary). This means that as the panic traverses Rust frames, live objects in those frames that <a href="destructors">implement <code>Drop</code></a> will have their <code>drop</code> methods called. Thus, when normal execution resumes, no-longer-accessible objects will have been “cleaned up” just as if they had gone out of scope normally.</p> <div class="alert alert-note"> <blockquote> <p class="alert-title">Note</p> <p>As long as this guarantee of resource-cleanup is preserved, “unwinding” may be implemented without actually using the mechanism used by C++ for the target platform.</p> </blockquote> </div> <div class="alert alert-note"> <blockquote> <p class="alert-title">Note</p> <p>The standard library provides two mechanisms for recovering from a panic, <a href="../std/panic/fn.catch_unwind"><code>std::panic::catch_unwind</code></a> (which enables recovery within the panicking thread) and <a href="../std/thread/fn.spawn"><code>std::thread::spawn</code></a> (which automatically sets up panic recovery for the spawned thread so that other threads may continue running).</p> </blockquote> </div> <div class="rule" id="r-panic.unwind.ffi">
<a class="rule-link" href="#r-panic.unwind.ffi" title="panic.unwind.ffi"><span>[panic<wbr>.unwind<wbr>.ffi]</wbr></wbr></span></a> </div> <h3 id="unwinding-across-ffi-boundaries">Unwinding across FFI boundaries</h3> <div class="rule" id="r-panic.unwind.ffi.intro">
<a class="rule-link" href="#r-panic.unwind.ffi.intro" title="panic.unwind.ffi.intro"><span>[panic<wbr>.unwind<wbr>.ffi<wbr>.intro]</wbr></wbr></wbr></span></a> </div> <p>It is possible to unwind across FFI boundaries using an <a href="items/functions#unwinding">appropriate ABI declaration</a>. While useful in certain cases, this creates unique opportunities for undefined behavior, especially when multiple language runtimes are involved.</p> <div class="rule" id="r-panic.unwind.ffi.undefined">
<a class="rule-link" href="#r-panic.unwind.ffi.undefined" title="panic.unwind.ffi.undefined"><span>[panic<wbr>.unwind<wbr>.ffi<wbr>.undefined]</wbr></wbr></wbr></span></a> </div> <p>Unwinding with the wrong ABI is undefined behavior:</p> <ul> <li>Causing an unwind into Rust code from a foreign function that was called via a function declaration or pointer declared with a non-unwinding ABI, such as <code>"C"</code>, <code>"system"</code>, etc. (For example, this case occurs when such a function written in C++ throws an exception that is uncaught and propagates to Rust.)</li> <li>Calling a Rust <code>extern</code> function that unwinds (with <code>extern "C-unwind"</code> or another ABI that permits unwinding) from code that does not support unwinding, such as code compiled with GCC or Clang using <code>-fno-exceptions</code>
</li> </ul> <div class="rule" id="r-panic.unwind.ffi.catch-foreign">
<a class="rule-link" href="#r-panic.unwind.ffi.catch-foreign" title="panic.unwind.ffi.catch-foreign"><span>[panic<wbr>.unwind<wbr>.ffi<wbr>.catch-foreign]</wbr></wbr></wbr></span></a> </div> <p>Catching a foreign unwinding operation (such as a C++ exception) using <a href="../std/panic/fn.catch_unwind"><code>std::panic::catch_unwind</code></a>, <a href="../std/thread/struct.joinhandle#method.join"><code>std::thread::JoinHandle::join</code></a>, or by letting it propagate beyond the Rust <code>main()</code> function or thread root will have one of two behaviors, and it is unspecified which will occur:</p> <ul> <li>The process aborts.</li> <li>The function returns a <a href="https://doc.rust-lang.org/core/result/enum.Result.html#variant.Err"><code>Result::Err</code></a> containing an opaque type.</li> </ul> <div class="alert alert-note"> <blockquote> <p class="alert-title">Note</p> <p>Rust code compiled or linked with a different instance of the Rust standard library counts as a “foreign exception” for the purpose of this guarantee. Thus, a library that uses <code>panic!</code> and is linked against one version of the Rust standard library, invoked from an application that uses a different version of the standard library, may cause the entire application to abort even if the library is only used within a child thread.</p> </blockquote> </div> <div class="rule" id="r-panic.unwind.ffi.dispose-panic">
<a class="rule-link" href="#r-panic.unwind.ffi.dispose-panic" title="panic.unwind.ffi.dispose-panic"><span>[panic<wbr>.unwind<wbr>.ffi<wbr>.dispose-panic]</wbr></wbr></wbr></span></a> </div> <p>There are currently no guarantees about the behavior that occurs when a foreign runtime attempts to dispose of, or rethrow, a Rust <code>panic</code> payload. In other words, an unwind originated from a Rust runtime must either lead to termination of the process or be caught by the same runtime.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/reference/panic.html" class="_attribution-link">https://doc.rust-lang.org/reference/panic.html</a>
  </p>
</div>
</div>
            </main>
        </div>
    </div>
    <script type="text/javascript" src="../assets/index.js"></script>
</body>

</html>