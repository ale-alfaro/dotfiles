<html class="_theme-default">
<head>
    <meta charset="utf-8">
    <title>.. The Rust Reference</title>
    
    <link rel="preload" href="../../assets/index.js" as="script" type="text/javascript" />

    <link rel="stylesheet" type="text/css" href="../../application.css" />
    <link rel="stylesheet" type="text/css" href="../../assets/index.css" />
</head>
<body>
    <div class="_app">
        <devdocs-navbar current="reference/types/struct" prefix="../../" listing-src="../../navbar.json"></devdocs-navbar>
        <div class="_container">
            <main class="_content">
                <div class="_page _rust"><h1 class="rule" id="r-type.struct">
<a class="rule-link" href="#r-type.struct" title="type.struct"><span>[type<wbr>.struct]</wbr></span></a> </h1> <h1 id="struct-types">Struct types</h1> <div class="rule" id="r-type.struct.intro">
<a class="rule-link" href="#r-type.struct.intro" title="type.struct.intro"><span>[type<wbr>.struct<wbr>.intro]</wbr></wbr></span></a> </div> <p>A <code>struct</code> <em>type</em> is a heterogeneous product of other types, called the <em>fields</em> of the type.<sup class="footnote-reference" id="fr-structtype-1"><a href="#footnote-structtype">1</a></sup></p> <div class="rule" id="r-type.struct.constructor">
<a class="rule-link" href="#r-type.struct.constructor" title="type.struct.constructor"><span>[type<wbr>.struct<wbr>.constructor]</wbr></wbr></span></a> </div> <p>New instances of a <code>struct</code> can be constructed with a <a href="../expressions/struct-expr">struct expression</a>.</p> <div class="rule" id="r-type.struct.layout">
<a class="rule-link" href="#r-type.struct.layout" title="type.struct.layout"><span>[type<wbr>.struct<wbr>.layout]</wbr></wbr></span></a> </div> <p>The memory layout of a <code>struct</code> is undefined by default to allow for compiler optimizations like field reordering, but it can be fixed with the <a href="../type-layout#representations"><code>repr</code> attribute</a>. In either case, fields may be given in any order in a corresponding struct <em>expression</em>; the resulting <code>struct</code> value will always have the same memory layout.</p> <div class="rule" id="r-type.struct.field-visibility">
<a class="rule-link" href="#r-type.struct.field-visibility" title="type.struct.field-visibility"><span>[type<wbr>.struct<wbr>.field-visibility]</wbr></wbr></span></a> </div> <p>The fields of a <code>struct</code> may be qualified by <a href="../visibility-and-privacy">visibility modifiers</a>, to allow access to data in a struct outside a module.</p> <div class="rule" id="r-type.struct.tuple">
<a class="rule-link" href="#r-type.struct.tuple" title="type.struct.tuple"><span>[type<wbr>.struct<wbr>.tuple]</wbr></wbr></span></a> </div> <p>A <em>tuple struct</em> type is just like a struct type, except that the fields are anonymous.</p> <div class="rule" id="r-type.struct.unit">
<a class="rule-link" href="#r-type.struct.unit" title="type.struct.unit"><span>[type<wbr>.struct<wbr>.unit]</wbr></wbr></span></a> </div> <p>A <em>unit-like struct</em> type is like a struct type, except that it has no fields. The one value constructed by the associated <a href="../expressions/struct-expr">struct expression</a> is the only value that inhabits such a type.</p>  <ol class="footnote-definition">
<li id="footnote-structtype"> <p><code>struct</code> types are analogous to <code>struct</code> types in C, the <em>record</em> types of the ML family, or the <em>struct</em> types of the Lisp family. <a href="#fr-structtype-1">â†©</a></p> </li> </ol><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 The Rust Project Developers<br>Licensed under the Apache License, Version 2.0 or the MIT license, at your option.<br>
    <a href="https://doc.rust-lang.org/reference/types/struct.html" class="_attribution-link">https://doc.rust-lang.org/reference/types/struct.html</a>
  </p>
</div>
</div>
            </main>
        </div>
    </div>
    <script type="text/javascript" src="../../assets/index.js"></script>
</body>

</html>