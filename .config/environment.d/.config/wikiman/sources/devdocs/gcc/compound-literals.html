<html class="_theme-default">
<head>
    <meta charset="utf-8">
    <title>6.28. Compound Literals</title>
    
    <link rel="preload" href="assets/index.js" as="script" type="text/javascript" />

    <link rel="stylesheet" type="text/css" href="application.css" />
    <link rel="stylesheet" type="text/css" href="assets/index.css" />
</head>
<body>
    <div class="_app">
        <devdocs-navbar current="compound-literals" prefix="" listing-src="navbar.json"></devdocs-navbar>
        <div class="_container">
            <main class="_content">
                <div class="_page _gcc"><h1 class="section" id="Compound-Literals-1">6.28 Compound Literals</h1>      <p id="index-compound-literals">A compound literal looks like a cast of a brace-enclosed aggregate initializer list. Its value is an object of the type specified in the cast, containing the elements specified in the initializer. Unlike the result of a cast, a compound literal is an lvalue. ISO C99 and later support compound literals. As an extension, GCC supports compound literals also in C90 mode and in C++, although as explained below, the C++ semantics are somewhat different. </p> <p>Usually, the specified type of a compound literal is a structure. Assume that <code>struct foo</code> and <code>structure</code> are declared as shown: </p> <div class="smallexample"> <pre class="smallexample" data-language="cpp">struct foo {int a; char b[2];} structure;</pre>
</div> <p>Here is an example of constructing a <code>struct foo</code> with a compound literal: </p> <div class="smallexample"> <pre class="smallexample" data-language="cpp">structure = ((struct foo) {x + y, 'a', 0});</pre>
</div> <p>This is equivalent to writing the following: </p> <div class="smallexample"> <pre class="smallexample" data-language="cpp">{
  struct foo temp = {x + y, 'a', 0};
  structure = temp;
}</pre>
</div> <p>You can also construct an array, though this is dangerous in C++, as explained below. If all the elements of the compound literal are (made up of) simple constant expressions suitable for use in initializers of objects of static storage duration, then the compound literal can be coerced to a pointer to its first element and used in such an initializer, as shown here: </p> <div class="smallexample"> <pre class="smallexample" data-language="cpp">char **foo = (char *[]) { "x", "y", "z" };</pre>
</div> <p>Compound literals for scalar types and union types are also allowed. In the following example the variable <code>i</code> is initialized to the value <code>2</code>, the result of incrementing the unnamed object created by the compound literal. </p> <div class="smallexample"> <pre class="smallexample" data-language="cpp">int i = ++(int) { 1 };</pre>
</div> <p>As a GNU extension, GCC allows initialization of objects with static storage duration by compound literals (which is not possible in ISO C99 because the initializer is not a constant). It is handled as if the object were initialized only with the brace-enclosed list if the types of the compound literal and the object match. The elements of the compound literal must be constant. If the object being initialized has array type of unknown size, the size is determined by the size of the compound literal. </p> <div class="smallexample"> <pre class="smallexample" data-language="cpp">static struct foo x = (struct foo) {1, 'a', 'b'};
static int y[] = (int []) {1, 2, 3};
static int z[] = (int [3]) {1};</pre>
</div> <p>The above lines are equivalent to the following: </p>
<div class="smallexample"> <pre class="smallexample" data-language="cpp">static struct foo x = {1, 'a', 'b'};
static int y[] = {1, 2, 3};
static int z[] = {1, 0, 0};</pre>
</div> <p>In C, a compound literal designates an unnamed object with static or automatic storage duration. In C++, a compound literal designates a temporary object that only lives until the end of its full-expression. As a result, well-defined C code that takes the address of a subobject of a compound literal can be undefined in C++, so G++ rejects the conversion of a temporary array to a pointer. For instance, if the array compound literal example above appeared inside a function, any subsequent use of <code>foo</code> in C++ would have undefined behavior because the lifetime of the array ends after the declaration of <code>foo</code>. </p> <p>As an optimization, G++ sometimes gives array compound literals longer lifetimes: when the array either appears outside a function or has a <code>const</code>-qualified type. If <code>foo</code> and its initializer had elements of type <code>char *const</code> rather than <code>char *</code>, or if <code>foo</code> were a global variable, the array would have static storage duration. But it is probably safest just to avoid the use of array compound literals in C++ code. </p>  <p class="header"> <p> Next: <a href="designated-inits#Designated-Inits" accesskey="n" rel="next">Designated Inits</a>, Previous: <a href="initializers#Initializers" accesskey="p" rel="prev">Initializers</a>, Up: <a href="c-extensions#C-Extensions" accesskey="u" rel="up">C Extensions</a> [<a href="index#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://gcc.gnu.org/onlinedocs/gcc-9.5.0/gcc/Option-Index.html#Option-Index" title="Index" rel="index">Index</a>]</p> </p><div class="_attribution">
  <p class="_attribution-p">
    &copy; Free Software Foundation<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://gcc.gnu.org/onlinedocs/gcc-9.5.0/gcc/Compound-Literals.html" class="_attribution-link">https://gcc.gnu.org/onlinedocs/gcc-9.5.0/gcc/Compound-Literals.html</a>
  </p>
</div>
</div>
            </main>
        </div>
    </div>
    <script type="text/javascript" src="assets/index.js"></script>
</body>

</html>