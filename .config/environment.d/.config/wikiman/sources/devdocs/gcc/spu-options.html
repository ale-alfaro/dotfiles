<html class="_theme-default">
<head>
    <meta charset="utf-8">
    <title>3.18.49. SPU Options</title>
    
    <link rel="preload" href="assets/index.js" as="script" type="text/javascript" />

    <link rel="stylesheet" type="text/css" href="application.css" />
    <link rel="stylesheet" type="text/css" href="assets/index.css" />
</head>
<body>
    <div class="_app">
        <devdocs-navbar current="spu-options" prefix="" listing-src="navbar.json"></devdocs-navbar>
        <div class="_container">
            <main class="_content">
                <div class="_page _gcc"><h1 class="subsection" id="SPU-Options-1">3.18.49 SPU Options</h1>  <p id="index-SPU-options">These ‘<samp>-m</samp>’ options are supported on the SPU: </p> <dl compact> <dt><code>-mwarn-reloc</code></dt> <dt><code>-merror-reloc</code></dt> <dd>  <p id="index-merror-reloc">The loader for SPU does not handle dynamic relocations. By default, GCC gives an error when it generates code that requires a dynamic relocation. <samp>-mno-error-reloc</samp> disables the error, <samp>-mwarn-reloc</samp> generates a warning instead. </p> </dd> <dt><code>-msafe-dma</code></dt> <dt><code>-munsafe-dma</code></dt> <dd>  <p id="index-munsafe-dma">Instructions that initiate or test completion of DMA must not be reordered with respect to loads and stores of the memory that is being accessed. With <samp>-munsafe-dma</samp> you must use the <code>volatile</code> keyword to protect memory accesses, but that can lead to inefficient code in places where the memory is known to not change. Rather than mark the memory as volatile, you can use <samp>-msafe-dma</samp> to tell the compiler to treat the DMA instructions as potentially affecting all memory. </p> </dd> <dt><code>-mbranch-hints</code></dt> <dd> <p id="index-mbranch-hints">By default, GCC generates a branch hint instruction to avoid pipeline stalls for always-taken or probably-taken branches. A hint is not generated closer than 8 instructions away from its branch. There is little reason to disable them, except for debugging purposes, or to make an object a little bit smaller. </p> </dd> <dt><code>-msmall-mem</code></dt> <dt><code>-mlarge-mem</code></dt> <dd>  <p id="index-mlarge-mem">By default, GCC generates code assuming that addresses are never larger than 18 bits. With <samp>-mlarge-mem</samp> code is generated that assumes a full 32-bit address. </p> </dd> <dt><code>-mstdmain</code></dt> <dd> <p id="index-mstdmain">By default, GCC links against startup code that assumes the SPU-style main function interface (which has an unconventional parameter list). With <samp>-mstdmain</samp>, GCC links your program against startup code that assumes a C99-style interface to <code>main</code>, including a local copy of <code>argv</code> strings. </p> </dd> <dt><code>-mfixed-range=<var>register-range</var></code></dt> <dd> <p id="index-mfixed-range-3">Generate code treating the given register range as fixed registers. A fixed register is one that the register allocator cannot use. This is useful when compiling kernel code. A register range is specified as two registers separated by a dash. Multiple register ranges can be specified separated by a comma. </p> </dd> <dt><code>-mea32</code></dt> <dt><code>-mea64</code></dt> <dd>  <p id="index-mea64">Compile code assuming that pointers to the PPU address space accessed via the <code>__ea</code> named address space qualifier are either 32 or 64 bits wide. The default is 32 bits. As this is an ABI-changing option, all object code in an executable must be compiled with the same setting. </p> </dd> <dt><code>-maddress-space-conversion</code></dt> <dt><code>-mno-address-space-conversion</code></dt> <dd>  <p id="index-mno-address-space-conversion">Allow/disallow treating the <code>__ea</code> address space as superset of the generic address space. This enables explicit type casts between <code>__ea</code> and generic pointer as well as implicit conversions of generic pointers to <code>__ea</code> pointers. The default is to allow address space pointer conversions. </p> </dd> <dt><code>-mcache-size=<var>cache-size</var></code></dt> <dd> <p id="index-mcache-size">This option controls the version of libgcc that the compiler links to an executable and selects a software-managed cache for accessing variables in the <code>__ea</code> address space with a particular cache size. Possible options for <var>cache-size</var> are ‘<samp>8</samp>’, ‘<samp>16</samp>’, ‘<samp>32</samp>’, ‘<samp>64</samp>’ and ‘<samp>128</samp>’. The default cache size is 64KB. </p> </dd> <dt><code>-matomic-updates</code></dt> <dt><code>-mno-atomic-updates</code></dt> <dd>  <p id="index-mno-atomic-updates">This option controls the version of libgcc that the compiler links to an executable and selects whether atomic updates to the software-managed cache of PPU-side variables are used. If you use atomic updates, changes to a PPU variable from SPU code using the <code>__ea</code> named address space qualifier do not interfere with changes to other PPU variables residing in the same cache line from PPU code. If you do not use atomic updates, such interference may occur; however, writing back cache lines is more efficient. The default behavior is to use atomic updates. </p> </dd> <dt><code>-mdual-nops</code></dt> <dt><code>-mdual-nops=<var>n</var></code></dt> <dd> <p id="index-mdual-nops">By default, GCC inserts NOPs to increase dual issue when it expects it to increase performance. <var>n</var> can be a value from 0 to 10. A smaller <var>n</var> inserts fewer NOPs. 10 is the default, 0 is the same as <samp>-mno-dual-nops</samp>. Disabled with <samp>-Os</samp>. </p> </dd> <dt><code>-mhint-max-nops=<var>n</var></code></dt> <dd> <p id="index-mhint-max-nops">Maximum number of NOPs to insert for a branch hint. A branch hint must be at least 8 instructions away from the branch it is affecting. GCC inserts up to <var>n</var> NOPs to enforce this, otherwise it does not generate the branch hint. </p> </dd> <dt><code>-mhint-max-distance=<var>n</var></code></dt> <dd> <p id="index-mhint-max-distance">The encoding of the branch hint instruction limits the hint to be within 256 instructions of the branch it is affecting. By default, GCC makes sure it is within 125. </p> </dd> <dt><code>-msafe-hints</code></dt> <dd> <p id="index-msafe-hints">Work around a hardware bug that causes the SPU to stall indefinitely. By default, GCC inserts the <code>hbrp</code> instruction to make sure this stall won’t happen. </p> </dd> </dl>  <p class="header"> <p> Next: <a href="system-v-options#System-V-Options" accesskey="n" rel="next">System V Options</a>, Previous: <a href="sparc-options#SPARC-Options" accesskey="p" rel="prev">SPARC Options</a>, Up: <a href="submodel-options#Submodel-Options" accesskey="u" rel="up">Submodel Options</a> [<a href="index#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://gcc.gnu.org/onlinedocs/gcc-9.5.0/gcc/Option-Index.html#Option-Index" title="Index" rel="index">Index</a>]</p> </p><div class="_attribution">
  <p class="_attribution-p">
    &copy; Free Software Foundation<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://gcc.gnu.org/onlinedocs/gcc-9.5.0/gcc/SPU-Options.html" class="_attribution-link">https://gcc.gnu.org/onlinedocs/gcc-9.5.0/gcc/SPU-Options.html</a>
  </p>
</div>
</div>
            </main>
        </div>
    </div>
    <script type="text/javascript" src="assets/index.js"></script>
</body>

</html>