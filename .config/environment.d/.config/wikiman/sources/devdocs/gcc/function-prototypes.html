<html class="_theme-default">
<head>
    <meta charset="utf-8">
    <title>6.40. Prototypes and Old-Style Function Definitions</title>
    
    <link rel="preload" href="assets/index.js" as="script" type="text/javascript" />

    <link rel="stylesheet" type="text/css" href="application.css" />
    <link rel="stylesheet" type="text/css" href="assets/index.css" />
</head>
<body>
    <div class="_app">
        <devdocs-navbar current="function-prototypes" prefix="" listing-src="navbar.json"></devdocs-navbar>
        <div class="_container">
            <main class="_content">
                <div class="_page _gcc"><h1 class="section" id="Prototypes-and-Old-Style-Function-Definitions">6.40 Prototypes and Old-Style Function Definitions</h1>    <p id="index-promotion-of-formal-parameters">GNU C extends ISO C to allow a function prototype to override a later old-style non-prototype definition. Consider the following example: </p> <div class="smallexample"> <pre class="smallexample" data-language="cpp">/* <span class="roman">Use prototypes unless the compiler is old-fashioned.</span>  */
#ifdef __STDC__
#define P(x) x
#else
#define P(x) ()
#endif

/* <span class="roman">Prototype function declaration.</span>  */
int isroot P((uid_t));

/* <span class="roman">Old-style function definition.</span>  */
int
isroot (x)   /* <span class="roman">??? lossage here ???</span> */
     uid_t x;
{
  return x == 0;
}</pre>
</div> <p>Suppose the type <code>uid_t</code> happens to be <code>short</code>. ISO C does not allow this example, because subword arguments in old-style non-prototype definitions are promoted. Therefore in this example the function definitionâ€™s argument is really an <code>int</code>, which does not match the prototype argument type of <code>short</code>. </p> <p>This restriction of ISO C makes it hard to write code that is portable to traditional C compilers, because the programmer does not know whether the <code>uid_t</code> type is <code>short</code>, <code>int</code>, or <code>long</code>. Therefore, in cases like these GNU C allows a prototype to override a later old-style definition. More precisely, in GNU C, a function prototype argument type overrides the argument type specified by a later old-style definition if the former type is the same as the latter type before promotion. Thus in GNU C the above example is equivalent to the following: </p> <div class="smallexample"> <pre class="smallexample" data-language="cpp">int isroot (uid_t);

int
isroot (uid_t x)
{
  return x == 0;
}</pre>
</div> <p>GNU C++ does not support old-style function definitions, so this extension is irrelevant. </p><div class="_attribution">
  <p class="_attribution-p">
    &copy; Free Software Foundation<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://gcc.gnu.org/onlinedocs/gcc-9.5.0/gcc/Function-Prototypes.html" class="_attribution-link">https://gcc.gnu.org/onlinedocs/gcc-9.5.0/gcc/Function-Prototypes.html</a>
  </p>
</div>
</div>
            </main>
        </div>
    </div>
    <script type="text/javascript" src="assets/index.js"></script>
</body>

</html>